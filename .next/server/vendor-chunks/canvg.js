"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.cjs":
/*!******************************************!*\
  !*** ./node_modules/canvg/lib/index.cjs ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n__webpack_require__(/*! core-js/modules/es.object.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.object.to-string.js\");\n__webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.delete-property.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.delete-property.js\");\nvar _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ \"(ssr)/./node_modules/@babel/runtime/regenerator/index.js\");\nvar _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n__webpack_require__(/*! core-js/modules/es.array.map.js */ \"(ssr)/./node_modules/core-js/modules/es.array.map.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"(ssr)/./node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/es.regexp.exec.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.exec.js\");\n__webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n__webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n__webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n__webpack_require__(/*! core-js/modules/es.array.join.js */ \"(ssr)/./node_modules/core-js/modules/es.array.join.js\");\nvar _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/slicedToArray.js\");\nvar _defineProperty = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\nvar _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"(ssr)/./node_modules/@babel/runtime/helpers/classCallCheck.js\");\nvar _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"(ssr)/./node_modules/@babel/runtime/helpers/createClass.js\");\n__webpack_require__(/*! core-js/modules/es.array.concat.js */ \"(ssr)/./node_modules/core-js/modules/es.array.concat.js\");\n__webpack_require__(/*! core-js/modules/es.array.every.js */ \"(ssr)/./node_modules/core-js/modules/es.array.every.js\");\n__webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n__webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n__webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\nvar requestAnimationFrame = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n__webpack_require__(/*! core-js/modules/es.function.name.js */ \"(ssr)/./node_modules/core-js/modules/es.function.name.js\");\n__webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\nvar RGBColor = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n__webpack_require__(/*! core-js/modules/es.array.for-each.js */ \"(ssr)/./node_modules/core-js/modules/es.array.for-each.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.for-each.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.for-each.js\");\nvar _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"(ssr)/./node_modules/@babel/runtime/helpers/inherits.js\");\nvar _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"(ssr)/./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\");\nvar _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"(ssr)/./node_modules/@babel/runtime/helpers/getPrototypeOf.js\");\n__webpack_require__(/*! core-js/modules/es.array.from.js */ \"(ssr)/./node_modules/core-js/modules/es.array.from.js\");\n__webpack_require__(/*! core-js/modules/es.array.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.array.includes.js\");\n__webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n__webpack_require__(/*! core-js/modules/es.array.some.js */ \"(ssr)/./node_modules/core-js/modules/es.array.some.js\");\n__webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n__webpack_require__(/*! core-js/modules/es.string.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.string.iterator.js\");\nvar _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"(ssr)/./node_modules/@babel/runtime/helpers/toConsumableArray.js\");\n__webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n__webpack_require__(/*! core-js/modules/es.number.constructor.js */ \"(ssr)/./node_modules/core-js/modules/es.number.constructor.js\");\nvar _get = __webpack_require__(/*! @babel/runtime/helpers/get */ \"(ssr)/./node_modules/@babel/runtime/helpers/get.js\");\n__webpack_require__(/*! core-js/modules/es.array.fill.js */ \"(ssr)/./node_modules/core-js/modules/es.array.fill.js\");\nvar svgPathdata = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.cjs\");\n__webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\nvar _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ \"(ssr)/./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\n__webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n__webpack_require__(/*! core-js/modules/es.map.js */ \"(ssr)/./node_modules/core-js/modules/es.map.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.apply.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.apply.js\");\n__webpack_require__(/*! core-js/modules/es.reflect.get-prototype-of.js */ \"(ssr)/./node_modules/core-js/modules/es.reflect.get-prototype-of.js\");\nvar stackblurCanvas = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar _regeneratorRuntime__default = /*#__PURE__*/ _interopDefaultLegacy(_regeneratorRuntime);\nvar _asyncToGenerator__default = /*#__PURE__*/ _interopDefaultLegacy(_asyncToGenerator);\nvar _slicedToArray__default = /*#__PURE__*/ _interopDefaultLegacy(_slicedToArray);\nvar _defineProperty__default = /*#__PURE__*/ _interopDefaultLegacy(_defineProperty);\nvar _classCallCheck__default = /*#__PURE__*/ _interopDefaultLegacy(_classCallCheck);\nvar _createClass__default = /*#__PURE__*/ _interopDefaultLegacy(_createClass);\nvar requestAnimationFrame__default = /*#__PURE__*/ _interopDefaultLegacy(requestAnimationFrame);\nvar RGBColor__default = /*#__PURE__*/ _interopDefaultLegacy(RGBColor);\nvar _inherits__default = /*#__PURE__*/ _interopDefaultLegacy(_inherits);\nvar _possibleConstructorReturn__default = /*#__PURE__*/ _interopDefaultLegacy(_possibleConstructorReturn);\nvar _getPrototypeOf__default = /*#__PURE__*/ _interopDefaultLegacy(_getPrototypeOf);\nvar _toConsumableArray__default = /*#__PURE__*/ _interopDefaultLegacy(_toConsumableArray);\nvar _get__default = /*#__PURE__*/ _interopDefaultLegacy(_get);\nvar _assertThisInitialized__default = /*#__PURE__*/ _interopDefaultLegacy(_assertThisInitialized);\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, DOMParserFallback = _ref.DOMParser;\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas: function createCanvas(width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage: function createImage(url) {\n            return _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee() {\n                var response, blob, img;\n                return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                    while(1){\n                        switch(_context.prev = _context.next){\n                            case 0:\n                                _context.next = 2;\n                                return fetch(url);\n                            case 2:\n                                response = _context.sent;\n                                _context.next = 5;\n                                return response.blob();\n                            case 5:\n                                blob = _context.sent;\n                                _context.next = 8;\n                                return createImageBitmap(blob);\n                            case 8:\n                                img = _context.sent;\n                                return _context.abrupt(\"return\", img);\n                            case 10:\n                            case \"end\":\n                                return _context.stop();\n                        }\n                    }\n                }, _callee);\n            }))();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var DOMParser1 = _ref.DOMParser, canvas = _ref.canvas, fetch1 = _ref.fetch;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, function(num, isFloat) {\n        return rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num;\n    });\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    var _findSelectorMatch = findSelectorMatch(currentSelector, attributeRegex);\n    var _findSelectorMatch2 = _slicedToArray__default[\"default\"](_findSelectorMatch, 2);\n    currentSelector = _findSelectorMatch2[0];\n    delta = _findSelectorMatch2[1];\n    specificity[1] += delta;\n    var _findSelectorMatch3 = findSelectorMatch(currentSelector, idRegex);\n    var _findSelectorMatch4 = _slicedToArray__default[\"default\"](_findSelectorMatch3, 2);\n    currentSelector = _findSelectorMatch4[0];\n    delta = _findSelectorMatch4[1];\n    specificity[0] += delta;\n    var _findSelectorMatch5 = findSelectorMatch(currentSelector, classRegex);\n    var _findSelectorMatch6 = _slicedToArray__default[\"default\"](_findSelectorMatch5, 2);\n    currentSelector = _findSelectorMatch6[0];\n    delta = _findSelectorMatch6[1];\n    specificity[1] += delta;\n    var _findSelectorMatch7 = findSelectorMatch(currentSelector, pseudoElementRegex);\n    var _findSelectorMatch8 = _slicedToArray__default[\"default\"](_findSelectorMatch7, 2);\n    currentSelector = _findSelectorMatch8[0];\n    delta = _findSelectorMatch8[1];\n    specificity[2] += delta;\n    var _findSelectorMatch9 = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    var _findSelectorMatch10 = _slicedToArray__default[\"default\"](_findSelectorMatch9, 2);\n    currentSelector = _findSelectorMatch10[0];\n    delta = _findSelectorMatch10[1];\n    specificity[1] += delta;\n    var _findSelectorMatch11 = findSelectorMatch(currentSelector, pseudoClassRegex);\n    var _findSelectorMatch12 = _slicedToArray__default[\"default\"](_findSelectorMatch11, 2);\n    currentSelector = _findSelectorMatch12[0];\n    delta = _findSelectorMatch12[1];\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    var _findSelectorMatch13 = findSelectorMatch(currentSelector, elementRegex);\n    var _findSelectorMatch14 = _slicedToArray__default[\"default\"](_findSelectorMatch13, 2);\n    currentSelector = _findSelectorMatch14[0];\n    delta = _findSelectorMatch14[1];\n    // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nvar Property = /*#__PURE__*/ function() {\n    function Property(document1, name, value) {\n        _classCallCheck__default[\"default\"](this, Property);\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    _createClass__default[\"default\"](Property, [\n        {\n            key: \"split\",\n            value: function split() {\n                var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n                var document1 = this.document, name = this.name;\n                return compressSpaces(this.getString()).trim().split(separator).map(function(value) {\n                    return new Property(document1, name, value);\n                });\n            }\n        },\n        {\n            key: \"hasValue\",\n            value: function hasValue(zeroIsValue) {\n                var value = this.value;\n                return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n            }\n        },\n        {\n            key: \"isString\",\n            value: function isString(regexp) {\n                var value = this.value;\n                var result = typeof value === \"string\";\n                if (!result || !regexp) {\n                    return result;\n                }\n                return regexp.test(value);\n            }\n        },\n        {\n            key: \"isUrlDefinition\",\n            value: function isUrlDefinition() {\n                return this.isString(/^url\\(/);\n            }\n        },\n        {\n            key: \"isPixels\",\n            value: function isPixels() {\n                if (!this.hasValue()) {\n                    return false;\n                }\n                var asString = this.getString();\n                switch(true){\n                    case asString.endsWith(\"px\"):\n                    case /^[0-9]+$/.test(asString):\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        },\n        {\n            key: \"setValue\",\n            value: function setValue(value) {\n                this.value = value;\n                return this;\n            }\n        },\n        {\n            key: \"getValue\",\n            value: function getValue(def) {\n                if (typeof def === \"undefined\" || this.hasValue()) {\n                    return this.value;\n                }\n                return def;\n            }\n        },\n        {\n            key: \"getNumber\",\n            value: function getNumber(def) {\n                if (!this.hasValue()) {\n                    if (typeof def === \"undefined\") {\n                        return 0;\n                    }\n                    return parseFloat(def);\n                }\n                var value = this.value;\n                var n = parseFloat(value);\n                if (this.isString(/%$/)) {\n                    n /= 100.0;\n                }\n                return n;\n            }\n        },\n        {\n            key: \"getString\",\n            value: function getString(def) {\n                if (typeof def === \"undefined\" || this.hasValue()) {\n                    return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n                }\n                return String(def);\n            }\n        },\n        {\n            key: \"getColor\",\n            value: function getColor(def) {\n                var color = this.getString(def);\n                if (this.isNormalizedColor) {\n                    return color;\n                }\n                this.isNormalizedColor = true;\n                color = normalizeColor(color);\n                this.value = color;\n                return color;\n            }\n        },\n        {\n            key: \"getDpi\",\n            value: function getDpi() {\n                return 96.0; // TODO: compute?\n            }\n        },\n        {\n            key: \"getRem\",\n            value: function getRem() {\n                return this.document.rootEmSize;\n            }\n        },\n        {\n            key: \"getEm\",\n            value: function getEm() {\n                return this.document.emSize;\n            }\n        },\n        {\n            key: \"getUnits\",\n            value: function getUnits() {\n                return this.getString().replace(/[0-9.-]/g, \"\");\n            }\n        },\n        {\n            key: \"getPixels\",\n            value: function getPixels(axisOrIsFontSize) {\n                var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                var _ref = typeof axisOrIsFontSize === \"boolean\" ? [\n                    undefined,\n                    axisOrIsFontSize\n                ] : [\n                    axisOrIsFontSize\n                ], _ref2 = _slicedToArray__default[\"default\"](_ref, 2), axis = _ref2[0], isFontSize = _ref2[1];\n                var viewPort = this.document.screen.viewPort;\n                switch(true){\n                    case this.isString(/vmin$/):\n                        return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n                    case this.isString(/vmax$/):\n                        return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n                    case this.isString(/vw$/):\n                        return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n                    case this.isString(/vh$/):\n                        return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n                    case this.isString(/rem$/):\n                        return this.getNumber() * this.getRem();\n                    case this.isString(/em$/):\n                        return this.getNumber() * this.getEm();\n                    case this.isString(/ex$/):\n                        return this.getNumber() * this.getEm() / 2.0;\n                    case this.isString(/px$/):\n                        return this.getNumber();\n                    case this.isString(/pt$/):\n                        return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n                    case this.isString(/pc$/):\n                        return this.getNumber() * 15;\n                    case this.isString(/cm$/):\n                        return this.getNumber() * this.getDpi() / 2.54;\n                    case this.isString(/mm$/):\n                        return this.getNumber() * this.getDpi() / 25.4;\n                    case this.isString(/in$/):\n                        return this.getNumber() * this.getDpi();\n                    case this.isString(/%$/) && isFontSize:\n                        return this.getNumber() * this.getEm();\n                    case this.isString(/%$/):\n                        return this.getNumber() * viewPort.computeSize(axis);\n                    default:\n                        {\n                            var n = this.getNumber();\n                            if (processPercent && n < 1.0) {\n                                return n * viewPort.computeSize(axis);\n                            }\n                            return n;\n                        }\n                }\n            }\n        },\n        {\n            key: \"getMilliseconds\",\n            value: function getMilliseconds() {\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                if (this.isString(/ms$/)) {\n                    return this.getNumber();\n                }\n                return this.getNumber() * 1000;\n            }\n        },\n        {\n            key: \"getRadians\",\n            value: function getRadians() {\n                if (!this.hasValue()) {\n                    return 0;\n                }\n                switch(true){\n                    case this.isString(/deg$/):\n                        return this.getNumber() * (Math.PI / 180.0);\n                    case this.isString(/grad$/):\n                        return this.getNumber() * (Math.PI / 200.0);\n                    case this.isString(/rad$/):\n                        return this.getNumber();\n                    default:\n                        return this.getNumber() * (Math.PI / 180.0);\n                }\n            }\n        },\n        {\n            key: \"getDefinition\",\n            value: function getDefinition() {\n                var asString = this.getString();\n                var name = /#([^)'\"]+)/.exec(asString);\n                if (name) {\n                    name = name[1];\n                }\n                if (!name) {\n                    name = asString;\n                }\n                return this.document.definitions[name];\n            }\n        },\n        {\n            key: \"getFillStyleDefinition\",\n            value: function getFillStyleDefinition(element, opacity) {\n                var def = this.getDefinition();\n                if (!def) {\n                    return null;\n                } // gradient\n                if (typeof def.createGradient === \"function\") {\n                    return def.createGradient(this.document.ctx, element, opacity);\n                } // pattern\n                if (typeof def.createPattern === \"function\") {\n                    if (def.getHrefAttribute().hasValue()) {\n                        var patternTransform = def.getAttribute(\"patternTransform\");\n                        def = def.getHrefAttribute().getDefinition();\n                        if (patternTransform.hasValue()) {\n                            def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                        }\n                    }\n                    return def.createPattern(this.document.ctx, element, opacity);\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getTextBaseline\",\n            value: function getTextBaseline() {\n                if (!this.hasValue()) {\n                    return null;\n                }\n                return Property.textBaselineMapping[this.getString()];\n            }\n        },\n        {\n            key: \"addOpacity\",\n            value: function addOpacity(opacity) {\n                var value = this.getColor();\n                var len = value.length;\n                var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n                for(var i = 0; i < len; i++){\n                    if (value[i] === \",\") {\n                        commas++;\n                    }\n                    if (commas === 3) {\n                        break;\n                    }\n                }\n                if (opacity.hasValue() && this.isString() && commas !== 3) {\n                    var color = new RGBColor__default[\"default\"](value);\n                    if (color.ok) {\n                        color.alpha = opacity.getNumber();\n                        value = color.toRGBA();\n                    }\n                }\n                return new Property(this.document, this.name, value);\n            }\n        }\n    ], [\n        {\n            key: \"empty\",\n            value: function empty(document1) {\n                return new Property(document1, \"EMPTY\", \"\");\n            }\n        }\n    ]);\n    return Property;\n}();\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nvar ViewPort = /*#__PURE__*/ function() {\n    function ViewPort() {\n        _classCallCheck__default[\"default\"](this, ViewPort);\n        this.viewPorts = [];\n    }\n    _createClass__default[\"default\"](ViewPort, [\n        {\n            key: \"clear\",\n            value: function clear() {\n                this.viewPorts = [];\n            }\n        },\n        {\n            key: \"setCurrent\",\n            value: function setCurrent(width, height) {\n                this.viewPorts.push({\n                    width: width,\n                    height: height\n                });\n            }\n        },\n        {\n            key: \"removeCurrent\",\n            value: function removeCurrent() {\n                this.viewPorts.pop();\n            }\n        },\n        {\n            key: \"getCurrent\",\n            value: function getCurrent() {\n                var viewPorts = this.viewPorts;\n                return viewPorts[viewPorts.length - 1];\n            }\n        },\n        {\n            key: \"computeSize\",\n            value: function computeSize(d) {\n                if (typeof d === \"number\") {\n                    return d;\n                }\n                if (d === \"x\") {\n                    return this.width;\n                }\n                if (d === \"y\") {\n                    return this.height;\n                }\n                return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n            }\n        },\n        {\n            key: \"width\",\n            get: function get() {\n                return this.getCurrent().width;\n            }\n        },\n        {\n            key: \"height\",\n            get: function get() {\n                return this.getCurrent().height;\n            }\n        }\n    ]);\n    return ViewPort;\n}();\nvar Point = /*#__PURE__*/ function() {\n    function Point(x, y) {\n        _classCallCheck__default[\"default\"](this, Point);\n        this.x = x;\n        this.y = y;\n    }\n    _createClass__default[\"default\"](Point, [\n        {\n            key: \"angleTo\",\n            value: function angleTo(point) {\n                return Math.atan2(point.y - this.y, point.x - this.x);\n            }\n        },\n        {\n            key: \"applyTransform\",\n            value: function applyTransform(transform) {\n                var x = this.x, y = this.y;\n                var xp = x * transform[0] + y * transform[2] + transform[4];\n                var yp = x * transform[1] + y * transform[3] + transform[5];\n                this.x = xp;\n                this.y = yp;\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse(point) {\n                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n                var _toNumbers = toNumbers(point), _toNumbers2 = _slicedToArray__default[\"default\"](_toNumbers, 2), _toNumbers2$ = _toNumbers2[0], x = _toNumbers2$ === void 0 ? defaultValue : _toNumbers2$, _toNumbers2$2 = _toNumbers2[1], y = _toNumbers2$2 === void 0 ? defaultValue : _toNumbers2$2;\n                return new Point(x, y);\n            }\n        },\n        {\n            key: \"parseScale\",\n            value: function parseScale(scale) {\n                var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n                var _toNumbers3 = toNumbers(scale), _toNumbers4 = _slicedToArray__default[\"default\"](_toNumbers3, 2), _toNumbers4$ = _toNumbers4[0], x = _toNumbers4$ === void 0 ? defaultValue : _toNumbers4$, _toNumbers4$2 = _toNumbers4[1], y = _toNumbers4$2 === void 0 ? x : _toNumbers4$2;\n                return new Point(x, y);\n            }\n        },\n        {\n            key: \"parsePath\",\n            value: function parsePath(path) {\n                var points = toNumbers(path);\n                var len = points.length;\n                var pathPoints = [];\n                for(var i = 0; i < len; i += 2){\n                    pathPoints.push(new Point(points[i], points[i + 1]));\n                }\n                return pathPoints;\n            }\n        }\n    ]);\n    return Point;\n}();\nvar Mouse = /*#__PURE__*/ function() {\n    function Mouse(screen) {\n        _classCallCheck__default[\"default\"](this, Mouse);\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    _createClass__default[\"default\"](Mouse, [\n        {\n            key: \"isWorking\",\n            value: function isWorking() {\n                return this.working;\n            }\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                if (this.working) {\n                    return;\n                }\n                var screen = this.screen, onClick = this.onClick, onMouseMove = this.onMouseMove;\n                var canvas = screen.ctx.canvas;\n                canvas.onclick = onClick;\n                canvas.onmousemove = onMouseMove;\n                this.working = true;\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                if (!this.working) {\n                    return;\n                }\n                var canvas = this.screen.ctx.canvas;\n                this.working = false;\n                canvas.onclick = null;\n                canvas.onmousemove = null;\n            }\n        },\n        {\n            key: \"hasEvents\",\n            value: function hasEvents() {\n                return this.working && this.events.length > 0;\n            }\n        },\n        {\n            key: \"runEvents\",\n            value: function runEvents() {\n                if (!this.working) {\n                    return;\n                }\n                var document1 = this.screen, events = this.events, eventElements = this.eventElements;\n                var style = document1.ctx.canvas.style;\n                if (style) {\n                    style.cursor = \"\";\n                }\n                events.forEach(function(_ref, i) {\n                    var run = _ref.run;\n                    var element = eventElements[i];\n                    while(element){\n                        run(element);\n                        element = element.parent;\n                    }\n                }); // done running, clear\n                this.events = [];\n                this.eventElements = [];\n            }\n        },\n        {\n            key: \"checkPath\",\n            value: function checkPath(element, ctx) {\n                if (!this.working || !ctx) {\n                    return;\n                }\n                var events = this.events, eventElements = this.eventElements;\n                events.forEach(function(_ref2, i) {\n                    var x = _ref2.x, y = _ref2.y;\n                    if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                        eventElements[i] = element;\n                    }\n                });\n            }\n        },\n        {\n            key: \"checkBoundingBox\",\n            value: function checkBoundingBox(element, boundingBox) {\n                if (!this.working || !boundingBox) {\n                    return;\n                }\n                var events = this.events, eventElements = this.eventElements;\n                events.forEach(function(_ref3, i) {\n                    var x = _ref3.x, y = _ref3.y;\n                    if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                        eventElements[i] = element;\n                    }\n                });\n            }\n        },\n        {\n            key: \"mapXY\",\n            value: function mapXY(x, y) {\n                var _this$screen = this.screen, window1 = _this$screen.window, ctx = _this$screen.ctx;\n                var point = new Point(x, y);\n                var element = ctx.canvas;\n                while(element){\n                    point.x -= element.offsetLeft;\n                    point.y -= element.offsetTop;\n                    element = element.offsetParent;\n                }\n                if (window1.scrollX) {\n                    point.x += window1.scrollX;\n                }\n                if (window1.scrollY) {\n                    point.y += window1.scrollY;\n                }\n                return point;\n            }\n        },\n        {\n            key: \"onClick\",\n            value: function onClick(event) {\n                var _this$mapXY = this.mapXY(event.clientX, event.clientY), x = _this$mapXY.x, y = _this$mapXY.y;\n                this.events.push({\n                    type: \"onclick\",\n                    x: x,\n                    y: y,\n                    run: function run(eventTarget) {\n                        if (eventTarget.onClick) {\n                            eventTarget.onClick();\n                        }\n                    }\n                });\n            }\n        },\n        {\n            key: \"onMouseMove\",\n            value: function onMouseMove(event) {\n                var _this$mapXY2 = this.mapXY(event.clientX, event.clientY), x = _this$mapXY2.x, y = _this$mapXY2.y;\n                this.events.push({\n                    type: \"onmousemove\",\n                    x: x,\n                    y: y,\n                    run: function run(eventTarget) {\n                        if (eventTarget.onMouseMove) {\n                            eventTarget.onMouseMove();\n                        }\n                    }\n                });\n            }\n        }\n    ]);\n    return Mouse;\n}();\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nvar Screen = /*#__PURE__*/ function() {\n    function Screen(ctx) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$fetch = _ref.fetch, fetch1 = _ref$fetch === void 0 ? defaultFetch$1 : _ref$fetch, _ref$window = _ref.window, window1 = _ref$window === void 0 ? defaultWindow : _ref$window;\n        _classCallCheck__default[\"default\"](this, Screen);\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    _createClass__default[\"default\"](Screen, [\n        {\n            key: \"wait\",\n            value: function wait(checker) {\n                this.waits.push(checker);\n            }\n        },\n        {\n            key: \"ready\",\n            value: function ready() {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                if (!this.readyPromise) {\n                    return Promise.resolve();\n                }\n                return this.readyPromise;\n            }\n        },\n        {\n            key: \"isReady\",\n            value: function isReady() {\n                if (this.isReadyLock) {\n                    return true;\n                }\n                var isReadyLock = this.waits.every(function(_) {\n                    return _();\n                });\n                if (isReadyLock) {\n                    this.waits = [];\n                    if (this.resolveReady) {\n                        this.resolveReady();\n                    }\n                }\n                this.isReadyLock = isReadyLock;\n                return isReadyLock;\n            }\n        },\n        {\n            key: \"setDefaults\",\n            value: function setDefaults(ctx) {\n                // initial values and defaults\n                ctx.strokeStyle = \"rgba(0,0,0,0)\";\n                ctx.lineCap = \"butt\";\n                ctx.lineJoin = \"miter\";\n                ctx.miterLimit = 4;\n            }\n        },\n        {\n            key: \"setViewBox\",\n            value: function setViewBox(_ref2) {\n                var document1 = _ref2.document, ctx = _ref2.ctx, aspectRatio = _ref2.aspectRatio, width = _ref2.width, desiredWidth = _ref2.desiredWidth, height = _ref2.height, desiredHeight = _ref2.desiredHeight, _ref2$minX = _ref2.minX, minX = _ref2$minX === void 0 ? 0 : _ref2$minX, _ref2$minY = _ref2.minY, minY = _ref2$minY === void 0 ? 0 : _ref2$minY, refX = _ref2.refX, refY = _ref2.refY, _ref2$clip = _ref2.clip, clip = _ref2$clip === void 0 ? false : _ref2$clip, _ref2$clipX = _ref2.clipX, clipX = _ref2$clipX === void 0 ? 0 : _ref2$clipX, _ref2$clipY = _ref2.clipY, clipY = _ref2$clipY === void 0 ? 0 : _ref2$clipY;\n                // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n                var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n                var _cleanAspectRatio$spl = cleanAspectRatio.split(\" \"), _cleanAspectRatio$spl2 = _slicedToArray__default[\"default\"](_cleanAspectRatio$spl, 2), aspectRatioAlign = _cleanAspectRatio$spl2[0], aspectRatioMeetOrSlice = _cleanAspectRatio$spl2[1];\n                var align = aspectRatioAlign || \"xMidYMid\";\n                var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n                var scaleX = width / desiredWidth;\n                var scaleY = height / desiredHeight;\n                var scaleMin = Math.min(scaleX, scaleY);\n                var scaleMax = Math.max(scaleX, scaleY);\n                var finalDesiredWidth = desiredWidth;\n                var finalDesiredHeight = desiredHeight;\n                if (meetOrSlice === \"meet\") {\n                    finalDesiredWidth *= scaleMin;\n                    finalDesiredHeight *= scaleMin;\n                }\n                if (meetOrSlice === \"slice\") {\n                    finalDesiredWidth *= scaleMax;\n                    finalDesiredHeight *= scaleMax;\n                }\n                var refXProp = new Property(document1, \"refX\", refX);\n                var refYProp = new Property(document1, \"refY\", refY);\n                var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n                if (hasRefs) {\n                    ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n                }\n                if (clip) {\n                    var scaledClipX = scaleMin * clipX;\n                    var scaledClipY = scaleMin * clipY;\n                    ctx.beginPath();\n                    ctx.moveTo(scaledClipX, scaledClipY);\n                    ctx.lineTo(width, scaledClipY);\n                    ctx.lineTo(width, height);\n                    ctx.lineTo(scaledClipX, height);\n                    ctx.closePath();\n                    ctx.clip();\n                }\n                if (!hasRefs) {\n                    var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n                    var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n                    var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n                    var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n                    if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                        ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n                    }\n                    if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                        ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n                    }\n                    if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                        ctx.translate(width - finalDesiredWidth, 0);\n                    }\n                    if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                        ctx.translate(0, height - finalDesiredHeight);\n                    }\n                } // scale\n                switch(true){\n                    case align === \"none\":\n                        ctx.scale(scaleX, scaleY);\n                        break;\n                    case meetOrSlice === \"meet\":\n                        ctx.scale(scaleMin, scaleMin);\n                        break;\n                    case meetOrSlice === \"slice\":\n                        ctx.scale(scaleMax, scaleMax);\n                        break;\n                } // translate\n                ctx.translate(-minX, -minY);\n            }\n        },\n        {\n            key: \"start\",\n            value: function start(element) {\n                var _this = this;\n                var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref3$enableRedraw = _ref3.enableRedraw, enableRedraw = _ref3$enableRedraw === void 0 ? false : _ref3$enableRedraw, _ref3$ignoreMouse = _ref3.ignoreMouse, ignoreMouse = _ref3$ignoreMouse === void 0 ? false : _ref3$ignoreMouse, _ref3$ignoreAnimation = _ref3.ignoreAnimation, ignoreAnimation = _ref3$ignoreAnimation === void 0 ? false : _ref3$ignoreAnimation, _ref3$ignoreDimension = _ref3.ignoreDimensions, ignoreDimensions = _ref3$ignoreDimension === void 0 ? false : _ref3$ignoreDimension, _ref3$ignoreClear = _ref3.ignoreClear, ignoreClear = _ref3$ignoreClear === void 0 ? false : _ref3$ignoreClear, forceRedraw = _ref3.forceRedraw, scaleWidth = _ref3.scaleWidth, scaleHeight = _ref3.scaleHeight, offsetX = _ref3.offsetX, offsetY = _ref3.offsetY;\n                var FRAMERATE = this.FRAMERATE, mouse = this.mouse;\n                var frameDuration = 1000 / FRAMERATE;\n                this.frameDuration = frameDuration;\n                this.readyPromise = new Promise(function(resolve) {\n                    _this.resolveReady = resolve;\n                });\n                if (this.isReady()) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                }\n                if (!enableRedraw) {\n                    return;\n                }\n                var now = Date.now();\n                var then = now;\n                var delta = 0;\n                var tick = function tick() {\n                    now = Date.now();\n                    delta = now - then;\n                    if (delta >= frameDuration) {\n                        then = now - delta % frameDuration;\n                        if (_this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                            _this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                            mouse.runEvents();\n                        }\n                    }\n                    _this.intervalId = requestAnimationFrame__default[\"default\"](tick);\n                };\n                if (!ignoreMouse) {\n                    mouse.start();\n                }\n                this.intervalId = requestAnimationFrame__default[\"default\"](tick);\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                if (this.intervalId) {\n                    requestAnimationFrame__default[\"default\"].cancel(this.intervalId);\n                    this.intervalId = null;\n                }\n                this.mouse.stop();\n            }\n        },\n        {\n            key: \"shouldUpdate\",\n            value: function shouldUpdate(ignoreAnimation, forceRedraw) {\n                // need update from animations?\n                if (!ignoreAnimation) {\n                    var frameDuration = this.frameDuration;\n                    var shouldUpdate = this.animations.reduce(function(shouldUpdate, animation) {\n                        return animation.update(frameDuration) || shouldUpdate;\n                    }, false);\n                    if (shouldUpdate) {\n                        return true;\n                    }\n                } // need update from redraw?\n                if (typeof forceRedraw === \"function\" && forceRedraw()) {\n                    return true;\n                }\n                if (!this.isReadyLock && this.isReady()) {\n                    return true;\n                } // need update from mouse events?\n                if (this.mouse.hasEvents()) {\n                    return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n                var CLIENT_WIDTH = this.CLIENT_WIDTH, CLIENT_HEIGHT = this.CLIENT_HEIGHT, viewPort = this.viewPort, ctx = this.ctx, isFirstRender = this.isFirstRender;\n                var canvas = ctx.canvas;\n                viewPort.clear();\n                if (canvas.width && canvas.height) {\n                    viewPort.setCurrent(canvas.width, canvas.height);\n                } else {\n                    viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n                }\n                var widthStyle = element.getStyle(\"width\");\n                var heightStyle = element.getStyle(\"height\");\n                if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n                    // set canvas size\n                    if (widthStyle.hasValue()) {\n                        canvas.width = widthStyle.getPixels(\"x\");\n                        if (canvas.style) {\n                            canvas.style.width = \"\".concat(canvas.width, \"px\");\n                        }\n                    }\n                    if (heightStyle.hasValue()) {\n                        canvas.height = heightStyle.getPixels(\"y\");\n                        if (canvas.style) {\n                            canvas.style.height = \"\".concat(canvas.height, \"px\");\n                        }\n                    }\n                }\n                var cWidth = canvas.clientWidth || canvas.width;\n                var cHeight = canvas.clientHeight || canvas.height;\n                if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n                    cWidth = widthStyle.getPixels(\"x\");\n                    cHeight = heightStyle.getPixels(\"y\");\n                }\n                viewPort.setCurrent(cWidth, cHeight);\n                if (typeof offsetX === \"number\") {\n                    element.getAttribute(\"x\", true).setValue(offsetX);\n                }\n                if (typeof offsetY === \"number\") {\n                    element.getAttribute(\"y\", true).setValue(offsetY);\n                }\n                if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n                    var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n                    var xRatio = 0;\n                    var yRatio = 0;\n                    if (typeof scaleWidth === \"number\") {\n                        var _widthStyle = element.getStyle(\"width\");\n                        if (_widthStyle.hasValue()) {\n                            xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                        } else if (!isNaN(viewBox[2])) {\n                            xRatio = viewBox[2] / scaleWidth;\n                        }\n                    }\n                    if (typeof scaleHeight === \"number\") {\n                        var _heightStyle = element.getStyle(\"height\");\n                        if (_heightStyle.hasValue()) {\n                            yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                        } else if (!isNaN(viewBox[3])) {\n                            yRatio = viewBox[3] / scaleHeight;\n                        }\n                    }\n                    if (!xRatio) {\n                        xRatio = yRatio;\n                    }\n                    if (!yRatio) {\n                        yRatio = xRatio;\n                    }\n                    element.getAttribute(\"width\", true).setValue(scaleWidth);\n                    element.getAttribute(\"height\", true).setValue(scaleHeight);\n                    var transformStyle = element.getStyle(\"transform\", true, true);\n                    transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n                } // clear and render\n                if (!ignoreClear) {\n                    ctx.clearRect(0, 0, cWidth, cHeight);\n                }\n                element.render(ctx);\n                if (isFirstRender) {\n                    this.isFirstRender = false;\n                }\n            }\n        }\n    ]);\n    return Screen;\n}();\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar defaultFetch = Screen.defaultFetch;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nvar Parser = /*#__PURE__*/ function() {\n    function Parser() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref$fetch = _ref.fetch, fetch1 = _ref$fetch === void 0 ? defaultFetch : _ref$fetch, _ref$DOMParser = _ref.DOMParser, DOMParser1 = _ref$DOMParser === void 0 ? DefaultDOMParser : _ref$DOMParser;\n        _classCallCheck__default[\"default\"](this, Parser);\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    _createClass__default[\"default\"](Parser, [\n        {\n            key: \"parse\",\n            value: function() {\n                var _parse = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(resource) {\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    if (!resource.startsWith(\"<\")) {\n                                        _context.next = 2;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\", this.parseFromString(resource));\n                                case 2:\n                                    return _context.abrupt(\"return\", this.load(resource));\n                                case 3:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this);\n                }));\n                function parse(_x) {\n                    return _parse.apply(this, arguments);\n                }\n                return parse;\n            }()\n        },\n        {\n            key: \"parseFromString\",\n            value: function parseFromString(xml) {\n                var parser = new this.DOMParser();\n                try {\n                    return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n                } catch (err) {\n                    return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n                }\n            }\n        },\n        {\n            key: \"checkDocument\",\n            value: function checkDocument(document1) {\n                var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n                if (parserError) {\n                    throw new Error(parserError.textContent);\n                }\n                return document1;\n            }\n        },\n        {\n            key: \"load\",\n            value: function() {\n                var _load = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(url) {\n                    var response, xml;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    _context2.next = 2;\n                                    return this.fetch(url);\n                                case 2:\n                                    response = _context2.sent;\n                                    _context2.next = 5;\n                                    return response.text();\n                                case 5:\n                                    xml = _context2.sent;\n                                    return _context2.abrupt(\"return\", this.parseFromString(xml));\n                                case 7:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2, this);\n                }));\n                function load(_x2) {\n                    return _load.apply(this, arguments);\n                }\n                return load;\n            }()\n        }\n    ]);\n    return Parser;\n}();\nvar Translate = /*#__PURE__*/ function() {\n    function Translate(_, point) {\n        _classCallCheck__default[\"default\"](this, Translate);\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    _createClass__default[\"default\"](Translate, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var _this$point = this.point, x = _this$point.x, y = _this$point.y;\n                ctx.translate(x || 0.0, y || 0.0);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var _this$point2 = this.point, x = _this$point2.x, y = _this$point2.y;\n                ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var _this$point3 = this.point, x = _this$point3.x, y = _this$point3.y;\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    x || 0.0,\n                    y || 0.0\n                ]);\n            }\n        }\n    ]);\n    return Translate;\n}();\nvar Rotate = /*#__PURE__*/ function() {\n    function Rotate(document1, rotate, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Rotate);\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    _createClass__default[\"default\"](Rotate, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle = this.angle;\n                var tx = cx + originX.getPixels(\"x\");\n                var ty = cy + originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.rotate(angle.getRadians());\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var cx = this.cx, cy = this.cy, originX = this.originX, originY = this.originY, angle = this.angle;\n                var tx = cx + originX.getPixels(\"x\");\n                var ty = cy + originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.rotate(-1.0 * angle.getRadians());\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var cx = this.cx, cy = this.cy, angle = this.angle;\n                var rad = angle.getRadians();\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    cx || 0.0,\n                    cy || 0.0 // this.p.y\n                ]);\n                point.applyTransform([\n                    Math.cos(rad),\n                    Math.sin(rad),\n                    -Math.sin(rad),\n                    Math.cos(rad),\n                    0,\n                    0\n                ]);\n                point.applyTransform([\n                    1,\n                    0,\n                    0,\n                    1,\n                    -cx || 0.0,\n                    -cy || 0.0 // -this.p.y\n                ]);\n            }\n        }\n    ]);\n    return Rotate;\n}();\nvar Scale = /*#__PURE__*/ function() {\n    function Scale(_, scale, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Scale);\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    _createClass__default[\"default\"](Scale, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var _this$scale = this.scale, x = _this$scale.x, y = _this$scale.y, originX = this.originX, originY = this.originY;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.scale(x, y || x);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var _this$scale2 = this.scale, x = _this$scale2.x, y = _this$scale2.y, originX = this.originX, originY = this.originY;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.scale(1.0 / x, 1.0 / y || x);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var _this$scale3 = this.scale, x = _this$scale3.x, y = _this$scale3.y;\n                point.applyTransform([\n                    x || 0.0,\n                    0,\n                    0,\n                    y || 0.0,\n                    0,\n                    0\n                ]);\n            }\n        }\n    ]);\n    return Scale;\n}();\nvar Matrix = /*#__PURE__*/ function() {\n    function Matrix(_, matrix, transformOrigin) {\n        _classCallCheck__default[\"default\"](this, Matrix);\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    _createClass__default[\"default\"](Matrix, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var originX = this.originX, originY = this.originY, matrix = this.matrix;\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var originX = this.originX, originY = this.originY, matrix = this.matrix;\n                var a = matrix[0];\n                var b = matrix[2];\n                var c = matrix[4];\n                var d = matrix[1];\n                var e = matrix[3];\n                var f = matrix[5];\n                var g = 0.0;\n                var h = 0.0;\n                var i = 1.0;\n                var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n                var tx = originX.getPixels(\"x\");\n                var ty = originY.getPixels(\"y\");\n                ctx.translate(tx, ty);\n                ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n                ctx.translate(-tx, -ty);\n            }\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                point.applyTransform(this.matrix);\n            }\n        }\n    ]);\n    return Matrix;\n}();\nfunction _createSuper$M(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$M();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$M() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar Skew = /*#__PURE__*/ function(_Matrix) {\n    _inherits__default[\"default\"](Skew, _Matrix);\n    var _super = _createSuper$M(Skew);\n    function Skew(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, Skew);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skew\";\n        _this.angle = null;\n        _this.angle = new Property(document1, \"angle\", skew);\n        return _this;\n    }\n    return Skew;\n}(Matrix);\nfunction _createSuper$L(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$L();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$L() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SkewX = /*#__PURE__*/ function(_Skew) {\n    _inherits__default[\"default\"](SkewX, _Skew);\n    var _super = _createSuper$L(SkewX);\n    function SkewX(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SkewX);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skewX\";\n        _this.matrix = [\n            1,\n            0,\n            Math.tan(_this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n        return _this;\n    }\n    return SkewX;\n}(Skew);\nfunction _createSuper$K(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$K();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$K() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SkewY = /*#__PURE__*/ function(_Skew) {\n    _inherits__default[\"default\"](SkewY, _Skew);\n    var _super = _createSuper$K(SkewY);\n    function SkewY(document1, skew, transformOrigin) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SkewY);\n        _this = _super.call(this, document1, skew, transformOrigin);\n        _this.type = \"skewY\";\n        _this.matrix = [\n            1,\n            Math.tan(_this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n        return _this;\n    }\n    return SkewY;\n}(Skew);\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var _transform$split = transform.split(\"(\"), _transform$split2 = _slicedToArray__default[\"default\"](_transform$split, 2), type = _transform$split2[0], value = _transform$split2[1];\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nvar Transform = /*#__PURE__*/ function() {\n    function Transform(document1, transform, transformOrigin) {\n        var _this = this;\n        _classCallCheck__default[\"default\"](this, Transform);\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach(function(transform) {\n            if (transform === \"none\") {\n                return;\n            }\n            var _parseTransform = parseTransform(transform), _parseTransform2 = _slicedToArray__default[\"default\"](_parseTransform, 2), type = _parseTransform2[0], value = _parseTransform2[1];\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                _this.transforms.push(new TransformType(_this.document, value, transformOrigin));\n            }\n        });\n    }\n    _createClass__default[\"default\"](Transform, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = 0; i < len; i++){\n                    transforms[i].apply(ctx);\n                }\n            }\n        },\n        {\n            key: \"unapply\",\n            value: function unapply(ctx) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = len - 1; i >= 0; i--){\n                    transforms[i].unapply(ctx);\n                }\n            } // TODO: applyToPoint unused ... remove?\n        },\n        {\n            key: \"applyToPoint\",\n            value: function applyToPoint(point) {\n                var transforms = this.transforms;\n                var len = transforms.length;\n                for(var i = 0; i < len; i++){\n                    transforms[i].applyToPoint(point);\n                }\n            }\n        }\n    ], [\n        {\n            key: \"fromElement\",\n            value: function fromElement(document1, element) {\n                var transformStyle = element.getStyle(\"transform\", false, true);\n                var _element$getStyle$spl = element.getStyle(\"transform-origin\", false, true).split(), _element$getStyle$spl2 = _slicedToArray__default[\"default\"](_element$getStyle$spl, 2), transformOriginXProperty = _element$getStyle$spl2[0], _element$getStyle$spl3 = _element$getStyle$spl2[1], transformOriginYProperty = _element$getStyle$spl3 === void 0 ? transformOriginXProperty : _element$getStyle$spl3;\n                var transformOrigin = [\n                    transformOriginXProperty,\n                    transformOriginYProperty\n                ];\n                if (transformStyle.hasValue()) {\n                    return new Transform(document1, transformStyle.getString(), transformOrigin);\n                }\n                return null;\n            }\n        }\n    ]);\n    return Transform;\n}();\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nvar Element = /*#__PURE__*/ function() {\n    function Element(document1, node) {\n        var _this = this;\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        _classCallCheck__default[\"default\"](this, Element);\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach(function(attribute) {\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            _this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map(function(_) {\n                return _.trim();\n            });\n            styles.forEach(function(style) {\n                if (!style) {\n                    return;\n                }\n                var _style$split$map = style.split(\":\").map(function(_) {\n                    return _.trim();\n                }), _style$split$map2 = _slicedToArray__default[\"default\"](_style$split$map, 2), name = _style$split$map2[0], value = _style$split$map2[1];\n                _this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var definitions = document1.definitions;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach(function(childNode) {\n            if (childNode.nodeType === 1) {\n                _this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    _this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    _createClass__default[\"default\"](Element, [\n        {\n            key: \"getAttribute\",\n            value: function getAttribute(name) {\n                var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var attr = this.attributes[name];\n                if (!attr && createIfNotExists) {\n                    var _attr = new Property(this.document, name, \"\");\n                    this.attributes[name] = _attr;\n                    return _attr;\n                }\n                return attr || Property.empty(this.document);\n            }\n        },\n        {\n            key: \"getHrefAttribute\",\n            value: function getHrefAttribute() {\n                for(var key in this.attributes){\n                    if (key === \"href\" || key.endsWith(\":href\")) {\n                        return this.attributes[key];\n                    }\n                }\n                return Property.empty(this.document);\n            }\n        },\n        {\n            key: \"getStyle\",\n            value: function getStyle(name) {\n                var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var style = this.styles[name];\n                if (style) {\n                    return style;\n                }\n                var attr = this.getAttribute(name);\n                if (attr !== null && attr !== void 0 && attr.hasValue()) {\n                    this.styles[name] = attr; // move up to me to cache\n                    return attr;\n                }\n                if (!skipAncestors) {\n                    var parent = this.parent;\n                    if (parent) {\n                        var parentStyle = parent.getStyle(name);\n                        if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                            return parentStyle;\n                        }\n                    }\n                }\n                if (createIfNotExists) {\n                    var _style = new Property(this.document, name, \"\");\n                    this.styles[name] = _style;\n                    return _style;\n                }\n                return style || Property.empty(this.document);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(ctx) {\n                // don't render display=none\n                // don't render visibility=hidden\n                if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n                    return;\n                }\n                ctx.save();\n                if (this.getStyle(\"mask\").hasValue()) {\n                    // mask\n                    var mask = this.getStyle(\"mask\").getDefinition();\n                    if (mask) {\n                        this.applyEffects(ctx);\n                        mask.apply(ctx, this);\n                    }\n                } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n                    // filter\n                    var filter = this.getStyle(\"filter\").getDefinition();\n                    if (filter) {\n                        this.applyEffects(ctx);\n                        filter.apply(ctx, this);\n                    }\n                } else {\n                    this.setContext(ctx);\n                    this.renderChildren(ctx);\n                    this.clearContext(ctx);\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"setContext\",\n            value: function setContext(_) {}\n        },\n        {\n            key: \"applyEffects\",\n            value: function applyEffects(ctx) {\n                // transform\n                var transform = Transform.fromElement(this.document, this);\n                if (transform) {\n                    transform.apply(ctx);\n                } // clip\n                var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n                if (clipPathStyleProp.hasValue()) {\n                    var clip = clipPathStyleProp.getDefinition();\n                    if (clip) {\n                        clip.apply(ctx);\n                    }\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(_) {}\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.children.forEach(function(child) {\n                    child.render(ctx);\n                });\n            }\n        },\n        {\n            key: \"addChild\",\n            value: function addChild(childNode) {\n                var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n                child.parent = this;\n                if (!Element.ignoreChildTypes.includes(child.type)) {\n                    this.children.push(child);\n                }\n            }\n        },\n        {\n            key: \"matchesSelector\",\n            value: function matchesSelector(selector) {\n                var _node$getAttribute;\n                var node = this.node;\n                if (typeof node.matches === \"function\") {\n                    return node.matches(selector);\n                }\n                var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n                if (!styleClasses || styleClasses === \"\") {\n                    return false;\n                }\n                return styleClasses.split(\" \").some(function(styleClass) {\n                    return \".\".concat(styleClass) === selector;\n                });\n            }\n        },\n        {\n            key: \"addStylesFromStyleDefinition\",\n            value: function addStylesFromStyleDefinition() {\n                var _this$document = this.document, styles = _this$document.styles, stylesSpecificity = _this$document.stylesSpecificity;\n                for(var selector in styles){\n                    if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                        var style = styles[selector];\n                        var specificity = stylesSpecificity[selector];\n                        if (style) {\n                            for(var name in style){\n                                var existingSpecificity = this.stylesSpecificity[name];\n                                if (typeof existingSpecificity === \"undefined\") {\n                                    existingSpecificity = \"000\";\n                                }\n                                if (specificity >= existingSpecificity) {\n                                    this.styles[name] = style[name];\n                                    this.stylesSpecificity[name] = specificity;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"removeStyles\",\n            value: function removeStyles(element, ignoreStyles) {\n                var toRestore = ignoreStyles.reduce(function(toRestore, name) {\n                    var styleProp = element.getStyle(name);\n                    if (!styleProp.hasValue()) {\n                        return toRestore;\n                    }\n                    var value = styleProp.getString();\n                    styleProp.setValue(\"\");\n                    return [].concat(_toConsumableArray__default[\"default\"](toRestore), [\n                        [\n                            name,\n                            value\n                        ]\n                    ]);\n                }, []);\n                return toRestore;\n            }\n        },\n        {\n            key: \"restoreStyles\",\n            value: function restoreStyles(element, styles) {\n                styles.forEach(function(_ref) {\n                    var _ref2 = _slicedToArray__default[\"default\"](_ref, 2), name = _ref2[0], value = _ref2[1];\n                    element.getStyle(name, true).setValue(value);\n                });\n            }\n        },\n        {\n            key: \"isFirstChild\",\n            value: function isFirstChild() {\n                var _this$parent;\n                return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n            }\n        }\n    ]);\n    return Element;\n}();\nElement.ignoreChildTypes = [\n    \"title\"\n];\nfunction _createSuper$J(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$J();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$J() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar UnknownElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](UnknownElement, _Element);\n    var _super = _createSuper$J(UnknownElement);\n    function UnknownElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, UnknownElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        return _this;\n    }\n    return UnknownElement;\n}(Element);\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nvar Font = /*#__PURE__*/ function() {\n    function Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {\n        _classCallCheck__default[\"default\"](this, Font);\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    _createClass__default[\"default\"](Font, [\n        {\n            key: \"toString\",\n            value: function toString() {\n                return [\n                    prepareFontStyle(this.fontStyle),\n                    this.fontVariant,\n                    prepareFontWeight(this.fontWeight),\n                    this.fontSize,\n                    prepareFontFamily(this.fontFamily)\n                ].join(\" \").trim();\n            }\n        }\n    ], [\n        {\n            key: \"parse\",\n            value: function parse() {\n                var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n                var inherit = arguments.length > 1 ? arguments[1] : undefined;\n                var fontStyle = \"\";\n                var fontVariant = \"\";\n                var fontWeight = \"\";\n                var fontSize = \"\";\n                var fontFamily = \"\";\n                var parts = compressSpaces(font).trim().split(\" \");\n                var set = {\n                    fontSize: false,\n                    fontStyle: false,\n                    fontWeight: false,\n                    fontVariant: false\n                };\n                parts.forEach(function(part) {\n                    switch(true){\n                        case !set.fontStyle && Font.styles.includes(part):\n                            if (part !== \"inherit\") {\n                                fontStyle = part;\n                            }\n                            set.fontStyle = true;\n                            break;\n                        case !set.fontVariant && Font.variants.includes(part):\n                            if (part !== \"inherit\") {\n                                fontVariant = part;\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            break;\n                        case !set.fontWeight && Font.weights.includes(part):\n                            if (part !== \"inherit\") {\n                                fontWeight = part;\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            set.fontWeight = true;\n                            break;\n                        case !set.fontSize:\n                            if (part !== \"inherit\") {\n                                var _part$split = part.split(\"/\");\n                                var _part$split2 = _slicedToArray__default[\"default\"](_part$split, 1);\n                                fontSize = _part$split2[0];\n                            }\n                            set.fontStyle = true;\n                            set.fontVariant = true;\n                            set.fontWeight = true;\n                            set.fontSize = true;\n                            break;\n                        default:\n                            if (part !== \"inherit\") {\n                                fontFamily += part;\n                            }\n                    }\n                });\n                return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n            }\n        }\n    ]);\n    return Font;\n}();\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nvar BoundingBox = /*#__PURE__*/ function() {\n    function BoundingBox() {\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        _classCallCheck__default[\"default\"](this, BoundingBox);\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    _createClass__default[\"default\"](BoundingBox, [\n        {\n            key: \"addPoint\",\n            value: function addPoint(x, y) {\n                if (typeof x !== \"undefined\") {\n                    if (isNaN(this.x1) || isNaN(this.x2)) {\n                        this.x1 = x;\n                        this.x2 = x;\n                    }\n                    if (x < this.x1) {\n                        this.x1 = x;\n                    }\n                    if (x > this.x2) {\n                        this.x2 = x;\n                    }\n                }\n                if (typeof y !== \"undefined\") {\n                    if (isNaN(this.y1) || isNaN(this.y2)) {\n                        this.y1 = y;\n                        this.y2 = y;\n                    }\n                    if (y < this.y1) {\n                        this.y1 = y;\n                    }\n                    if (y > this.y2) {\n                        this.y2 = y;\n                    }\n                }\n            }\n        },\n        {\n            key: \"addX\",\n            value: function addX(x) {\n                this.addPoint(x, null);\n            }\n        },\n        {\n            key: \"addY\",\n            value: function addY(y) {\n                this.addPoint(null, y);\n            }\n        },\n        {\n            key: \"addBoundingBox\",\n            value: function addBoundingBox(boundingBox) {\n                if (!boundingBox) {\n                    return;\n                }\n                var x1 = boundingBox.x1, y1 = boundingBox.y1, x2 = boundingBox.x2, y2 = boundingBox.y2;\n                this.addPoint(x1, y1);\n                this.addPoint(x2, y2);\n            }\n        },\n        {\n            key: \"sumCubic\",\n            value: function sumCubic(t, p0, p1, p2, p3) {\n                return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n            }\n        },\n        {\n            key: \"bezierCurveAdd\",\n            value: function bezierCurveAdd(forX, p0, p1, p2, p3) {\n                var b = 6 * p0 - 12 * p1 + 6 * p2;\n                var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n                var c = 3 * p1 - 3 * p0;\n                if (a === 0) {\n                    if (b === 0) {\n                        return;\n                    }\n                    var t = -c / b;\n                    if (0 < t && t < 1) {\n                        if (forX) {\n                            this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                        } else {\n                            this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                        }\n                    }\n                    return;\n                }\n                var b2ac = Math.pow(b, 2) - 4 * c * a;\n                if (b2ac < 0) {\n                    return;\n                }\n                var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n                if (0 < t1 && t1 < 1) {\n                    if (forX) {\n                        this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n                    } else {\n                        this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n                    }\n                }\n                var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n                if (0 < t2 && t2 < 1) {\n                    if (forX) {\n                        this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n                    } else {\n                        this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n                    }\n                }\n            } // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n        },\n        {\n            key: \"addBezierCurve\",\n            value: function addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n                this.addPoint(p0x, p0y);\n                this.addPoint(p3x, p3y);\n                this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n                this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n            }\n        },\n        {\n            key: \"addQuadraticCurve\",\n            value: function addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n                var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n                var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n                var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n                var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n            }\n        },\n        {\n            key: \"isPointInBox\",\n            value: function isPointInBox(x, y) {\n                var x1 = this.x1, y1 = this.y1, x2 = this.x2, y2 = this.y2;\n                return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n            }\n        },\n        {\n            key: \"x\",\n            get: function get() {\n                return this.x1;\n            }\n        },\n        {\n            key: \"y\",\n            get: function get() {\n                return this.y1;\n            }\n        },\n        {\n            key: \"width\",\n            get: function get() {\n                return this.x2 - this.x1;\n            }\n        },\n        {\n            key: \"height\",\n            get: function get() {\n                return this.y2 - this.y1;\n            }\n        }\n    ]);\n    return BoundingBox;\n}();\nfunction _createSuper$I(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$I();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$I() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PathParser = /*#__PURE__*/ function(_SVGPathData) {\n    _inherits__default[\"default\"](PathParser, _SVGPathData);\n    var _super = _createSuper$I(PathParser);\n    function PathParser(path) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PathParser);\n        _this = _super.call(this, path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        _this.control = null;\n        _this.start = null;\n        _this.current = null;\n        _this.command = null;\n        _this.commands = _this.commands;\n        _this.i = -1;\n        _this.previousCommand = null;\n        _this.points = [];\n        _this.angles = [];\n        return _this;\n    }\n    _createClass__default[\"default\"](PathParser, [\n        {\n            key: \"reset\",\n            value: function reset() {\n                this.i = -1;\n                this.command = null;\n                this.previousCommand = null;\n                this.start = new Point(0, 0);\n                this.control = new Point(0, 0);\n                this.current = new Point(0, 0);\n                this.points = [];\n                this.angles = [];\n            }\n        },\n        {\n            key: \"isEnd\",\n            value: function isEnd() {\n                var i = this.i, commands = this.commands;\n                return i >= commands.length - 1;\n            }\n        },\n        {\n            key: \"next\",\n            value: function next() {\n                var command = this.commands[++this.i];\n                this.previousCommand = this.command;\n                this.command = command;\n                return command;\n            }\n        },\n        {\n            key: \"getPoint\",\n            value: function getPoint() {\n                var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n                var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n                var point = new Point(this.command[xProp], this.command[yProp]);\n                return this.makeAbsolute(point);\n            }\n        },\n        {\n            key: \"getAsControlPoint\",\n            value: function getAsControlPoint(xProp, yProp) {\n                var point = this.getPoint(xProp, yProp);\n                this.control = point;\n                return point;\n            }\n        },\n        {\n            key: \"getAsCurrentPoint\",\n            value: function getAsCurrentPoint(xProp, yProp) {\n                var point = this.getPoint(xProp, yProp);\n                this.current = point;\n                return point;\n            }\n        },\n        {\n            key: \"getReflectedControlPoint\",\n            value: function getReflectedControlPoint() {\n                var previousCommand = this.previousCommand.type;\n                if (previousCommand !== svgPathdata.SVGPathData.CURVE_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svgPathdata.SVGPathData.QUAD_TO && previousCommand !== svgPathdata.SVGPathData.SMOOTH_QUAD_TO) {\n                    return this.current;\n                } // reflect point\n                var _this$current = this.current, cx = _this$current.x, cy = _this$current.y, _this$control = this.control, ox = _this$control.x, oy = _this$control.y;\n                var point = new Point(2 * cx - ox, 2 * cy - oy);\n                return point;\n            }\n        },\n        {\n            key: \"makeAbsolute\",\n            value: function makeAbsolute(point) {\n                if (this.command.relative) {\n                    var _this$current2 = this.current, x = _this$current2.x, y = _this$current2.y;\n                    point.x += x;\n                    point.y += y;\n                }\n                return point;\n            }\n        },\n        {\n            key: \"addMarker\",\n            value: function addMarker(point, from, priorTo) {\n                var points = this.points, angles = this.angles; // if the last angle isn't filled in because we didn't have this point yet ...\n                if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n                    angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n                }\n                this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n            }\n        },\n        {\n            key: \"addMarkerAngle\",\n            value: function addMarkerAngle(point, angle) {\n                this.points.push(point);\n                this.angles.push(angle);\n            }\n        },\n        {\n            key: \"getMarkerPoints\",\n            value: function getMarkerPoints() {\n                return this.points;\n            }\n        },\n        {\n            key: \"getMarkerAngles\",\n            value: function getMarkerAngles() {\n                var angles = this.angles;\n                var len = angles.length;\n                for(var i = 0; i < len; i++){\n                    if (!angles[i]) {\n                        for(var j = i + 1; j < len; j++){\n                            if (angles[j]) {\n                                angles[i] = angles[j];\n                                break;\n                            }\n                        }\n                    }\n                }\n                return angles;\n            }\n        }\n    ]);\n    return PathParser;\n}(svgPathdata.SVGPathData);\nfunction _createSuper$H(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$H();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$H() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RenderedElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](RenderedElement, _Element);\n    var _super = _createSuper$H(RenderedElement);\n    function RenderedElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RenderedElement);\n        _this = _super.apply(this, arguments);\n        _this.modifiedEmSizeStack = false;\n        return _this;\n    }\n    _createClass__default[\"default\"](RenderedElement, [\n        {\n            key: \"calculateOpacity\",\n            value: function calculateOpacity() {\n                var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n                var element = this;\n                while(element){\n                    var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n                    if (opacityStyle.hasValue(true)) {\n                        opacity *= opacityStyle.getNumber();\n                    }\n                    element = element.parent;\n                }\n                return opacity;\n            }\n        },\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                if (!fromMeasure) {\n                    // causes stack overflow when measuring text with gradients\n                    // fill\n                    var fillStyleProp = this.getStyle(\"fill\");\n                    var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n                    var strokeStyleProp = this.getStyle(\"stroke\");\n                    var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n                    if (fillStyleProp.isUrlDefinition()) {\n                        var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                        if (fillStyle) {\n                            ctx.fillStyle = fillStyle;\n                        }\n                    } else if (fillStyleProp.hasValue()) {\n                        if (fillStyleProp.getString() === \"currentColor\") {\n                            fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                        }\n                        var _fillStyle = fillStyleProp.getColor();\n                        if (_fillStyle !== \"inherit\") {\n                            ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                        }\n                    }\n                    if (fillOpacityStyleProp.hasValue()) {\n                        var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                        ctx.fillStyle = _fillStyle2;\n                    } // stroke\n                    if (strokeStyleProp.isUrlDefinition()) {\n                        var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                        if (strokeStyle) {\n                            ctx.strokeStyle = strokeStyle;\n                        }\n                    } else if (strokeStyleProp.hasValue()) {\n                        if (strokeStyleProp.getString() === \"currentColor\") {\n                            strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                        }\n                        var _strokeStyle = strokeStyleProp.getString();\n                        if (_strokeStyle !== \"inherit\") {\n                            ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                        }\n                    }\n                    if (strokeOpacityProp.hasValue()) {\n                        var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                        ctx.strokeStyle = _strokeStyle2;\n                    }\n                    var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n                    if (strokeWidthStyleProp.hasValue()) {\n                        var newLineWidth = strokeWidthStyleProp.getPixels();\n                        ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                         : newLineWidth;\n                    }\n                    var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n                    var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n                    var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n                    // const pointOrderStyleProp = this.getStyle('paint-order');\n                    var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n                    var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n                    if (strokeLinecapStyleProp.hasValue()) {\n                        ctx.lineCap = strokeLinecapStyleProp.getString();\n                    }\n                    if (strokeLinejoinStyleProp.hasValue()) {\n                        ctx.lineJoin = strokeLinejoinStyleProp.getString();\n                    }\n                    if (strokeMiterlimitProp.hasValue()) {\n                        ctx.miterLimit = strokeMiterlimitProp.getNumber();\n                    } // NEED TEST\n                    // if (pointOrderStyleProp.hasValue()) {\n                    // \t// ?\n                    // \tctx.paintOrder = pointOrderStyleProp.getValue();\n                    // }\n                    if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                        var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                        if (typeof ctx.setLineDash !== \"undefined\") {\n                            ctx.setLineDash(gaps);\n                        } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.webkitLineDash = gaps;\n                        } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.mozDash = gaps;\n                        }\n                        var offset = strokeDashoffsetProp.getPixels();\n                        if (typeof ctx.lineDashOffset !== \"undefined\") {\n                            ctx.lineDashOffset = offset;\n                        } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.webkitLineDashOffset = offset;\n                        } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                            // @ts-expect-error Handle browser prefix.\n                            ctx.mozDashOffset = offset;\n                        }\n                    }\n                } // font\n                this.modifiedEmSizeStack = false;\n                if (typeof ctx.font !== \"undefined\") {\n                    var fontStyleProp = this.getStyle(\"font\");\n                    var fontStyleStyleProp = this.getStyle(\"font-style\");\n                    var fontVariantStyleProp = this.getStyle(\"font-variant\");\n                    var fontWeightStyleProp = this.getStyle(\"font-weight\");\n                    var fontSizeStyleProp = this.getStyle(\"font-size\");\n                    var fontFamilyStyleProp = this.getStyle(\"font-family\");\n                    var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n                    fontStyleStyleProp.setValue(font.fontStyle);\n                    fontVariantStyleProp.setValue(font.fontVariant);\n                    fontWeightStyleProp.setValue(font.fontWeight);\n                    fontSizeStyleProp.setValue(font.fontSize);\n                    fontFamilyStyleProp.setValue(font.fontFamily);\n                    ctx.font = font.toString();\n                    if (fontSizeStyleProp.isPixels()) {\n                        this.document.emSize = fontSizeStyleProp.getPixels();\n                        this.modifiedEmSizeStack = true;\n                    }\n                }\n                if (!fromMeasure) {\n                    // effects\n                    this.applyEffects(ctx); // opacity\n                    ctx.globalAlpha = this.calculateOpacity();\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](RenderedElement.prototype), \"clearContext\", this).call(this, ctx);\n                if (this.modifiedEmSizeStack) {\n                    this.document.popEmSize();\n                }\n            }\n        }\n    ]);\n    return RenderedElement;\n}(Element);\nfunction _createSuper$G(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$G();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$G() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PathElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](PathElement, _RenderedElement);\n    var _super = _createSuper$G(PathElement);\n    function PathElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PathElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"path\";\n        _this.pathParser = null;\n        _this.pathParser = new PathParser(_this.getAttribute(\"d\").getString());\n        return _this;\n    }\n    _createClass__default[\"default\"](PathElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var pathParser = this.pathParser;\n                var boundingBox = new BoundingBox();\n                pathParser.reset();\n                if (ctx) {\n                    ctx.beginPath();\n                }\n                while(!pathParser.isEnd()){\n                    switch(pathParser.next().type){\n                        case PathParser.MOVE_TO:\n                            this.pathM(ctx, boundingBox);\n                            break;\n                        case PathParser.LINE_TO:\n                            this.pathL(ctx, boundingBox);\n                            break;\n                        case PathParser.HORIZ_LINE_TO:\n                            this.pathH(ctx, boundingBox);\n                            break;\n                        case PathParser.VERT_LINE_TO:\n                            this.pathV(ctx, boundingBox);\n                            break;\n                        case PathParser.CURVE_TO:\n                            this.pathC(ctx, boundingBox);\n                            break;\n                        case PathParser.SMOOTH_CURVE_TO:\n                            this.pathS(ctx, boundingBox);\n                            break;\n                        case PathParser.QUAD_TO:\n                            this.pathQ(ctx, boundingBox);\n                            break;\n                        case PathParser.SMOOTH_QUAD_TO:\n                            this.pathT(ctx, boundingBox);\n                            break;\n                        case PathParser.ARC:\n                            this.pathA(ctx, boundingBox);\n                            break;\n                        case PathParser.CLOSE_PATH:\n                            this.pathZ(ctx, boundingBox);\n                            break;\n                    }\n                }\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(_) {\n                return this.path();\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var pathParser = this.pathParser;\n                var points = pathParser.getMarkerPoints();\n                var angles = pathParser.getMarkerAngles();\n                var markers = points.map(function(point, i) {\n                    return [\n                        point,\n                        angles[i]\n                    ];\n                });\n                return markers;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.path(ctx);\n                this.document.screen.mouse.checkPath(this, ctx);\n                var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n                if (ctx.fillStyle !== \"\") {\n                    if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                        ctx.fill(fillRuleStyleProp.getString());\n                    } else {\n                        ctx.fill();\n                    }\n                }\n                if (ctx.strokeStyle !== \"\") {\n                    if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                        ctx.save();\n                        ctx.setTransform(1, 0, 0, 1, 0, 0);\n                        ctx.stroke();\n                        ctx.restore();\n                    } else {\n                        ctx.stroke();\n                    }\n                }\n                var markers = this.getMarkers();\n                if (markers) {\n                    var markersLastIndex = markers.length - 1;\n                    var markerStartStyleProp = this.getStyle(\"marker-start\");\n                    var markerMidStyleProp = this.getStyle(\"marker-mid\");\n                    var markerEndStyleProp = this.getStyle(\"marker-end\");\n                    if (markerStartStyleProp.isUrlDefinition()) {\n                        var marker = markerStartStyleProp.getDefinition();\n                        var _markers$ = _slicedToArray__default[\"default\"](markers[0], 2), point = _markers$[0], angle = _markers$[1];\n                        marker.render(ctx, point, angle);\n                    }\n                    if (markerMidStyleProp.isUrlDefinition()) {\n                        var _marker = markerMidStyleProp.getDefinition();\n                        for(var i = 1; i < markersLastIndex; i++){\n                            var _markers$i = _slicedToArray__default[\"default\"](markers[i], 2), _point = _markers$i[0], _angle = _markers$i[1];\n                            _marker.render(ctx, _point, _angle);\n                        }\n                    }\n                    if (markerEndStyleProp.isUrlDefinition()) {\n                        var _marker2 = markerEndStyleProp.getDefinition();\n                        var _markers$markersLastI = _slicedToArray__default[\"default\"](markers[markersLastIndex], 2), _point2 = _markers$markersLastI[0], _angle2 = _markers$markersLastI[1];\n                        _marker2.render(ctx, _point2, _angle2);\n                    }\n                }\n            }\n        },\n        {\n            key: \"pathM\",\n            value: function pathM(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathM = PathElement.pathM(pathParser), point = _PathElement$pathM.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.moveTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathL = PathElement.pathL(pathParser), current = _PathElement$pathL.current, point = _PathElement$pathL.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathH = PathElement.pathH(pathParser), current = _PathElement$pathH.current, point = _PathElement$pathH.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathV = PathElement.pathV(pathParser), current = _PathElement$pathV.current, point = _PathElement$pathV.point;\n                var x = point.x, y = point.y;\n                pathParser.addMarker(point, current);\n                boundingBox.addPoint(x, y);\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                }\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathC = PathElement.pathC(pathParser), current = _PathElement$pathC.current, point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, point);\n                boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathS = PathElement.pathS(pathParser), current = _PathElement$pathS.current, point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, point);\n                boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathQ = PathElement.pathQ(pathParser), current = _PathElement$pathQ.current, controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n                boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathT = PathElement.pathT(pathParser), current = _PathElement$pathT.current, controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;\n                pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n                boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                if (ctx) {\n                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                }\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(ctx, boundingBox) {\n                var pathParser = this.pathParser;\n                var _PathElement$pathA = PathElement.pathA(pathParser), currentPoint = _PathElement$pathA.currentPoint, rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad; // for markers\n                var dir = 1 - sweepFlag ? 1.0 : -1.0;\n                var ah = a1 + dir * (ad / 2.0);\n                var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n                pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n                pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n                boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n                if (ctx && !isNaN(a1) && !isNaN(ad)) {\n                    var r = rX > rY ? rX : rY;\n                    var sx = rX > rY ? 1 : rX / rY;\n                    var sy = rX > rY ? rY / rX : 1;\n                    ctx.translate(centp.x, centp.y);\n                    ctx.rotate(xAxisRotation);\n                    ctx.scale(sx, sy);\n                    ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n                    ctx.scale(1 / sx, 1 / sy);\n                    ctx.rotate(-xAxisRotation);\n                    ctx.translate(-centp.x, -centp.y);\n                }\n            }\n        },\n        {\n            key: \"pathZ\",\n            value: function pathZ(ctx, boundingBox) {\n                PathElement.pathZ(this.pathParser);\n                if (ctx) {\n                    // only close path if it is not a straight line\n                    if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                        ctx.closePath();\n                    }\n                }\n            }\n        }\n    ], [\n        {\n            key: \"pathM\",\n            value: function pathM(pathParser) {\n                var point = pathParser.getAsCurrentPoint();\n                pathParser.start = pathParser.current;\n                return {\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n                pathParser.current = point;\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n                pathParser.current = point;\n                return {\n                    current: current,\n                    point: point\n                };\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getPoint(\"x1\", \"y1\");\n                var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(pathParser) {\n                var current = pathParser.current;\n                var point = pathParser.getReflectedControlPoint();\n                var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    point: point,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(pathParser) {\n                var current = pathParser.current;\n                var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(pathParser) {\n                var current = pathParser.current;\n                var controlPoint = pathParser.getReflectedControlPoint();\n                pathParser.control = controlPoint;\n                var currentPoint = pathParser.getAsCurrentPoint();\n                return {\n                    current: current,\n                    controlPoint: controlPoint,\n                    currentPoint: currentPoint\n                };\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(pathParser) {\n                var current = pathParser.current, command = pathParser.command;\n                var rX = command.rX, rY = command.rY, xRot = command.xRot, lArcFlag = command.lArcFlag, sweepFlag = command.sweepFlag;\n                var xAxisRotation = xRot * (Math.PI / 180.0);\n                var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n                // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n                // x1', y1'\n                var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n                var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n                if (l > 1) {\n                    rX *= Math.sqrt(l);\n                    rY *= Math.sqrt(l);\n                } // cx', cy'\n                var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n                if (isNaN(s)) {\n                    s = 0;\n                }\n                var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n                var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n                var a1 = vectorsAngle([\n                    1,\n                    0\n                ], [\n                    (currp.x - cpp.x) / rX,\n                    (currp.y - cpp.y) / rY\n                ]); // 1\n                // angle delta\n                var u = [\n                    (currp.x - cpp.x) / rX,\n                    (currp.y - cpp.y) / rY\n                ];\n                var v = [\n                    (-currp.x - cpp.x) / rX,\n                    (-currp.y - cpp.y) / rY\n                ];\n                var ad = vectorsAngle(u, v); // \n                if (vectorsRatio(u, v) <= -1) {\n                    ad = Math.PI;\n                }\n                if (vectorsRatio(u, v) >= 1) {\n                    ad = 0;\n                }\n                return {\n                    currentPoint: currentPoint,\n                    rX: rX,\n                    rY: rY,\n                    sweepFlag: sweepFlag,\n                    xAxisRotation: xAxisRotation,\n                    centp: centp,\n                    a1: a1,\n                    ad: ad\n                };\n            }\n        },\n        {\n            key: \"pathZ\",\n            value: function pathZ(pathParser) {\n                pathParser.current = pathParser.start;\n            }\n        }\n    ]);\n    return PathElement;\n}(RenderedElement);\nfunction _createSuper$F(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$F();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$F() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GlyphElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](GlyphElement, _PathElement);\n    var _super = _createSuper$F(GlyphElement);\n    function GlyphElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GlyphElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"glyph\";\n        _this.horizAdvX = _this.getAttribute(\"horiz-adv-x\").getNumber();\n        _this.unicode = _this.getAttribute(\"unicode\").getString();\n        _this.arabicForm = _this.getAttribute(\"arabic-form\").getString();\n        return _this;\n    }\n    return GlyphElement;\n}(PathElement);\nfunction _createSuper$E(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$E();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$E() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](TextElement, _RenderedElement);\n    var _super = _createSuper$E(TextElement);\n    function TextElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextElement);\n        _this = _super.call(this, document1, node, (this instanceof TextElement ? this.constructor : void 0) === TextElement ? true : captureTextNodes);\n        _this.type = \"text\";\n        _this.x = 0;\n        _this.y = 0;\n        _this.measureCache = -1;\n        return _this;\n    }\n    _createClass__default[\"default\"](TextElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](TextElement.prototype), \"setContext\", this).call(this, ctx, fromMeasure);\n                var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n                if (textBaseline) {\n                    ctx.textBaseline = textBaseline;\n                }\n            }\n        },\n        {\n            key: \"initializeCoordinates\",\n            value: function initializeCoordinates() {\n                this.x = 0;\n                this.y = 0;\n                this.leafTexts = [];\n                this.textChunkStart = 0;\n                this.minX = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var _this2 = this;\n                if (this.type !== \"text\") {\n                    return this.getTElementBoundingBox(ctx);\n                } // first, calculate child positions\n                this.initializeCoordinates();\n                this.adjustChildCoordinatesRecursive(ctx);\n                var boundingBox = null; // then calculate bounding box\n                this.children.forEach(function(_, i) {\n                    var childBoundingBox = _this2.getChildBoundingBox(ctx, _this2, _this2, i);\n                    if (!boundingBox) {\n                        boundingBox = childBoundingBox;\n                    } else {\n                        boundingBox.addBoundingBox(childBoundingBox);\n                    }\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getFontSize\",\n            value: function getFontSize() {\n                var document1 = this.document, parent = this.parent;\n                var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n                var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n                return fontSize;\n            }\n        },\n        {\n            key: \"getTElementBoundingBox\",\n            value: function getTElementBoundingBox(ctx) {\n                var fontSize = this.getFontSize();\n                return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n            }\n        },\n        {\n            key: \"getGlyph\",\n            value: function getGlyph(font, text, i) {\n                var char = text[i];\n                var glyph = null;\n                if (font.isArabic) {\n                    var len = text.length;\n                    var prevChar = text[i - 1];\n                    var nextChar = text[i + 1];\n                    var arabicForm = \"isolated\";\n                    if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                        arabicForm = \"terminal\";\n                    }\n                    if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                        arabicForm = \"medial\";\n                    }\n                    if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                        arabicForm = \"initial\";\n                    }\n                    if (typeof font.glyphs[char] !== \"undefined\") {\n                        // NEED TEST\n                        var maybeGlyph = font.glyphs[char];\n                        glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n                    }\n                } else {\n                    glyph = font.glyphs[char];\n                }\n                if (!glyph) {\n                    glyph = font.missingGlyph;\n                }\n                return glyph;\n            }\n        },\n        {\n            key: \"getText\",\n            value: function getText() {\n                return \"\";\n            }\n        },\n        {\n            key: \"getTextFromNode\",\n            value: function getTextFromNode(node) {\n                var textNode = node || this.node;\n                var childNodes = Array.from(textNode.parentNode.childNodes);\n                var index = childNodes.indexOf(textNode);\n                var lastIndex = childNodes.length - 1;\n                var text = compressSpaces(// || textNode.text\n                textNode.textContent || \"\");\n                if (index === 0) {\n                    text = trimLeft(text);\n                }\n                if (index === lastIndex) {\n                    text = trimRight(text);\n                }\n                return text;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var _this3 = this;\n                if (this.type !== \"text\") {\n                    this.renderTElementChildren(ctx);\n                    return;\n                } // first, calculate child positions\n                this.initializeCoordinates();\n                this.adjustChildCoordinatesRecursive(ctx); // then render\n                this.children.forEach(function(_, i) {\n                    _this3.renderChild(ctx, _this3, _this3, i);\n                });\n                var mouse = this.document.screen.mouse; // Do not calc bounding box if mouse is not working.\n                if (mouse.isWorking()) {\n                    mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n                }\n            }\n        },\n        {\n            key: \"renderTElementChildren\",\n            value: function renderTElementChildren(ctx) {\n                var document1 = this.document, parent = this.parent;\n                var renderText = this.getText();\n                var customFont = parent.getStyle(\"font-family\").getDefinition();\n                if (customFont) {\n                    var unitsPerEm = customFont.fontFace.unitsPerEm;\n                    var ctxFont = Font.parse(document1.ctx.font);\n                    var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n                    var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n                    var scale = fontSize / unitsPerEm;\n                    var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n                    var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n                    var len = text.length;\n                    for(var i = 0; i < len; i++){\n                        var glyph = this.getGlyph(customFont, text, i);\n                        ctx.translate(this.x, this.y);\n                        ctx.scale(scale, -scale);\n                        var lw = ctx.lineWidth;\n                        ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                        if (fontStyle === \"italic\") {\n                            ctx.transform(1, 0, .4, 1, 0, 0);\n                        }\n                        glyph.render(ctx);\n                        if (fontStyle === \"italic\") {\n                            ctx.transform(1, 0, -.4, 1, 0, 0);\n                        }\n                        ctx.lineWidth = lw;\n                        ctx.scale(1 / scale, -1 / scale);\n                        ctx.translate(-this.x, -this.y);\n                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                        if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                            this.x += dx[i];\n                        }\n                    }\n                    return;\n                }\n                var x = this.x, y = this.y; // NEED TEST\n                // if (ctx.paintOrder === 'stroke') {\n                // \tif (ctx.strokeStyle) {\n                // \t\tctx.strokeText(renderText, x, y);\n                // \t}\n                // \tif (ctx.fillStyle) {\n                // \t\tctx.fillText(renderText, x, y);\n                // \t}\n                // } else {\n                if (ctx.fillStyle) {\n                    ctx.fillText(renderText, x, y);\n                }\n                if (ctx.strokeStyle) {\n                    ctx.strokeText(renderText, x, y);\n                } // }\n            }\n        },\n        {\n            key: \"applyAnchoring\",\n            value: function applyAnchoring() {\n                if (this.textChunkStart >= this.leafTexts.length) {\n                    return;\n                } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n                // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n                // Vertical text is not supported.\n                var firstElement = this.leafTexts[this.textChunkStart];\n                var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n                var isRTL = false; // we treat RTL like LTR\n                var shift = 0;\n                if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n                    shift = firstElement.x - this.minX;\n                } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n                    shift = firstElement.x - this.maxX;\n                } else {\n                    shift = firstElement.x - (this.minX + this.maxX) / 2;\n                }\n                for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n                    this.leafTexts[i].x += shift;\n                } // start new chunk\n                this.minX = Number.POSITIVE_INFINITY;\n                this.maxX = Number.NEGATIVE_INFINITY;\n                this.textChunkStart = this.leafTexts.length;\n            }\n        },\n        {\n            key: \"adjustChildCoordinatesRecursive\",\n            value: function adjustChildCoordinatesRecursive(ctx) {\n                var _this4 = this;\n                this.children.forEach(function(_, i) {\n                    _this4.adjustChildCoordinatesRecursiveCore(ctx, _this4, _this4, i);\n                });\n                this.applyAnchoring();\n            }\n        },\n        {\n            key: \"adjustChildCoordinatesRecursiveCore\",\n            value: function adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                if (child.children.length > 0) {\n                    child.children.forEach(function(_, i) {\n                        textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n                    });\n                } else {\n                    // only leafs are relevant\n                    this.adjustChildCoordinates(ctx, textParent, parent, i);\n                }\n            }\n        },\n        {\n            key: \"adjustChildCoordinates\",\n            value: function adjustChildCoordinates(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                if (typeof child.measureText !== \"function\") {\n                    return child;\n                }\n                ctx.save();\n                child.setContext(ctx, true);\n                var xAttr = child.getAttribute(\"x\");\n                var yAttr = child.getAttribute(\"y\");\n                var dxAttr = child.getAttribute(\"dx\");\n                var dyAttr = child.getAttribute(\"dy\");\n                var customFont = child.getStyle(\"font-family\").getDefinition();\n                var isRTL = Boolean(customFont) && customFont.isRTL;\n                if (i === 0) {\n                    // First children inherit attributes from parent(s). Positional attributes\n                    // are only inherited from a parent to it's first child.\n                    if (!xAttr.hasValue()) {\n                        xAttr.setValue(child.getInheritedAttribute(\"x\"));\n                    }\n                    if (!yAttr.hasValue()) {\n                        yAttr.setValue(child.getInheritedAttribute(\"y\"));\n                    }\n                    if (!dxAttr.hasValue()) {\n                        dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n                    }\n                    if (!dyAttr.hasValue()) {\n                        dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n                    }\n                }\n                var width = child.measureText(ctx);\n                if (isRTL) {\n                    textParent.x -= width;\n                }\n                if (xAttr.hasValue()) {\n                    // an \"x\" attribute marks the start of a new chunk\n                    textParent.applyAnchoring();\n                    child.x = xAttr.getPixels(\"x\");\n                    if (dxAttr.hasValue()) {\n                        child.x += dxAttr.getPixels(\"x\");\n                    }\n                } else {\n                    if (dxAttr.hasValue()) {\n                        textParent.x += dxAttr.getPixels(\"x\");\n                    }\n                    child.x = textParent.x;\n                }\n                textParent.x = child.x;\n                if (!isRTL) {\n                    textParent.x += width;\n                }\n                if (yAttr.hasValue()) {\n                    child.y = yAttr.getPixels(\"y\");\n                    if (dyAttr.hasValue()) {\n                        child.y += dyAttr.getPixels(\"y\");\n                    }\n                } else {\n                    if (dyAttr.hasValue()) {\n                        textParent.y += dyAttr.getPixels(\"y\");\n                    }\n                    child.y = textParent.y;\n                }\n                textParent.y = child.y; // update the current chunk and it's bounds\n                textParent.leafTexts.push(child);\n                textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n                textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n                child.clearContext(ctx);\n                ctx.restore();\n                return child;\n            }\n        },\n        {\n            key: \"getChildBoundingBox\",\n            value: function getChildBoundingBox(ctx, textParent, parent, i) {\n                var child = parent.children[i]; // not a text node?\n                if (typeof child.getBoundingBox !== \"function\") {\n                    return null;\n                }\n                var boundingBox = child.getBoundingBox(ctx);\n                if (!boundingBox) {\n                    return null;\n                }\n                child.children.forEach(function(_, i) {\n                    var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n                    boundingBox.addBoundingBox(childBoundingBox);\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"renderChild\",\n            value: function renderChild(ctx, textParent, parent, i) {\n                var child = parent.children[i];\n                child.render(ctx);\n                child.children.forEach(function(_, i) {\n                    textParent.renderChild(ctx, textParent, child, i);\n                });\n            }\n        },\n        {\n            key: \"measureText\",\n            value: function measureText(ctx) {\n                var measureCache = this.measureCache;\n                if (~measureCache) {\n                    return measureCache;\n                }\n                var renderText = this.getText();\n                var measure = this.measureTargetText(ctx, renderText);\n                this.measureCache = measure;\n                return measure;\n            }\n        },\n        {\n            key: \"measureTargetText\",\n            value: function measureTargetText(ctx, targetText) {\n                if (!targetText.length) {\n                    return 0;\n                }\n                var parent = this.parent;\n                var customFont = parent.getStyle(\"font-family\").getDefinition();\n                if (customFont) {\n                    var fontSize = this.getFontSize();\n                    var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n                    var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n                    var len = text.length;\n                    var _measure = 0;\n                    for(var i = 0; i < len; i++){\n                        var glyph = this.getGlyph(customFont, text, i);\n                        _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                        if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                            _measure += dx[i];\n                        }\n                    }\n                    return _measure;\n                }\n                if (!ctx.measureText) {\n                    return targetText.length * 10;\n                }\n                ctx.save();\n                this.setContext(ctx, true);\n                var _ctx$measureText = ctx.measureText(targetText), measure = _ctx$measureText.width;\n                this.clearContext(ctx);\n                ctx.restore();\n                return measure;\n            }\n        },\n        {\n            key: \"getInheritedAttribute\",\n            value: function getInheritedAttribute(name) {\n                // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n                var current = this;\n                while(current instanceof TextElement && current.isFirstChild()){\n                    var parentAttr = current.parent.getAttribute(name);\n                    if (parentAttr.hasValue(true)) {\n                        return parentAttr.getValue(\"0\");\n                    }\n                    current = current.parent;\n                }\n                return null;\n            }\n        }\n    ]);\n    return TextElement;\n}(RenderedElement);\nfunction _createSuper$D(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$D();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$D() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TSpanElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TSpanElement, _TextElement);\n    var _super = _createSuper$D(TSpanElement);\n    function TSpanElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TSpanElement);\n        _this = _super.call(this, document1, node, (this instanceof TSpanElement ? this.constructor : void 0) === TSpanElement ? true : captureTextNodes);\n        _this.type = \"tspan\"; // if this node has children, then they own the text\n        _this.text = _this.children.length > 0 ? \"\" : _this.getTextFromNode();\n        return _this;\n    }\n    _createClass__default[\"default\"](TSpanElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        }\n    ]);\n    return TSpanElement;\n}(TextElement);\nfunction _createSuper$C(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$C();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$C() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextNode = /*#__PURE__*/ function(_TSpanElement) {\n    _inherits__default[\"default\"](TextNode, _TSpanElement);\n    var _super = _createSuper$C(TextNode);\n    function TextNode() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextNode);\n        _this = _super.apply(this, arguments);\n        _this.type = \"textNode\";\n        return _this;\n    }\n    return TextNode;\n}(TSpanElement);\nfunction _createSuper$B(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$B();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$B() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SVGElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](SVGElement, _RenderedElement);\n    var _super = _createSuper$B(SVGElement);\n    function SVGElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SVGElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"svg\";\n        _this.root = false;\n        return _this;\n    }\n    _createClass__default[\"default\"](SVGElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                var _this$node$parentNode;\n                var document1 = this.document;\n                var screen = document1.screen, window1 = document1.window;\n                var canvas = ctx.canvas;\n                screen.setDefaults(ctx);\n                if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n                    ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n                    var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n                    if (fontSizeProp.hasValue()) {\n                        document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                        document1.emSize = document1.rootEmSize;\n                    }\n                } // create new view port\n                if (!this.getAttribute(\"x\").hasValue()) {\n                    this.getAttribute(\"x\", true).setValue(0);\n                }\n                if (!this.getAttribute(\"y\").hasValue()) {\n                    this.getAttribute(\"y\", true).setValue(0);\n                }\n                var _screen$viewPort = screen.viewPort, width = _screen$viewPort.width, height = _screen$viewPort.height;\n                if (!this.getStyle(\"width\").hasValue()) {\n                    this.getStyle(\"width\", true).setValue(\"100%\");\n                }\n                if (!this.getStyle(\"height\").hasValue()) {\n                    this.getStyle(\"height\", true).setValue(\"100%\");\n                }\n                if (!this.getStyle(\"color\").hasValue()) {\n                    this.getStyle(\"color\", true).setValue(\"black\");\n                }\n                var refXAttr = this.getAttribute(\"refX\");\n                var refYAttr = this.getAttribute(\"refY\");\n                var viewBoxAttr = this.getAttribute(\"viewBox\");\n                var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n                var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n                var minX = 0;\n                var minY = 0;\n                var clipX = 0;\n                var clipY = 0;\n                if (viewBox) {\n                    minX = viewBox[0];\n                    minY = viewBox[1];\n                }\n                if (!this.root) {\n                    width = this.getStyle(\"width\").getPixels(\"x\");\n                    height = this.getStyle(\"height\").getPixels(\"y\");\n                    if (this.type === \"marker\") {\n                        clipX = minX;\n                        clipY = minY;\n                        minX = 0;\n                        minY = 0;\n                    }\n                }\n                screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n                // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n                if (this.node // is not temporary SVGElement\n                 && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n                    this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n                }\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](SVGElement.prototype), \"setContext\", this).call(this, ctx);\n                ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n                if (viewBox) {\n                    width = viewBox[2];\n                    height = viewBox[3];\n                }\n                document1.setViewBox({\n                    ctx: ctx,\n                    aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                    width: screen.viewPort.width,\n                    desiredWidth: width,\n                    height: screen.viewPort.height,\n                    desiredHeight: height,\n                    minX: minX,\n                    minY: minY,\n                    refX: refXAttr.getValue(),\n                    refY: refYAttr.getValue(),\n                    clip: clip,\n                    clipX: clipX,\n                    clipY: clipY\n                });\n                if (viewBox) {\n                    screen.viewPort.removeCurrent();\n                    screen.viewPort.setCurrent(width, height);\n                }\n            }\n        },\n        {\n            key: \"clearContext\",\n            value: function clearContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](SVGElement.prototype), \"clearContext\", this).call(this, ctx);\n                this.document.screen.viewPort.removeCurrent();\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize(width) {\n                var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n                var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                var widthAttr = this.getAttribute(\"width\", true);\n                var heightAttr = this.getAttribute(\"height\", true);\n                var viewBoxAttr = this.getAttribute(\"viewBox\");\n                var styleAttr = this.getAttribute(\"style\");\n                var originWidth = widthAttr.getNumber(0);\n                var originHeight = heightAttr.getNumber(0);\n                if (preserveAspectRatio) {\n                    if (typeof preserveAspectRatio === \"string\") {\n                        this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n                    } else {\n                        var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                        if (preserveAspectRatioAttr.hasValue()) {\n                            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                        }\n                    }\n                }\n                widthAttr.setValue(width);\n                heightAttr.setValue(height);\n                if (!viewBoxAttr.hasValue()) {\n                    viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n                }\n                if (styleAttr.hasValue()) {\n                    var widthStyle = this.getStyle(\"width\");\n                    var heightStyle = this.getStyle(\"height\");\n                    if (widthStyle.hasValue()) {\n                        widthStyle.setValue(\"\".concat(width, \"px\"));\n                    }\n                    if (heightStyle.hasValue()) {\n                        heightStyle.setValue(\"\".concat(height, \"px\"));\n                    }\n                }\n            }\n        }\n    ]);\n    return SVGElement;\n}(RenderedElement);\nfunction _createSuper$A(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$A();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$A() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RectElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](RectElement, _PathElement);\n    var _super = _createSuper$A(RectElement);\n    function RectElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RectElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"rect\";\n        return _this;\n    }\n    _createClass__default[\"default\"](RectElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n                var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n                var rxAttr = this.getAttribute(\"rx\");\n                var ryAttr = this.getAttribute(\"ry\");\n                var rx = rxAttr.getPixels(\"x\");\n                var ry = ryAttr.getPixels(\"y\");\n                if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n                    ry = rx;\n                }\n                if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n                    rx = ry;\n                }\n                rx = Math.min(rx, width / 2.0);\n                ry = Math.min(ry, height / 2.0);\n                if (ctx) {\n                    var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n                    ctx.beginPath(); // always start the path so we don't fill prior paths\n                    if (height > 0 && width > 0) {\n                        ctx.moveTo(x + rx, y);\n                        ctx.lineTo(x + width - rx, y);\n                        ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                        ctx.lineTo(x + width, y + height - ry);\n                        ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                        ctx.lineTo(x + rx, y + height);\n                        ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                        ctx.lineTo(x, y + ry);\n                        ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                        ctx.closePath();\n                    }\n                }\n                return new BoundingBox(x, y, x + width, y + height);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return RectElement;\n}(PathElement);\nfunction _createSuper$z(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$z();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$z() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar CircleElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](CircleElement, _PathElement);\n    var _super = _createSuper$z(CircleElement);\n    function CircleElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, CircleElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"circle\";\n        return _this;\n    }\n    _createClass__default[\"default\"](CircleElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n                var r = this.getAttribute(\"r\").getPixels();\n                if (ctx && r > 0) {\n                    ctx.beginPath();\n                    ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n                    ctx.closePath();\n                }\n                return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return CircleElement;\n}(PathElement);\nfunction _createSuper$y(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$y();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$y() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar EllipseElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](EllipseElement, _PathElement);\n    var _super = _createSuper$y(EllipseElement);\n    function EllipseElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, EllipseElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"ellipse\";\n        return _this;\n    }\n    _createClass__default[\"default\"](EllipseElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n                var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n                var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n                var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n                if (ctx && rx > 0 && ry > 0) {\n                    ctx.beginPath();\n                    ctx.moveTo(cx + rx, cy);\n                    ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n                    ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n                    ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n                    ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n                    ctx.closePath();\n                }\n                return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                return null;\n            }\n        }\n    ]);\n    return EllipseElement;\n}(PathElement);\nfunction _createSuper$x(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$x();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$x() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar LineElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](LineElement, _PathElement);\n    var _super = _createSuper$x(LineElement);\n    function LineElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, LineElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"line\";\n        return _this;\n    }\n    _createClass__default[\"default\"](LineElement, [\n        {\n            key: \"getPoints\",\n            value: function getPoints() {\n                return [\n                    new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n                    new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n                ];\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var _this$getPoints = this.getPoints(), _this$getPoints2 = _slicedToArray__default[\"default\"](_this$getPoints, 2), _this$getPoints2$ = _this$getPoints2[0], x0 = _this$getPoints2$.x, y0 = _this$getPoints2$.y, _this$getPoints2$2 = _this$getPoints2[1], x1 = _this$getPoints2$2.x, y1 = _this$getPoints2$2.y;\n                if (ctx) {\n                    ctx.beginPath();\n                    ctx.moveTo(x0, y0);\n                    ctx.lineTo(x1, y1);\n                }\n                return new BoundingBox(x0, y0, x1, y1);\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var _this$getPoints3 = this.getPoints(), _this$getPoints4 = _slicedToArray__default[\"default\"](_this$getPoints3, 2), p0 = _this$getPoints4[0], p1 = _this$getPoints4[1];\n                var a = p0.angleTo(p1);\n                return [\n                    [\n                        p0,\n                        a\n                    ],\n                    [\n                        p1,\n                        a\n                    ]\n                ];\n            }\n        }\n    ]);\n    return LineElement;\n}(PathElement);\nfunction _createSuper$w(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$w();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$w() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PolylineElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](PolylineElement, _PathElement);\n    var _super = _createSuper$w(PolylineElement);\n    function PolylineElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PolylineElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"polyline\";\n        _this.points = [];\n        _this.points = Point.parsePath(_this.getAttribute(\"points\").getString());\n        return _this;\n    }\n    _createClass__default[\"default\"](PolylineElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var points = this.points;\n                var _points = _slicedToArray__default[\"default\"](points, 1), _points$ = _points[0], x0 = _points$.x, y0 = _points$.y;\n                var boundingBox = new BoundingBox(x0, y0);\n                if (ctx) {\n                    ctx.beginPath();\n                    ctx.moveTo(x0, y0);\n                }\n                points.forEach(function(_ref) {\n                    var x = _ref.x, y = _ref.y;\n                    boundingBox.addPoint(x, y);\n                    if (ctx) {\n                        ctx.lineTo(x, y);\n                    }\n                });\n                return boundingBox;\n            }\n        },\n        {\n            key: \"getMarkers\",\n            value: function getMarkers() {\n                var points = this.points;\n                var lastIndex = points.length - 1;\n                var markers = [];\n                points.forEach(function(point, i) {\n                    if (i === lastIndex) {\n                        return;\n                    }\n                    markers.push([\n                        point,\n                        point.angleTo(points[i + 1])\n                    ]);\n                });\n                if (markers.length > 0) {\n                    markers.push([\n                        points[points.length - 1],\n                        markers[markers.length - 1][1]\n                    ]);\n                }\n                return markers;\n            }\n        }\n    ]);\n    return PolylineElement;\n}(PathElement);\nfunction _createSuper$v(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$v();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$v() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PolygonElement = /*#__PURE__*/ function(_PolylineElement) {\n    _inherits__default[\"default\"](PolygonElement, _PolylineElement);\n    var _super = _createSuper$v(PolygonElement);\n    function PolygonElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PolygonElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"polygon\";\n        return _this;\n    }\n    _createClass__default[\"default\"](PolygonElement, [\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var boundingBox = _get__default[\"default\"](_getPrototypeOf__default[\"default\"](PolygonElement.prototype), \"path\", this).call(this, ctx);\n                var _this$points = _slicedToArray__default[\"default\"](this.points, 1), _this$points$ = _this$points[0], x = _this$points$.x, y = _this$points$.y;\n                if (ctx) {\n                    ctx.lineTo(x, y);\n                    ctx.closePath();\n                }\n                return boundingBox;\n            }\n        }\n    ]);\n    return PolygonElement;\n}(PolylineElement);\nfunction _createSuper$u(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$u();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$u() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar PatternElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](PatternElement, _Element);\n    var _super = _createSuper$u(PatternElement);\n    function PatternElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, PatternElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"pattern\";\n        return _this;\n    }\n    _createClass__default[\"default\"](PatternElement, [\n        {\n            key: \"createPattern\",\n            value: function createPattern(ctx, _, parentOpacityProp) {\n                var width = this.getStyle(\"width\").getPixels(\"x\", true);\n                var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n                var patternSvg = new SVGElement(this.document, null);\n                patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n                patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n                patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n                patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n                patternSvg.children = this.children;\n                var patternCanvas = this.document.createCanvas(width, height);\n                var patternCtx = patternCanvas.getContext(\"2d\");\n                var xAttr = this.getAttribute(\"x\");\n                var yAttr = this.getAttribute(\"y\");\n                if (xAttr.hasValue() && yAttr.hasValue()) {\n                    patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n                }\n                if (parentOpacityProp.hasValue()) {\n                    this.styles[\"fill-opacity\"] = parentOpacityProp;\n                } else {\n                    Reflect.deleteProperty(this.styles, \"fill-opacity\");\n                } // render 3x3 grid so when we transform there's no white space on edges\n                for(var x = -1; x <= 1; x++){\n                    for(var y = -1; y <= 1; y++){\n                        patternCtx.save();\n                        patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                        patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                        patternSvg.render(patternCtx);\n                        patternCtx.restore();\n                    }\n                }\n                var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n                return pattern;\n            }\n        }\n    ]);\n    return PatternElement;\n}(Element);\nfunction _createSuper$t(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$t();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$t() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MarkerElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](MarkerElement, _Element);\n    var _super = _createSuper$t(MarkerElement);\n    function MarkerElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MarkerElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"marker\";\n        return _this;\n    }\n    _createClass__default[\"default\"](MarkerElement, [\n        {\n            key: \"render\",\n            value: function render(ctx, point, angle) {\n                if (!point) {\n                    return;\n                }\n                var x = point.x, y = point.y;\n                var orient = this.getAttribute(\"orient\").getString(\"auto\");\n                var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n                ctx.translate(x, y);\n                if (orient === \"auto\") {\n                    ctx.rotate(angle);\n                }\n                if (markerUnits === \"strokeWidth\") {\n                    ctx.scale(ctx.lineWidth, ctx.lineWidth);\n                }\n                ctx.save(); // render me using a temporary svg element\n                var markerSvg = new SVGElement(this.document, null);\n                markerSvg.type = this.type;\n                markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n                markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n                markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n                markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n                markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n                markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n                markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n                markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n                markerSvg.children = this.children;\n                markerSvg.render(ctx);\n                ctx.restore();\n                if (markerUnits === \"strokeWidth\") {\n                    ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n                }\n                if (orient === \"auto\") {\n                    ctx.rotate(-angle);\n                }\n                ctx.translate(-x, -y);\n            }\n        }\n    ]);\n    return MarkerElement;\n}(Element);\nfunction _createSuper$s(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$s();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$s() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar DefsElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](DefsElement, _Element);\n    var _super = _createSuper$s(DefsElement);\n    function DefsElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, DefsElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"defs\";\n        return _this;\n    }\n    _createClass__default[\"default\"](DefsElement, [\n        {\n            key: \"render\",\n            value: function render() {}\n        }\n    ]);\n    return DefsElement;\n}(Element);\nfunction _createSuper$r(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$r();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$r() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](GElement, _RenderedElement);\n    var _super = _createSuper$r(GElement);\n    function GElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"g\";\n        return _this;\n    }\n    _createClass__default[\"default\"](GElement, [\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var boundingBox = new BoundingBox();\n                this.children.forEach(function(child) {\n                    boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n                });\n                return boundingBox;\n            }\n        }\n    ]);\n    return GElement;\n}(RenderedElement);\nfunction _createSuper$q(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$q();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$q() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar GradientElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](GradientElement, _Element);\n    var _super = _createSuper$q(GradientElement);\n    function GradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, GradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        _this.stops = [];\n        var _assertThisInitialize = _assertThisInitialized__default[\"default\"](_this), stops = _assertThisInitialize.stops, children = _assertThisInitialize.children;\n        children.forEach(function(child) {\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n        return _this;\n    }\n    _createClass__default[\"default\"](GradientElement, [\n        {\n            key: \"getGradientUnits\",\n            value: function getGradientUnits() {\n                return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n            }\n        },\n        {\n            key: \"createGradient\",\n            value: function createGradient(ctx, element, parentOpacityProp) {\n                var _this2 = this;\n                // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n                var stopsContainer = this;\n                if (this.getHrefAttribute().hasValue()) {\n                    stopsContainer = this.getHrefAttribute().getDefinition();\n                    this.inheritStopContainer(stopsContainer);\n                }\n                var _stopsContainer = stopsContainer, stops = _stopsContainer.stops;\n                var gradient = this.getGradient(ctx, element);\n                if (!gradient) {\n                    return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n                }\n                stops.forEach(function(stop) {\n                    gradient.addColorStop(stop.offset, _this2.addParentOpacity(parentOpacityProp, stop.color));\n                });\n                if (this.getAttribute(\"gradientTransform\").hasValue()) {\n                    // render as transformed pattern on temporary canvas\n                    var document1 = this.document;\n                    var _document$screen = document1.screen, MAX_VIRTUAL_PIXELS = _document$screen.MAX_VIRTUAL_PIXELS, viewPort = _document$screen.viewPort;\n                    var _viewPort$viewPorts = _slicedToArray__default[\"default\"](viewPort.viewPorts, 1), rootView = _viewPort$viewPorts[0];\n                    var rect = new RectElement(document1, null);\n                    rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n                    rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n                    rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n                    rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n                    var group = new GElement(document1, null);\n                    group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n                    group.children = [\n                        rect\n                    ];\n                    var patternSvg = new SVGElement(document1, null);\n                    patternSvg.attributes.x = new Property(document1, \"x\", 0);\n                    patternSvg.attributes.y = new Property(document1, \"y\", 0);\n                    patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n                    patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n                    patternSvg.children = [\n                        group\n                    ];\n                    var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n                    var patternCtx = patternCanvas.getContext(\"2d\");\n                    patternCtx.fillStyle = gradient;\n                    patternSvg.render(patternCtx);\n                    return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n                }\n                return gradient;\n            }\n        },\n        {\n            key: \"inheritStopContainer\",\n            value: function inheritStopContainer(stopsContainer) {\n                var _this3 = this;\n                this.attributesToInherit.forEach(function(attributeToInherit) {\n                    if (!_this3.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                        _this3.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n                    }\n                });\n            }\n        },\n        {\n            key: \"addParentOpacity\",\n            value: function addParentOpacity(parentOpacityProp, color) {\n                if (parentOpacityProp.hasValue()) {\n                    var colorProp = new Property(this.document, \"color\", color);\n                    return colorProp.addOpacity(parentOpacityProp).getColor();\n                }\n                return color;\n            }\n        }\n    ]);\n    return GradientElement;\n}(Element);\nfunction _createSuper$p(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$p();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$p() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar LinearGradientElement = /*#__PURE__*/ function(_GradientElement) {\n    _inherits__default[\"default\"](LinearGradientElement, _GradientElement);\n    var _super = _createSuper$p(LinearGradientElement);\n    function LinearGradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, LinearGradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"linearGradient\";\n        _this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n        return _this;\n    }\n    _createClass__default[\"default\"](LinearGradientElement, [\n        {\n            key: \"getGradient\",\n            value: function getGradient(ctx, element) {\n                var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n                var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n                if (isBoundingBoxUnits && !boundingBox) {\n                    return null;\n                }\n                if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n                    this.getAttribute(\"x1\", true).setValue(0);\n                    this.getAttribute(\"y1\", true).setValue(0);\n                    this.getAttribute(\"x2\", true).setValue(1);\n                    this.getAttribute(\"y2\", true).setValue(0);\n                }\n                var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n                var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n                var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n                var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n                if (x1 === x2 && y1 === y2) {\n                    return null;\n                }\n                return ctx.createLinearGradient(x1, y1, x2, y2);\n            }\n        }\n    ]);\n    return LinearGradientElement;\n}(GradientElement);\nfunction _createSuper$o(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$o();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$o() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar RadialGradientElement = /*#__PURE__*/ function(_GradientElement) {\n    _inherits__default[\"default\"](RadialGradientElement, _GradientElement);\n    var _super = _createSuper$o(RadialGradientElement);\n    function RadialGradientElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, RadialGradientElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"radialGradient\";\n        _this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n        return _this;\n    }\n    _createClass__default[\"default\"](RadialGradientElement, [\n        {\n            key: \"getGradient\",\n            value: function getGradient(ctx, element) {\n                var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n                var boundingBox = element.getBoundingBox(ctx);\n                if (isBoundingBoxUnits && !boundingBox) {\n                    return null;\n                }\n                if (!this.getAttribute(\"cx\").hasValue()) {\n                    this.getAttribute(\"cx\", true).setValue(\"50%\");\n                }\n                if (!this.getAttribute(\"cy\").hasValue()) {\n                    this.getAttribute(\"cy\", true).setValue(\"50%\");\n                }\n                if (!this.getAttribute(\"r\").hasValue()) {\n                    this.getAttribute(\"r\", true).setValue(\"50%\");\n                }\n                var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n                var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n                var fx = cx;\n                var fy = cy;\n                if (this.getAttribute(\"fx\").hasValue()) {\n                    fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n                }\n                if (this.getAttribute(\"fy\").hasValue()) {\n                    fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n                }\n                var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n                var fr = this.getAttribute(\"fr\").getPixels();\n                return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n            }\n        }\n    ]);\n    return RadialGradientElement;\n}(GradientElement);\nfunction _createSuper$n(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$n();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$n() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar StopElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](StopElement, _Element);\n    var _super = _createSuper$n(StopElement);\n    function StopElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, StopElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, _this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = _this.getStyle(\"stop-opacity\");\n        var stopColor = _this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        _this.offset = offset;\n        _this.color = stopColor.getColor();\n        return _this;\n    }\n    return StopElement;\n}(Element);\nfunction _createSuper$m(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$m();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$m() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](AnimateElement, _Element);\n    var _super = _createSuper$m(AnimateElement);\n    function AnimateElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"animate\";\n        _this.duration = 0;\n        _this.initialValue = null;\n        _this.initialUnits = \"\";\n        _this.removed = false;\n        _this.frozen = false;\n        document1.screen.animations.push(_assertThisInitialized__default[\"default\"](_this));\n        _this.begin = _this.getAttribute(\"begin\").getMilliseconds();\n        _this.maxDuration = _this.begin + _this.getAttribute(\"dur\").getMilliseconds();\n        _this.from = _this.getAttribute(\"from\");\n        _this.to = _this.getAttribute(\"to\");\n        _this.values = new Property(document1, \"values\", null);\n        var valuesAttr = _this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            _this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateElement, [\n        {\n            key: \"getProperty\",\n            value: function getProperty() {\n                var attributeType = this.getAttribute(\"attributeType\").getString();\n                var attributeName = this.getAttribute(\"attributeName\").getString();\n                if (attributeType === \"CSS\") {\n                    return this.parent.getStyle(attributeName, true);\n                }\n                return this.parent.getAttribute(attributeName, true);\n            }\n        },\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var initialUnits = this.initialUnits;\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to; // tween value linearly\n                var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n                if (initialUnits === \"%\") {\n                    newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n                }\n                return \"\".concat(newValue).concat(initialUnits);\n            }\n        },\n        {\n            key: \"update\",\n            value: function update(delta) {\n                var parent = this.parent;\n                var prop = this.getProperty(); // set initial value\n                if (!this.initialValue) {\n                    this.initialValue = prop.getString();\n                    this.initialUnits = prop.getUnits();\n                } // if we're past the end time\n                if (this.duration > this.maxDuration) {\n                    var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n                    if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                        this.duration = 0;\n                    } else if (fill === \"freeze\" && !this.frozen) {\n                        this.frozen = true;\n                        parent.animationFrozen = true;\n                        parent.animationFrozenValue = prop.getString();\n                    } else if (fill === \"remove\" && !this.removed) {\n                        this.removed = true;\n                        prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                        return true;\n                    }\n                    return false;\n                }\n                this.duration += delta; // if we're past the begin time\n                var updated = false;\n                if (this.begin < this.duration) {\n                    var newValue = this.calcValue(); // tween\n                    var typeAttr = this.getAttribute(\"type\");\n                    if (typeAttr.hasValue()) {\n                        // for transform, etc.\n                        var type = typeAttr.getString();\n                        newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n                    }\n                    prop.setValue(newValue);\n                    updated = true;\n                }\n                return updated;\n            }\n        },\n        {\n            key: \"getProgress\",\n            value: function getProgress() {\n                var document1 = this.document, values = this.values;\n                var result = {\n                    progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n                };\n                if (values.hasValue()) {\n                    var p = result.progress * (values.getValue().length - 1);\n                    var lb = Math.floor(p);\n                    var ub = Math.ceil(p);\n                    result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n                    result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n                    result.progress = (p - lb) / (ub - lb);\n                } else {\n                    result.from = this.from;\n                    result.to = this.to;\n                }\n                return result;\n            }\n        }\n    ]);\n    return AnimateElement;\n}(Element);\nfunction _createSuper$l(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$l();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$l() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateColorElement = /*#__PURE__*/ function(_AnimateElement) {\n    _inherits__default[\"default\"](AnimateColorElement, _AnimateElement);\n    var _super = _createSuper$l(AnimateColorElement);\n    function AnimateColorElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateColorElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"animateColor\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateColorElement, [\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to;\n                var colorFrom = new RGBColor__default[\"default\"](from.getColor());\n                var colorTo = new RGBColor__default[\"default\"](to.getColor());\n                if (colorFrom.ok && colorTo.ok) {\n                    // tween color linearly\n                    var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n                    var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n                    var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n                    return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n                }\n                return this.getAttribute(\"from\").getColor();\n            }\n        }\n    ]);\n    return AnimateColorElement;\n}(AnimateElement);\nfunction _createSuper$k(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$k();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$k() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AnimateTransformElement = /*#__PURE__*/ function(_AnimateElement) {\n    _inherits__default[\"default\"](AnimateTransformElement, _AnimateElement);\n    var _super = _createSuper$k(AnimateTransformElement);\n    function AnimateTransformElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AnimateTransformElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"animateTransform\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AnimateTransformElement, [\n        {\n            key: \"calcValue\",\n            value: function calcValue() {\n                var _this$getProgress = this.getProgress(), progress = _this$getProgress.progress, from = _this$getProgress.from, to = _this$getProgress.to; // tween value linearly\n                var transformFrom = toNumbers(from.getString());\n                var transformTo = toNumbers(to.getString());\n                var newValue = transformFrom.map(function(from, i) {\n                    var to = transformTo[i];\n                    return from + (to - from) * progress;\n                }).join(\" \");\n                return newValue;\n            }\n        }\n    ]);\n    return AnimateTransformElement;\n}(AnimateElement);\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it.return != null) it.return();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray$1(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);\n}\nfunction _arrayLikeToArray$1(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction _createSuper$j(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$j();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$j() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FontElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FontElement, _Element);\n    var _super = _createSuper$j(FontElement);\n    function FontElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FontElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"font\";\n        _this.glyphs = Object.create(null);\n        _this.horizAdvX = _this.getAttribute(\"horiz-adv-x\").getNumber();\n        var definitions = document1.definitions;\n        var _assertThisInitialize = _assertThisInitialized__default[\"default\"](_this), children = _assertThisInitialize.children;\n        var _iterator = _createForOfIteratorHelper$1(children), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var child = _step.value;\n                switch(child.type){\n                    case \"font-face\":\n                        {\n                            _this.fontFace = child;\n                            var fontFamilyStyle = child.getStyle(\"font-family\");\n                            if (fontFamilyStyle.hasValue()) {\n                                definitions[fontFamilyStyle.getString()] = _assertThisInitialized__default[\"default\"](_this);\n                            }\n                            break;\n                        }\n                    case \"missing-glyph\":\n                        _this.missingGlyph = child;\n                        break;\n                    case \"glyph\":\n                        {\n                            var glyph = child;\n                            if (glyph.arabicForm) {\n                                _this.isRTL = true;\n                                _this.isArabic = true;\n                                if (typeof _this.glyphs[glyph.unicode] === \"undefined\") {\n                                    _this.glyphs[glyph.unicode] = Object.create(null);\n                                }\n                                _this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                            } else {\n                                _this.glyphs[glyph.unicode] = glyph;\n                            }\n                            break;\n                        }\n                    default:\n                }\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return _this;\n    }\n    _createClass__default[\"default\"](FontElement, [\n        {\n            key: \"render\",\n            value: function render() {}\n        }\n    ]);\n    return FontElement;\n}(Element);\nfunction _createSuper$i(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$i();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$i() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FontFaceElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FontFaceElement, _Element);\n    var _super = _createSuper$i(FontFaceElement);\n    function FontFaceElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FontFaceElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"font-face\";\n        _this.ascent = _this.getAttribute(\"ascent\").getNumber();\n        _this.descent = _this.getAttribute(\"descent\").getNumber();\n        _this.unitsPerEm = _this.getAttribute(\"units-per-em\").getNumber();\n        return _this;\n    }\n    return FontFaceElement;\n}(Element);\nfunction _createSuper$h(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$h();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$h() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MissingGlyphElement = /*#__PURE__*/ function(_PathElement) {\n    _inherits__default[\"default\"](MissingGlyphElement, _PathElement);\n    var _super = _createSuper$h(MissingGlyphElement);\n    function MissingGlyphElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MissingGlyphElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"missing-glyph\";\n        _this.horizAdvX = 0;\n        return _this;\n    }\n    return MissingGlyphElement;\n}(PathElement);\nfunction _createSuper$g(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$g();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$g() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TRefElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TRefElement, _TextElement);\n    var _super = _createSuper$g(TRefElement);\n    function TRefElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TRefElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"tref\";\n        return _this;\n    }\n    _createClass__default[\"default\"](TRefElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                var element = this.getHrefAttribute().getDefinition();\n                if (element) {\n                    var firstChild = element.children[0];\n                    if (firstChild) {\n                        return firstChild.getText();\n                    }\n                }\n                return \"\";\n            }\n        }\n    ]);\n    return TRefElement;\n}(TextElement);\nfunction _createSuper$f(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$f();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$f() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar AElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](AElement, _TextElement);\n    var _super = _createSuper$f(AElement);\n    function AElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, AElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"a\";\n        var childNodes = node.childNodes;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every(function(node) {\n            return node.nodeType === 3;\n        });\n        _this.hasText = hasText;\n        _this.text = hasText ? _this.getTextFromNode(firstChild) : \"\";\n        return _this;\n    }\n    _createClass__default[\"default\"](AElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                if (this.hasText) {\n                    // render as text element\n                    _get__default[\"default\"](_getPrototypeOf__default[\"default\"](AElement.prototype), \"renderChildren\", this).call(this, ctx);\n                    var document1 = this.document, x = this.x, y = this.y;\n                    var mouse = document1.screen.mouse;\n                    var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n                    if (mouse.isWorking()) {\n                        mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n                    }\n                } else if (this.children.length > 0) {\n                    // render as temporary group\n                    var g = new GElement(this.document, null);\n                    g.children = this.children;\n                    g.parent = this;\n                    g.render(ctx);\n                }\n            }\n        },\n        {\n            key: \"onClick\",\n            value: function onClick() {\n                var window1 = this.document.window;\n                if (window1) {\n                    window1.open(this.getHrefAttribute().getString());\n                }\n            }\n        },\n        {\n            key: \"onMouseMove\",\n            value: function onMouseMove() {\n                var ctx = this.document.ctx;\n                ctx.canvas.style.cursor = \"pointer\";\n            }\n        }\n    ]);\n    return AElement;\n}(TextElement);\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            var F = function F() {};\n            return {\n                s: F,\n                n: function n() {\n                    if (i >= o.length) return {\n                        done: true\n                    };\n                    return {\n                        done: false,\n                        value: o[i++]\n                    };\n                },\n                e: function e(_e) {\n                    throw _e;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true, didErr = false, err;\n    return {\n        s: function s() {\n            it = it.call(o);\n        },\n        n: function n() {\n            var step = it.next();\n            normalCompletion = step.done;\n            return step;\n        },\n        e: function e(_e2) {\n            didErr = true;\n            err = _e2;\n        },\n        f: function f() {\n            try {\n                if (!normalCompletion && it.return != null) it.return();\n            } finally{\n                if (didErr) throw err;\n            }\n        }\n    };\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++){\n        arr2[i] = arr[i];\n    }\n    return arr2;\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction _createSuper$e(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$e();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$e() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TextPathElement = /*#__PURE__*/ function(_TextElement) {\n    _inherits__default[\"default\"](TextPathElement, _TextElement);\n    var _super = _createSuper$e(TextPathElement);\n    function TextPathElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TextPathElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"textPath\";\n        _this.textWidth = 0;\n        _this.textHeight = 0;\n        _this.pathLength = -1;\n        _this.glyphInfo = null;\n        _this.letterSpacingCache = [];\n        _this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = _this.getHrefAttribute().getDefinition();\n        _this.text = _this.getTextFromNode();\n        _this.dataArray = _this.parsePathData(pathElement);\n        return _this;\n    }\n    _createClass__default[\"default\"](TextPathElement, [\n        {\n            key: \"getText\",\n            value: function getText() {\n                return this.text;\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var dataArray = this.dataArray;\n                if (ctx) {\n                    ctx.beginPath();\n                }\n                dataArray.forEach(function(_ref) {\n                    var type = _ref.type, points = _ref.points;\n                    switch(type){\n                        case PathParser.LINE_TO:\n                            if (ctx) {\n                                ctx.lineTo(points[0], points[1]);\n                            }\n                            break;\n                        case PathParser.MOVE_TO:\n                            if (ctx) {\n                                ctx.moveTo(points[0], points[1]);\n                            }\n                            break;\n                        case PathParser.CURVE_TO:\n                            if (ctx) {\n                                ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                            }\n                            break;\n                        case PathParser.QUAD_TO:\n                            if (ctx) {\n                                ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                            }\n                            break;\n                        case PathParser.ARC:\n                            {\n                                var _points = _slicedToArray__default[\"default\"](points, 8), cx = _points[0], cy = _points[1], rx = _points[2], ry = _points[3], theta = _points[4], dTheta = _points[5], psi = _points[6], fs = _points[7];\n                                var r = rx > ry ? rx : ry;\n                                var scaleX = rx > ry ? 1 : rx / ry;\n                                var scaleY = rx > ry ? ry / rx : 1;\n                                if (ctx) {\n                                    ctx.translate(cx, cy);\n                                    ctx.rotate(psi);\n                                    ctx.scale(scaleX, scaleY);\n                                    ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                                    ctx.scale(1 / scaleX, 1 / scaleY);\n                                    ctx.rotate(-psi);\n                                    ctx.translate(-cx, -cy);\n                                }\n                                break;\n                            }\n                        case PathParser.CLOSE_PATH:\n                            if (ctx) {\n                                ctx.closePath();\n                            }\n                            break;\n                    }\n                });\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                this.setTextData(ctx);\n                ctx.save();\n                var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n                var fontSize = this.getFontSize();\n                var glyphInfo = this.glyphInfo;\n                var fill = ctx.fillStyle;\n                if (textDecoration === \"underline\") {\n                    ctx.beginPath();\n                }\n                glyphInfo.forEach(function(glyph, i) {\n                    var p0 = glyph.p0, p1 = glyph.p1, rotation = glyph.rotation, partialText = glyph.text;\n                    ctx.save();\n                    ctx.translate(p0.x, p0.y);\n                    ctx.rotate(rotation);\n                    if (ctx.fillStyle) {\n                        ctx.fillText(partialText, 0, 0);\n                    }\n                    if (ctx.strokeStyle) {\n                        ctx.strokeText(partialText, 0, 0);\n                    }\n                    ctx.restore();\n                    if (textDecoration === \"underline\") {\n                        if (i === 0) {\n                            ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                        }\n                        ctx.lineTo(p1.x, p1.y + fontSize / 5);\n                    } // // To assist with debugging visually, uncomment following\n                //\n                // ctx.beginPath();\n                // if (i % 2)\n                // \tctx.strokeStyle = 'red';\n                // else\n                // \tctx.strokeStyle = 'green';\n                // ctx.moveTo(p0.x, p0.y);\n                // ctx.lineTo(p1.x, p1.y);\n                // ctx.stroke();\n                // ctx.closePath();\n                });\n                if (textDecoration === \"underline\") {\n                    ctx.lineWidth = fontSize / 20;\n                    ctx.strokeStyle = fill;\n                    ctx.stroke();\n                    ctx.closePath();\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"getLetterSpacingAt\",\n            value: function getLetterSpacingAt() {\n                var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n                return this.letterSpacingCache[idx] || 0;\n            }\n        },\n        {\n            key: \"findSegmentToFitChar\",\n            value: function findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n                var offset = inputOffset;\n                var glyphWidth = this.measureText(ctx, c);\n                if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n                    glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n                }\n                if (charI > -1) {\n                    offset += this.getLetterSpacingAt(charI);\n                }\n                var splineStep = this.textHeight / 20;\n                var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n                var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n                var segment = {\n                    p0: p0,\n                    p1: p1\n                };\n                var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n                if (dy) {\n                    var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n                    var dyY = Math.cos(-rotation) * dy;\n                    segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                        x: p0.x + dyX,\n                        y: p0.y + dyY\n                    });\n                    segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                        x: p1.x + dyX,\n                        y: p1.y + dyY\n                    });\n                }\n                offset += glyphWidth;\n                return {\n                    offset: offset,\n                    segment: segment,\n                    rotation: rotation\n                };\n            }\n        },\n        {\n            key: \"measureText\",\n            value: function measureText(ctx, text) {\n                var measuresCache = this.measuresCache;\n                var targetText = text || this.getText();\n                if (measuresCache.has(targetText)) {\n                    return measuresCache.get(targetText);\n                }\n                var measure = this.measureTargetText(ctx, targetText);\n                measuresCache.set(targetText, measure);\n                return measure;\n            } // This method supposes what all custom fonts already loaded.\n        },\n        {\n            key: \"setTextData\",\n            value: function setTextData(ctx) {\n                var _this2 = this;\n                if (this.glyphInfo) {\n                    return;\n                }\n                var renderText = this.getText();\n                var chars = renderText.split(\"\");\n                var spacesNumber = renderText.split(\" \").length - 1;\n                var dx = this.parent.getAttribute(\"dx\").split().map(function(_) {\n                    return _.getPixels(\"x\");\n                });\n                var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n                var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n                var thisSpacing = this.getStyle(\"letter-spacing\");\n                var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n                var letterSpacing = 0;\n                if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n                    letterSpacing = parentSpacing.getPixels();\n                } else if (thisSpacing.hasValue()) {\n                    if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                        letterSpacing = thisSpacing.getPixels();\n                    }\n                } // fill letter-spacing cache\n                var letterSpacingCache = [];\n                var textLen = renderText.length;\n                this.letterSpacingCache = letterSpacingCache;\n                for(var i = 0; i < textLen; i++){\n                    letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n                }\n                var dxSum = letterSpacingCache.reduce(function(acc, cur, i) {\n                    return i === 0 ? 0 : acc + cur || 0;\n                }, 0);\n                var textWidth = this.measureText(ctx);\n                var textFullWidth = Math.max(textWidth + dxSum, 0);\n                this.textWidth = textWidth;\n                this.textHeight = this.getFontSize();\n                this.glyphInfo = [];\n                var fullPathWidth = this.getPathLength();\n                var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n                var offset = 0;\n                if (anchor === \"middle\" || anchor === \"center\") {\n                    offset = -textFullWidth / 2;\n                }\n                if (anchor === \"end\" || anchor === \"right\") {\n                    offset = -textFullWidth;\n                }\n                offset += startOffset;\n                chars.forEach(function(char, i) {\n                    // Find such segment what distance between p0 and p1 is approx. width of glyph\n                    var _this2$findSegmentToF = _this2.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i), nextOffset = _this2$findSegmentToF.offset, segment = _this2$findSegmentToF.segment, rotation = _this2$findSegmentToF.rotation;\n                    offset = nextOffset;\n                    if (!segment.p0 || !segment.p1) {\n                        return;\n                    } // const width = this.getLineLength(\n                    // \tsegment.p0.x,\n                    // \tsegment.p0.y,\n                    // \tsegment.p1.x,\n                    // \tsegment.p1.y\n                    // );\n                    // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n                    // Can foresee having a rough pair table built in that the developer can override as needed.\n                    // Or use \"dx\" attribute of the <text> node as a naive replacement\n                    // const kern = 0;\n                    // placeholder for future implementation\n                    // const midpoint = this.getPointOnLine(\n                    // \tkern + width / 2.0,\n                    // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n                    // );\n                    _this2.glyphInfo.push({\n                        // transposeX: midpoint.x,\n                        // transposeY: midpoint.y,\n                        text: chars[i],\n                        p0: segment.p0,\n                        p1: segment.p1,\n                        rotation: rotation\n                    });\n                });\n            }\n        },\n        {\n            key: \"parsePathData\",\n            value: function parsePathData(path) {\n                this.pathLength = -1; // reset path length\n                if (!path) {\n                    return [];\n                }\n                var pathCommands = [];\n                var pathParser = path.pathParser;\n                pathParser.reset(); // convert l, H, h, V, and v to L\n                while(!pathParser.isEnd()){\n                    var current = pathParser.current;\n                    var startX = current ? current.x : 0;\n                    var startY = current ? current.y : 0;\n                    var command = pathParser.next();\n                    var nextCommandType = command.type;\n                    var points = [];\n                    switch(command.type){\n                        case PathParser.MOVE_TO:\n                            this.pathM(pathParser, points);\n                            break;\n                        case PathParser.LINE_TO:\n                            nextCommandType = this.pathL(pathParser, points);\n                            break;\n                        case PathParser.HORIZ_LINE_TO:\n                            nextCommandType = this.pathH(pathParser, points);\n                            break;\n                        case PathParser.VERT_LINE_TO:\n                            nextCommandType = this.pathV(pathParser, points);\n                            break;\n                        case PathParser.CURVE_TO:\n                            this.pathC(pathParser, points);\n                            break;\n                        case PathParser.SMOOTH_CURVE_TO:\n                            nextCommandType = this.pathS(pathParser, points);\n                            break;\n                        case PathParser.QUAD_TO:\n                            this.pathQ(pathParser, points);\n                            break;\n                        case PathParser.SMOOTH_QUAD_TO:\n                            nextCommandType = this.pathT(pathParser, points);\n                            break;\n                        case PathParser.ARC:\n                            points = this.pathA(pathParser);\n                            break;\n                        case PathParser.CLOSE_PATH:\n                            PathElement.pathZ(pathParser);\n                            break;\n                    }\n                    if (command.type !== PathParser.CLOSE_PATH) {\n                        pathCommands.push({\n                            type: nextCommandType,\n                            points: points,\n                            start: {\n                                x: startX,\n                                y: startY\n                            },\n                            pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                        });\n                    } else {\n                        pathCommands.push({\n                            type: PathParser.CLOSE_PATH,\n                            points: [],\n                            pathLength: 0\n                        });\n                    }\n                }\n                return pathCommands;\n            }\n        },\n        {\n            key: \"pathM\",\n            value: function pathM(pathParser, points) {\n                var _PathElement$pathM$po = PathElement.pathM(pathParser).point, x = _PathElement$pathM$po.x, y = _PathElement$pathM$po.y;\n                points.push(x, y);\n            }\n        },\n        {\n            key: \"pathL\",\n            value: function pathL(pathParser, points) {\n                var _PathElement$pathL$po = PathElement.pathL(pathParser).point, x = _PathElement$pathL$po.x, y = _PathElement$pathL$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathH\",\n            value: function pathH(pathParser, points) {\n                var _PathElement$pathH$po = PathElement.pathH(pathParser).point, x = _PathElement$pathH$po.x, y = _PathElement$pathH$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathV\",\n            value: function pathV(pathParser, points) {\n                var _PathElement$pathV$po = PathElement.pathV(pathParser).point, x = _PathElement$pathV$po.x, y = _PathElement$pathV$po.y;\n                points.push(x, y);\n                return PathParser.LINE_TO;\n            }\n        },\n        {\n            key: \"pathC\",\n            value: function pathC(pathParser, points) {\n                var _PathElement$pathC = PathElement.pathC(pathParser), point = _PathElement$pathC.point, controlPoint = _PathElement$pathC.controlPoint, currentPoint = _PathElement$pathC.currentPoint;\n                points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n            }\n        },\n        {\n            key: \"pathS\",\n            value: function pathS(pathParser, points) {\n                var _PathElement$pathS = PathElement.pathS(pathParser), point = _PathElement$pathS.point, controlPoint = _PathElement$pathS.controlPoint, currentPoint = _PathElement$pathS.currentPoint;\n                points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                return PathParser.CURVE_TO;\n            }\n        },\n        {\n            key: \"pathQ\",\n            value: function pathQ(pathParser, points) {\n                var _PathElement$pathQ = PathElement.pathQ(pathParser), controlPoint = _PathElement$pathQ.controlPoint, currentPoint = _PathElement$pathQ.currentPoint;\n                points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n            }\n        },\n        {\n            key: \"pathT\",\n            value: function pathT(pathParser, points) {\n                var _PathElement$pathT = PathElement.pathT(pathParser), controlPoint = _PathElement$pathT.controlPoint, currentPoint = _PathElement$pathT.currentPoint;\n                points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n                return PathParser.QUAD_TO;\n            }\n        },\n        {\n            key: \"pathA\",\n            value: function pathA(pathParser) {\n                var _PathElement$pathA = PathElement.pathA(pathParser), rX = _PathElement$pathA.rX, rY = _PathElement$pathA.rY, sweepFlag = _PathElement$pathA.sweepFlag, xAxisRotation = _PathElement$pathA.xAxisRotation, centp = _PathElement$pathA.centp, a1 = _PathElement$pathA.a1, ad = _PathElement$pathA.ad;\n                if (sweepFlag === 0 && ad > 0) {\n                    ad -= 2 * Math.PI;\n                }\n                if (sweepFlag === 1 && ad < 0) {\n                    ad += 2 * Math.PI;\n                }\n                return [\n                    centp.x,\n                    centp.y,\n                    rX,\n                    rY,\n                    a1,\n                    ad,\n                    xAxisRotation,\n                    sweepFlag\n                ];\n            }\n        },\n        {\n            key: \"calcLength\",\n            value: function calcLength(x, y, commandType, points) {\n                var len = 0;\n                var p1 = null;\n                var p2 = null;\n                var t = 0;\n                switch(commandType){\n                    case PathParser.LINE_TO:\n                        return this.getLineLength(x, y, points[0], points[1]);\n                    case PathParser.CURVE_TO:\n                        // Approximates by breaking curve into 100 line segments\n                        len = 0.0;\n                        p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                        for(t = 0.01; t <= 1; t += 0.01){\n                            p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                        return len;\n                    case PathParser.QUAD_TO:\n                        // Approximates by breaking curve into 100 line segments\n                        len = 0.0;\n                        p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                        for(t = 0.01; t <= 1; t += 0.01){\n                            p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                        return len;\n                    case PathParser.ARC:\n                        {\n                            // Approximates by breaking curve into line segments\n                            len = 0.0;\n                            var start = points[4]; // 4 = theta\n                            var dTheta = points[5]; // 5 = dTheta\n                            var end = points[4] + dTheta;\n                            var inc = Math.PI / 180.0; // 1 degree resolution\n                            if (Math.abs(start - end) < inc) {\n                                inc = Math.abs(start - end);\n                            } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                            p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                            if (dTheta < 0) {\n                                // clockwise\n                                for(t = start - inc; t > end; t -= inc){\n                                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                                    p1 = p2;\n                                }\n                            } else {\n                                // counter-clockwise\n                                for(t = start + inc; t < end; t += inc){\n                                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                                    p1 = p2;\n                                }\n                            }\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            return len;\n                        }\n                }\n                return 0;\n            }\n        },\n        {\n            key: \"getPointOnLine\",\n            value: function getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n                var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n                var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n                var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n                var run = Math.sqrt(dist * dist / (1 + m * m));\n                if (p2x < p1x) {\n                    run *= -1;\n                }\n                var rise = m * run;\n                var pt = null;\n                if (p2x === p1x) {\n                    // vertical line\n                    pt = {\n                        x: fromX,\n                        y: fromY + rise\n                    };\n                } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n                    pt = {\n                        x: fromX + run,\n                        y: fromY + rise\n                    };\n                } else {\n                    var ix = 0;\n                    var iy = 0;\n                    var len = this.getLineLength(p1x, p1y, p2x, p2y);\n                    if (len < PSEUDO_ZERO) {\n                        return null;\n                    }\n                    var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n                    u /= len * len;\n                    ix = p1x + u * (p2x - p1x);\n                    iy = p1y + u * (p2y - p1y);\n                    var pRise = this.getLineLength(fromX, fromY, ix, iy);\n                    var pRun = Math.sqrt(dist * dist - pRise * pRise);\n                    run = Math.sqrt(pRun * pRun / (1 + m * m));\n                    if (p2x < p1x) {\n                        run *= -1;\n                    }\n                    rise = m * run;\n                    pt = {\n                        x: ix + run,\n                        y: iy + rise\n                    };\n                }\n                return pt;\n            }\n        },\n        {\n            key: \"getPointOnPath\",\n            value: function getPointOnPath(distance) {\n                var fullLen = this.getPathLength();\n                var cumulativePathLength = 0;\n                var p = null;\n                if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n                    return null;\n                }\n                var dataArray = this.dataArray;\n                var _iterator = _createForOfIteratorHelper(dataArray), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var command = _step.value;\n                        if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                            cumulativePathLength += command.pathLength;\n                            continue;\n                        }\n                        var delta = distance - cumulativePathLength;\n                        var currentT = 0;\n                        switch(command.type){\n                            case PathParser.LINE_TO:\n                                p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                                break;\n                            case PathParser.ARC:\n                                {\n                                    var start = command.points[4]; // 4 = theta\n                                    var dTheta = command.points[5]; // 5 = dTheta\n                                    var end = command.points[4] + dTheta;\n                                    currentT = start + delta / command.pathLength * dTheta;\n                                    if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                                        break;\n                                    }\n                                    p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                                    break;\n                                }\n                            case PathParser.CURVE_TO:\n                                currentT = delta / command.pathLength;\n                                if (currentT > 1) {\n                                    currentT = 1;\n                                }\n                                p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                                break;\n                            case PathParser.QUAD_TO:\n                                currentT = delta / command.pathLength;\n                                if (currentT > 1) {\n                                    currentT = 1;\n                                }\n                                p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                                break;\n                            default:\n                        }\n                        if (p) {\n                            return p;\n                        }\n                        break;\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                return null;\n            }\n        },\n        {\n            key: \"getLineLength\",\n            value: function getLineLength(x1, y1, x2, y2) {\n                return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n            }\n        },\n        {\n            key: \"getPathLength\",\n            value: function getPathLength() {\n                if (this.pathLength === -1) {\n                    this.pathLength = this.dataArray.reduce(function(length, command) {\n                        return command.pathLength > 0 ? length + command.pathLength : length;\n                    }, 0);\n                }\n                return this.pathLength;\n            }\n        },\n        {\n            key: \"getPointOnCubicBezier\",\n            value: function getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n                var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n                var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        },\n        {\n            key: \"getPointOnQuadraticBezier\",\n            value: function getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n                var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n                var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n                return {\n                    x: x,\n                    y: y\n                };\n            }\n        },\n        {\n            key: \"getPointOnEllipticalArc\",\n            value: function getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n                var cosPsi = Math.cos(psi);\n                var sinPsi = Math.sin(psi);\n                var pt = {\n                    x: rx * Math.cos(theta),\n                    y: ry * Math.sin(theta)\n                };\n                return {\n                    x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n                    y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n                };\n            } // TODO need some optimisations. possibly build cache only for curved segments?\n        },\n        {\n            key: \"buildEquidistantCache\",\n            value: function buildEquidistantCache(inputStep, inputPrecision) {\n                var fullLen = this.getPathLength();\n                var precision = inputPrecision || 0.25; // accuracy vs performance\n                var step = inputStep || fullLen / 100;\n                if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n                    // Prepare cache\n                    this.equidistantCache = {\n                        step: step,\n                        precision: precision,\n                        points: []\n                    }; // Calculate points\n                    var s = 0;\n                    for(var l = 0; l <= fullLen; l += precision){\n                        var p0 = this.getPointOnPath(l);\n                        var p1 = this.getPointOnPath(l + precision);\n                        if (!p0 || !p1) {\n                            continue;\n                        }\n                        s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                        if (s >= step) {\n                            this.equidistantCache.points.push({\n                                x: p0.x,\n                                y: p0.y,\n                                distance: l\n                            });\n                            s -= step;\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"getEquidistantPointOnPath\",\n            value: function getEquidistantPointOnPath(targetDistance, step, precision) {\n                this.buildEquidistantCache(step, precision);\n                if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n                    return null;\n                }\n                var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n                return this.equidistantCache.points[idx] || null;\n            }\n        }\n    ]);\n    return TextPathElement;\n}(TextElement);\nfunction _createSuper$d(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$d();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$d() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nvar ImageElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](ImageElement, _RenderedElement);\n    var _super = _createSuper$d(ImageElement);\n    function ImageElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, ImageElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"image\";\n        _this.loaded = false;\n        var href = _this.getHrefAttribute().getString();\n        if (!href) {\n            return _possibleConstructorReturn__default[\"default\"](_this);\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(_assertThisInitialized__default[\"default\"](_this));\n        if (!isSvg) {\n            void _this.loadImage(href);\n        } else {\n            void _this.loadSvg(href);\n        }\n        _this.isSvg = isSvg;\n        return _this;\n    }\n    _createClass__default[\"default\"](ImageElement, [\n        {\n            key: \"loadImage\",\n            value: function() {\n                var _loadImage = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(href) {\n                    var image;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.prev = 0;\n                                    _context.next = 3;\n                                    return this.document.createImage(href);\n                                case 3:\n                                    image = _context.sent;\n                                    this.image = image;\n                                    _context.next = 10;\n                                    break;\n                                case 7:\n                                    _context.prev = 7;\n                                    _context.t0 = _context[\"catch\"](0);\n                                    console.error('Error while loading image \"'.concat(href, '\":'), _context.t0);\n                                case 10:\n                                    this.loaded = true;\n                                case 11:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            7\n                        ]\n                    ]);\n                }));\n                function loadImage(_x) {\n                    return _loadImage.apply(this, arguments);\n                }\n                return loadImage;\n            }()\n        },\n        {\n            key: \"loadSvg\",\n            value: function() {\n                var _loadSvg = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(href) {\n                    var match, data, response, svg;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    match = dataUriRegex.exec(href);\n                                    if (!match) {\n                                        _context2.next = 6;\n                                        break;\n                                    }\n                                    data = match[5];\n                                    if (match[4] === \"base64\") {\n                                        this.image = atob(data);\n                                    } else {\n                                        this.image = decodeURIComponent(data);\n                                    }\n                                    _context2.next = 19;\n                                    break;\n                                case 6:\n                                    _context2.prev = 6;\n                                    _context2.next = 9;\n                                    return this.document.fetch(href);\n                                case 9:\n                                    response = _context2.sent;\n                                    _context2.next = 12;\n                                    return response.text();\n                                case 12:\n                                    svg = _context2.sent;\n                                    this.image = svg;\n                                    _context2.next = 19;\n                                    break;\n                                case 16:\n                                    _context2.prev = 16;\n                                    _context2.t0 = _context2[\"catch\"](6);\n                                    console.error('Error while loading image \"'.concat(href, '\":'), _context2.t0);\n                                case 19:\n                                    this.loaded = true;\n                                case 20:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2, this, [\n                        [\n                            6,\n                            16\n                        ]\n                    ]);\n                }));\n                function loadSvg(_x2) {\n                    return _loadSvg.apply(this, arguments);\n                }\n                return loadSvg;\n            }()\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var document1 = this.document, image = this.image, loaded = this.loaded;\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                if (!loaded || !image || !width || !height) {\n                    return;\n                }\n                ctx.save();\n                ctx.translate(x, y);\n                if (this.isSvg) {\n                    var subDocument = document1.canvg.forkString(ctx, this.image, {\n                        ignoreMouse: true,\n                        ignoreAnimation: true,\n                        ignoreDimensions: true,\n                        ignoreClear: true,\n                        offsetX: 0,\n                        offsetY: 0,\n                        scaleWidth: width,\n                        scaleHeight: height\n                    });\n                    subDocument.document.documentElement.parent = this;\n                    void subDocument.render();\n                } else {\n                    var _image = this.image;\n                    document1.setViewBox({\n                        ctx: ctx,\n                        aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                        width: width,\n                        desiredWidth: _image.width,\n                        height: height,\n                        desiredHeight: _image.height\n                    });\n                    if (this.loaded) {\n                        if (typeof _image.complete === \"undefined\" || _image.complete) {\n                            ctx.drawImage(_image, 0, 0);\n                        }\n                    }\n                }\n                ctx.restore();\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox() {\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                return new BoundingBox(x, y, x + width, y + height);\n            }\n        }\n    ]);\n    return ImageElement;\n}(RenderedElement);\nfunction _createSuper$c(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$c();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$c() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar SymbolElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](SymbolElement, _RenderedElement);\n    var _super = _createSuper$c(SymbolElement);\n    function SymbolElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, SymbolElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"symbol\";\n        return _this;\n    }\n    _createClass__default[\"default\"](SymbolElement, [\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return SymbolElement;\n}(RenderedElement);\nvar SVGFontLoader = /*#__PURE__*/ function() {\n    function SVGFontLoader(document1) {\n        _classCallCheck__default[\"default\"](this, SVGFontLoader);\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    _createClass__default[\"default\"](SVGFontLoader, [\n        {\n            key: \"load\",\n            value: function() {\n                var _load = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(fontFamily, url) {\n                    var document1, svgDocument, fonts;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.prev = 0;\n                                    document1 = this.document;\n                                    _context.next = 4;\n                                    return document1.canvg.parser.load(url);\n                                case 4:\n                                    svgDocument = _context.sent;\n                                    fonts = svgDocument.getElementsByTagName(\"font\");\n                                    Array.from(fonts).forEach(function(fontNode) {\n                                        var font = document1.createElement(fontNode);\n                                        document1.definitions[fontFamily] = font;\n                                    });\n                                    _context.next = 12;\n                                    break;\n                                case 9:\n                                    _context.prev = 9;\n                                    _context.t0 = _context[\"catch\"](0);\n                                    console.error('Error while loading font \"'.concat(url, '\":'), _context.t0);\n                                case 12:\n                                    this.loaded = true;\n                                case 13:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this, [\n                        [\n                            0,\n                            9\n                        ]\n                    ]);\n                }));\n                function load(_x, _x2) {\n                    return _load.apply(this, arguments);\n                }\n                return load;\n            }()\n        }\n    ]);\n    return SVGFontLoader;\n}();\nfunction _createSuper$b(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$b();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$b() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar StyleElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](StyleElement, _Element);\n    var _super = _createSuper$b(StyleElement);\n    function StyleElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, StyleElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map(function(_) {\n            return _.textContent;\n        }).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach(function(_) {\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach(function(_) {\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach(function(cssProp) {\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach(function(src) {\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n        return _this;\n    }\n    return StyleElement;\n}(Element);\nStyleElement.parseExternalUrl = parseExternalUrl;\nfunction _createSuper$a(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$a();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$a() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar UseElement = /*#__PURE__*/ function(_RenderedElement) {\n    _inherits__default[\"default\"](UseElement, _RenderedElement);\n    var _super = _createSuper$a(UseElement);\n    function UseElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, UseElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"use\";\n        return _this;\n    }\n    _createClass__default[\"default\"](UseElement, [\n        {\n            key: \"setContext\",\n            value: function setContext(ctx) {\n                _get__default[\"default\"](_getPrototypeOf__default[\"default\"](UseElement.prototype), \"setContext\", this).call(this, ctx);\n                var xAttr = this.getAttribute(\"x\");\n                var yAttr = this.getAttribute(\"y\");\n                if (xAttr.hasValue()) {\n                    ctx.translate(xAttr.getPixels(\"x\"), 0);\n                }\n                if (yAttr.hasValue()) {\n                    ctx.translate(0, yAttr.getPixels(\"y\"));\n                }\n            }\n        },\n        {\n            key: \"path\",\n            value: function path(ctx) {\n                var element = this.element;\n                if (element) {\n                    element.path(ctx);\n                }\n            }\n        },\n        {\n            key: \"renderChildren\",\n            value: function renderChildren(ctx) {\n                var document1 = this.document, element = this.element;\n                if (element) {\n                    var tempSvg = element;\n                    if (element.type === \"symbol\") {\n                        // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                        tempSvg = new SVGElement(document1, null);\n                        tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                        tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                        tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                        tempSvg.children = element.children; // element is still the parent of the children\n                        element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n                    }\n                    if (tempSvg.type === \"svg\") {\n                        var widthStyle = this.getStyle(\"width\", false, true);\n                        var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                        if (widthStyle.hasValue()) {\n                            tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                        }\n                        if (heightStyle.hasValue()) {\n                            tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                        }\n                    }\n                    var oldParent = tempSvg.parent;\n                    tempSvg.parent = this;\n                    tempSvg.render(ctx);\n                    tempSvg.parent = oldParent;\n                }\n            }\n        },\n        {\n            key: \"getBoundingBox\",\n            value: function getBoundingBox(ctx) {\n                var element = this.element;\n                if (element) {\n                    return element.getBoundingBox(ctx);\n                }\n                return null;\n            }\n        },\n        {\n            key: \"elementTransform\",\n            value: function elementTransform() {\n                var document1 = this.document, element = this.element;\n                return Transform.fromElement(document1, element);\n            }\n        },\n        {\n            key: \"element\",\n            get: function get() {\n                if (!this.cachedElement) {\n                    this.cachedElement = this.getHrefAttribute().getDefinition();\n                }\n                return this.cachedElement;\n            }\n        }\n    ]);\n    return UseElement;\n}(RenderedElement);\nfunction _createSuper$9(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$9();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$9() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nvar FeColorMatrixElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeColorMatrixElement, _Element);\n    var _super = _createSuper$9(FeColorMatrixElement);\n    function FeColorMatrixElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeColorMatrixElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feColorMatrix\";\n        var matrix = toNumbers(_this.getAttribute(\"values\").getString());\n        switch(_this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        _this.matrix = matrix;\n        _this.includeOpacity = _this.getAttribute(\"includeOpacity\").hasValue();\n        return _this;\n    }\n    _createClass__default[\"default\"](FeColorMatrixElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, _x, _y, width, height) {\n                // assuming x==0 && y==0 for now\n                var includeOpacity = this.includeOpacity, matrix = this.matrix;\n                var srcData = ctx.getImageData(0, 0, width, height);\n                for(var y = 0; y < height; y++){\n                    for(var x = 0; x < width; x++){\n                        var r = imGet(srcData.data, x, y, width, height, 0);\n                        var g = imGet(srcData.data, x, y, width, height, 1);\n                        var b = imGet(srcData.data, x, y, width, height, 2);\n                        var a = imGet(srcData.data, x, y, width, height, 3);\n                        var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                        var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                        var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                        var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                        if (includeOpacity) {\n                            nr = 0;\n                            ng = 0;\n                            nb = 0;\n                            na *= a / 255;\n                        }\n                        imSet(srcData.data, x, y, width, height, 0, nr);\n                        imSet(srcData.data, x, y, width, height, 1, ng);\n                        imSet(srcData.data, x, y, width, height, 2, nb);\n                        imSet(srcData.data, x, y, width, height, 3, na);\n                    }\n                }\n                ctx.clearRect(0, 0, width, height);\n                ctx.putImageData(srcData, 0, 0);\n            }\n        }\n    ]);\n    return FeColorMatrixElement;\n}(Element);\nfunction _createSuper$8(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$8();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$8() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar MaskElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](MaskElement, _Element);\n    var _super = _createSuper$8(MaskElement);\n    function MaskElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, MaskElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"mask\";\n        return _this;\n    }\n    _createClass__default[\"default\"](MaskElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, element) {\n                var document1 = this.document; // render as temp svg\n                var x = this.getAttribute(\"x\").getPixels(\"x\");\n                var y = this.getAttribute(\"y\").getPixels(\"y\");\n                var width = this.getStyle(\"width\").getPixels(\"x\");\n                var height = this.getStyle(\"height\").getPixels(\"y\");\n                if (!width && !height) {\n                    var boundingBox = new BoundingBox();\n                    this.children.forEach(function(child) {\n                        boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n                    });\n                    x = Math.floor(boundingBox.x1);\n                    y = Math.floor(boundingBox.y1);\n                    width = Math.floor(boundingBox.width);\n                    height = Math.floor(boundingBox.height);\n                }\n                var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n                var maskCanvas = document1.createCanvas(x + width, y + height);\n                var maskCtx = maskCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(maskCtx);\n                this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n                // TODO: refactor out apply from feColorMatrix\n                new FeColorMatrixElement(document1, {\n                    nodeType: 1,\n                    childNodes: [],\n                    attributes: [\n                        {\n                            nodeName: \"type\",\n                            value: \"luminanceToAlpha\"\n                        },\n                        {\n                            nodeName: \"includeOpacity\",\n                            value: \"true\"\n                        }\n                    ]\n                }).apply(maskCtx, 0, 0, x + width, y + height);\n                var tmpCanvas = document1.createCanvas(x + width, y + height);\n                var tmpCtx = tmpCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(tmpCtx);\n                element.render(tmpCtx);\n                tmpCtx.globalCompositeOperation = \"destination-in\";\n                tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n                tmpCtx.fillRect(0, 0, x + width, y + height);\n                ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n                ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n                this.restoreStyles(element, ignoredStyles);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return MaskElement;\n}(Element);\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nfunction _createSuper$7(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$7();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$7() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar noop = function noop() {};\nvar ClipPathElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](ClipPathElement, _Element);\n    var _super = _createSuper$7(ClipPathElement);\n    function ClipPathElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, ClipPathElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"clipPath\";\n        return _this;\n    }\n    _createClass__default[\"default\"](ClipPathElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx) {\n                var document1 = this.document;\n                var contextProto = Reflect.getPrototypeOf(ctx);\n                var beginPath = ctx.beginPath, closePath = ctx.closePath;\n                if (contextProto) {\n                    contextProto.beginPath = noop;\n                    contextProto.closePath = noop;\n                }\n                Reflect.apply(beginPath, ctx, []);\n                this.children.forEach(function(child) {\n                    if (typeof child.path === \"undefined\") {\n                        return;\n                    }\n                    var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n                    if (!transform) {\n                        transform = Transform.fromElement(document1, child);\n                    }\n                    if (transform) {\n                        transform.apply(ctx);\n                    }\n                    child.path(ctx);\n                    if (contextProto) {\n                        contextProto.closePath = closePath;\n                    }\n                    if (transform) {\n                        transform.unapply(ctx);\n                    }\n                });\n                Reflect.apply(closePath, ctx, []);\n                ctx.clip();\n                if (contextProto) {\n                    contextProto.beginPath = beginPath;\n                    contextProto.closePath = closePath;\n                }\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return ClipPathElement;\n}(Element);\nfunction _createSuper$6(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$6();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$6() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FilterElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FilterElement, _Element);\n    var _super = _createSuper$6(FilterElement);\n    function FilterElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FilterElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"filter\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FilterElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, element) {\n                // render as temp svg\n                var document1 = this.document, children = this.children;\n                var boundingBox = element.getBoundingBox(ctx);\n                if (!boundingBox) {\n                    return;\n                }\n                var px = 0;\n                var py = 0;\n                children.forEach(function(child) {\n                    var efd = child.extraFilterDistance || 0;\n                    px = Math.max(px, efd);\n                    py = Math.max(py, efd);\n                });\n                var width = Math.floor(boundingBox.width);\n                var height = Math.floor(boundingBox.height);\n                var tmpCanvasWidth = width + 2 * px;\n                var tmpCanvasHeight = height + 2 * py;\n                if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n                    return;\n                }\n                var x = Math.floor(boundingBox.x);\n                var y = Math.floor(boundingBox.y);\n                var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n                var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n                var tmpCtx = tmpCanvas.getContext(\"2d\");\n                document1.screen.setDefaults(tmpCtx);\n                tmpCtx.translate(-x + px, -y + py);\n                element.render(tmpCtx); // apply filters\n                children.forEach(function(child) {\n                    if (typeof child.apply === \"function\") {\n                        child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n                    }\n                }); // render on me\n                ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n                this.restoreStyles(element, ignoredStyles);\n            }\n        },\n        {\n            key: \"render\",\n            value: function render(_) {}\n        }\n    ]);\n    return FilterElement;\n}(Element);\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nfunction _createSuper$5(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$5();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$5() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeDropShadowElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeDropShadowElement, _Element);\n    var _super = _createSuper$5(FeDropShadowElement);\n    function FeDropShadowElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeDropShadowElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feDropShadow\";\n        _this.addStylesFromStyleDefinition();\n        return _this;\n    }\n    _createClass__default[\"default\"](FeDropShadowElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeDropShadowElement;\n}(Element);\nfunction _createSuper$4(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$4();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$4() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeMorphologyElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeMorphologyElement, _Element);\n    var _super = _createSuper$4(FeMorphologyElement);\n    function FeMorphologyElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeMorphologyElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"feMorphology\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FeMorphologyElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeMorphologyElement;\n}(Element);\nfunction _createSuper$3(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$3();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$3() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeCompositeElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeCompositeElement, _Element);\n    var _super = _createSuper$3(FeCompositeElement);\n    function FeCompositeElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeCompositeElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"feComposite\";\n        return _this;\n    }\n    _createClass__default[\"default\"](FeCompositeElement, [\n        {\n            key: \"apply\",\n            value: function apply(_, _x, _y, _width, _height) {}\n        }\n    ]);\n    return FeCompositeElement;\n}(Element);\nfunction _createSuper$2(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$2() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar FeGaussianBlurElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](FeGaussianBlurElement, _Element);\n    var _super = _createSuper$2(FeGaussianBlurElement);\n    function FeGaussianBlurElement(document1, node, captureTextNodes) {\n        var _this;\n        _classCallCheck__default[\"default\"](this, FeGaussianBlurElement);\n        _this = _super.call(this, document1, node, captureTextNodes);\n        _this.type = \"feGaussianBlur\";\n        _this.blurRadius = Math.floor(_this.getAttribute(\"stdDeviation\").getNumber());\n        _this.extraFilterDistance = _this.blurRadius;\n        return _this;\n    }\n    _createClass__default[\"default\"](FeGaussianBlurElement, [\n        {\n            key: \"apply\",\n            value: function apply(ctx, x, y, width, height) {\n                var document1 = this.document, blurRadius = this.blurRadius;\n                var body = document1.window ? document1.window.document.body : null;\n                var canvas = ctx.canvas; // StackBlur requires canvas be on document\n                canvas.id = document1.getUniqueId();\n                if (body) {\n                    canvas.style.display = \"none\";\n                    body.appendChild(canvas);\n                }\n                stackblurCanvas.canvasRGBA(canvas, x, y, width, height, blurRadius);\n                if (body) {\n                    body.removeChild(canvas);\n                }\n            }\n        }\n    ]);\n    return FeGaussianBlurElement;\n}(Element);\nfunction _createSuper$1(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct$1() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar TitleElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](TitleElement, _Element);\n    var _super = _createSuper$1(TitleElement);\n    function TitleElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, TitleElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"title\";\n        return _this;\n    }\n    return TitleElement;\n}(Element);\nfunction _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n        var Super = _getPrototypeOf__default[\"default\"](Derived), result;\n        if (hasNativeReflectConstruct) {\n            var NewTarget = _getPrototypeOf__default[\"default\"](this).constructor;\n            result = Reflect.construct(Super, arguments, NewTarget);\n        } else {\n            result = Super.apply(this, arguments);\n        }\n        return _possibleConstructorReturn__default[\"default\"](this, result);\n    };\n}\nfunction _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar DescElement = /*#__PURE__*/ function(_Element) {\n    _inherits__default[\"default\"](DescElement, _Element);\n    var _super = _createSuper(DescElement);\n    function DescElement() {\n        var _this;\n        _classCallCheck__default[\"default\"](this, DescElement);\n        _this = _super.apply(this, arguments);\n        _this.type = \"desc\";\n        return _this;\n    }\n    return DescElement;\n}(Element);\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee(src) {\n        var anonymousCrossOrigin, image, _args = arguments;\n        return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n            while(1){\n                switch(_context.prev = _context.next){\n                    case 0:\n                        anonymousCrossOrigin = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n                        image = document.createElement(\"img\");\n                        if (anonymousCrossOrigin) {\n                            image.crossOrigin = \"Anonymous\";\n                        }\n                        return _context.abrupt(\"return\", new Promise(function(resolve, reject) {\n                            image.onload = function() {\n                                resolve(image);\n                            };\n                            image.onerror = function(_event, _source, _lineno, _colno, error) {\n                                reject(error);\n                            };\n                            image.src = src;\n                        }));\n                    case 4:\n                    case \"end\":\n                        return _context.stop();\n                }\n            }\n        }, _callee);\n    }));\n    return _createImage.apply(this, arguments);\n}\nvar Document = /*#__PURE__*/ function() {\n    function Document(canvg) {\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$rootEmSize = _ref.rootEmSize, rootEmSize = _ref$rootEmSize === void 0 ? 12 : _ref$rootEmSize, _ref$emSize = _ref.emSize, emSize = _ref$emSize === void 0 ? 12 : _ref$emSize, _ref$createCanvas = _ref.createCanvas, createCanvas = _ref$createCanvas === void 0 ? Document.createCanvas : _ref$createCanvas, _ref$createImage = _ref.createImage, createImage = _ref$createImage === void 0 ? Document.createImage : _ref$createImage, anonymousCrossOrigin = _ref.anonymousCrossOrigin;\n        _classCallCheck__default[\"default\"](this, Document);\n        this.canvg = canvg;\n        this.definitions = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    _createClass__default[\"default\"](Document, [\n        {\n            key: \"bindCreateImage\",\n            value: function bindCreateImage(createImage, anonymousCrossOrigin) {\n                if (typeof anonymousCrossOrigin === \"boolean\") {\n                    return function(source, forceAnonymousCrossOrigin) {\n                        return createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n                    };\n                }\n                return createImage;\n            }\n        },\n        {\n            key: \"popEmSize\",\n            value: function popEmSize() {\n                var emSizeStack = this.emSizeStack;\n                emSizeStack.pop();\n            }\n        },\n        {\n            key: \"getUniqueId\",\n            value: function getUniqueId() {\n                return \"canvg\".concat(++this.uniqueId);\n            }\n        },\n        {\n            key: \"isImagesLoaded\",\n            value: function isImagesLoaded() {\n                return this.images.every(function(_) {\n                    return _.loaded;\n                });\n            }\n        },\n        {\n            key: \"isFontsLoaded\",\n            value: function isFontsLoaded() {\n                return this.fonts.every(function(_) {\n                    return _.loaded;\n                });\n            }\n        },\n        {\n            key: \"createDocumentElement\",\n            value: function createDocumentElement(document1) {\n                var documentElement = this.createElement(document1.documentElement);\n                documentElement.root = true;\n                documentElement.addStylesFromStyleDefinition();\n                this.documentElement = documentElement;\n                return documentElement;\n            }\n        },\n        {\n            key: \"createElement\",\n            value: function createElement(node) {\n                var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n                var ElementType = Document.elementTypes[elementType];\n                if (typeof ElementType !== \"undefined\") {\n                    return new ElementType(this, node);\n                }\n                return new UnknownElement(this, node);\n            }\n        },\n        {\n            key: \"createTextNode\",\n            value: function createTextNode(node) {\n                return new TextNode(this, node);\n            }\n        },\n        {\n            key: \"setViewBox\",\n            value: function setViewBox(config) {\n                this.screen.setViewBox(_objectSpread$1({\n                    document: this\n                }, config));\n            }\n        },\n        {\n            key: \"window\",\n            get: function get() {\n                return this.screen.window;\n            }\n        },\n        {\n            key: \"fetch\",\n            get: function get() {\n                return this.screen.fetch;\n            }\n        },\n        {\n            key: \"ctx\",\n            get: function get() {\n                return this.screen.ctx;\n            }\n        },\n        {\n            key: \"emSize\",\n            get: function get() {\n                var emSizeStack = this.emSizeStack;\n                return emSizeStack[emSizeStack.length - 1];\n            },\n            set: function set(value) {\n                var emSizeStack = this.emSizeStack;\n                emSizeStack.push(value);\n            }\n        }\n    ]);\n    return Document;\n}();\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _defineProperty__default[\"default\"](target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ var Canvg = /*#__PURE__*/ function() {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ function Canvg(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        _classCallCheck__default[\"default\"](this, Canvg);\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ _createClass__default[\"default\"](Canvg, [\n        {\n            key: \"fork\",\n            /**\r\n     * Create new Canvg instance with inherited options.\r\n     * @param ctx - Rendering context.\r\n     * @param svg - SVG source string or URL.\r\n     * @param options - Rendering options.\r\n     * @returns Canvg instance.\r\n     */ value: function fork(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n            }\n        },\n        {\n            key: \"forkString\",\n            value: function forkString(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n            }\n        },\n        {\n            key: \"ready\",\n            value: function ready() {\n                return this.screen.ready();\n            }\n        },\n        {\n            key: \"isReady\",\n            value: function isReady() {\n                return this.screen.isReady();\n            }\n        },\n        {\n            key: \"render\",\n            value: function() {\n                var _render = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee() {\n                    var options, _args = arguments;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                                    this.start(_objectSpread({\n                                        enableRedraw: true,\n                                        ignoreAnimation: true,\n                                        ignoreMouse: true\n                                    }, options));\n                                    _context.next = 4;\n                                    return this.ready();\n                                case 4:\n                                    this.stop();\n                                case 5:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, this);\n                }));\n                function render() {\n                    return _render.apply(this, arguments);\n                }\n                return render;\n            }()\n        },\n        {\n            key: \"start\",\n            value: function start() {\n                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var documentElement = this.documentElement, screen = this.screen, baseOptions = this.options;\n                screen.start(documentElement, _objectSpread(_objectSpread({\n                    enableRedraw: true\n                }, baseOptions), options));\n            }\n        },\n        {\n            key: \"stop\",\n            value: function stop() {\n                this.screen.stop();\n            }\n        },\n        {\n            key: \"resize\",\n            value: function resize(width) {\n                var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n                var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n                this.documentElement.resize(width, height, preserveAspectRatio);\n            }\n        }\n    ], [\n        {\n            key: \"from\",\n            value: function() {\n                var _from = _asyncToGenerator__default[\"default\"](/*#__PURE__*/ _regeneratorRuntime__default[\"default\"].mark(function _callee2(ctx, svg) {\n                    var options, parser, svgDocument, _args2 = arguments;\n                    return _regeneratorRuntime__default[\"default\"].wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};\n                                    parser = new Parser(options);\n                                    _context2.next = 4;\n                                    return parser.parse(svg);\n                                case 4:\n                                    svgDocument = _context2.sent;\n                                    return _context2.abrupt(\"return\", new Canvg(ctx, svgDocument, options));\n                                case 6:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2);\n                }));\n                function from(_x, _x2) {\n                    return _from.apply(this, arguments);\n                }\n                return from;\n            }()\n        },\n        {\n            key: \"fromString\",\n            value: function fromString(ctx, svg) {\n                var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n                var parser = new Parser(options);\n                var svgDocument = parser.parseFromString(svg);\n                return new Canvg(ctx, svgDocument, options);\n            }\n        }\n    ]);\n    return Canvg;\n}();\nexports.AElement = AElement;\nexports.AnimateColorElement = AnimateColorElement;\nexports.AnimateElement = AnimateElement;\nexports.AnimateTransformElement = AnimateTransformElement;\nexports.BoundingBox = BoundingBox;\nexports.CB1 = CB1;\nexports.CB2 = CB2;\nexports.CB3 = CB3;\nexports.CB4 = CB4;\nexports.Canvg = Canvg;\nexports.CircleElement = CircleElement;\nexports.ClipPathElement = ClipPathElement;\nexports.DefsElement = DefsElement;\nexports.DescElement = DescElement;\nexports.Document = Document;\nexports.Element = Element;\nexports.EllipseElement = EllipseElement;\nexports.FeColorMatrixElement = FeColorMatrixElement;\nexports.FeCompositeElement = FeCompositeElement;\nexports.FeDropShadowElement = FeDropShadowElement;\nexports.FeGaussianBlurElement = FeGaussianBlurElement;\nexports.FeMorphologyElement = FeMorphologyElement;\nexports.FilterElement = FilterElement;\nexports.Font = Font;\nexports.FontElement = FontElement;\nexports.FontFaceElement = FontFaceElement;\nexports.GElement = GElement;\nexports.GlyphElement = GlyphElement;\nexports.GradientElement = GradientElement;\nexports.ImageElement = ImageElement;\nexports.LineElement = LineElement;\nexports.LinearGradientElement = LinearGradientElement;\nexports.MarkerElement = MarkerElement;\nexports.MaskElement = MaskElement;\nexports.Matrix = Matrix;\nexports.MissingGlyphElement = MissingGlyphElement;\nexports.Mouse = Mouse;\nexports.PSEUDO_ZERO = PSEUDO_ZERO;\nexports.Parser = Parser;\nexports.PathElement = PathElement;\nexports.PathParser = PathParser;\nexports.PatternElement = PatternElement;\nexports.Point = Point;\nexports.PolygonElement = PolygonElement;\nexports.PolylineElement = PolylineElement;\nexports.Property = Property;\nexports.QB1 = QB1;\nexports.QB2 = QB2;\nexports.QB3 = QB3;\nexports.RadialGradientElement = RadialGradientElement;\nexports.RectElement = RectElement;\nexports.RenderedElement = RenderedElement;\nexports.Rotate = Rotate;\nexports.SVGElement = SVGElement;\nexports.SVGFontLoader = SVGFontLoader;\nexports.Scale = Scale;\nexports.Screen = Screen;\nexports.Skew = Skew;\nexports.SkewX = SkewX;\nexports.SkewY = SkewY;\nexports.StopElement = StopElement;\nexports.StyleElement = StyleElement;\nexports.SymbolElement = SymbolElement;\nexports.TRefElement = TRefElement;\nexports.TSpanElement = TSpanElement;\nexports.TextElement = TextElement;\nexports.TextPathElement = TextPathElement;\nexports.TitleElement = TitleElement;\nexports.Transform = Transform;\nexports.Translate = Translate;\nexports.UnknownElement = UnknownElement;\nexports.UseElement = UseElement;\nexports.ViewPort = ViewPort;\nexports.compressSpaces = compressSpaces;\nexports[\"default\"] = Canvg;\nexports.getSelectorSpecificity = getSelectorSpecificity;\nexports.normalizeAttributeName = normalizeAttributeName;\nexports.normalizeColor = normalizeColor;\nexports.parseExternalUrl = parseExternalUrl;\nexports.presets = index;\nexports.toNumbers = toNumbers;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.vectorMagnitude = vectorMagnitude;\nexports.vectorsAngle = vectorsAngle;\nexports.vectorsRatio = vectorsRatio; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguY2pzIiwic291cmNlcyI6W10sInNvdXJjZXNDb250ZW50IjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3REMsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJQyxzQkFBc0JELG1CQUFPQSxDQUFDO0FBQ2xDLElBQUlFLG9CQUFvQkYsbUJBQU9BLENBQUM7QUFDaENBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUcsaUJBQWlCSCxtQkFBT0EsQ0FBQztBQUM3QixJQUFJSSxrQkFBa0JKLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlLLGtCQUFrQkwsbUJBQU9BLENBQUM7QUFDOUIsSUFBSU0sZUFBZU4sbUJBQU9BLENBQUM7QUFDM0JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSU8sd0JBQXdCUCxtQkFBT0EsQ0FBQztBQUNwQ0EsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJUSxXQUFXUixtQkFBT0EsQ0FBQztBQUN2QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUixJQUFJUyxZQUFZVCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJVSw2QkFBNkJWLG1CQUFPQSxDQUFDO0FBQ3pDLElBQUlXLGtCQUFrQlgsbUJBQU9BLENBQUM7QUFDOUJBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FBQ1JBLG1CQUFPQSxDQUFDO0FB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QWEsR0FBR2dlO0FBQ2hCaGUsYUFBYSxHQUFHcWU7QUFDaEJyZSxtQkFBbUIsR0FBRzQ4QjtBQUN0QjU4QixvQkFBb0IsR0FBR3FyQztBQUN2QnJyQyxxQkFBcUIsR0FBRzhxQztBQUN4QjlxQyxtQkFBbUIsR0FBRzZoQztBQUN0QjdoQyxvQkFBb0IsR0FBR20xQjtBQUN2Qm4xQixtQkFBbUIsR0FBR214QjtBQUN0Qm54Qix1QkFBdUIsR0FBR3VqQztBQUMxQnZqQyxvQkFBb0IsR0FBRzR3QztBQUN2QjV3QyxpQkFBaUIsR0FBRzBlO0FBQ3BCMWUsaUJBQWlCLEdBQUd5YTtBQUNwQnphLHNCQUFzQixHQUFHcWpCO0FBQ3pCcmpCLGtCQUFrQixHQUFHbXNDO0FBQ3JCbnNDLGdCQUFnQixHQUFHcU47QUFDbkJyTixzQkFBc0IsR0FBRzJFO0FBQ3pCM0Usa0JBQWtCLEdBQUdnekM7QUFDckJoekMsOEJBQThCLEdBQUdpSDtBQUNqQ2pILDhCQUE4QixHQUFHc0Y7QUFDakN0RixzQkFBc0IsR0FBRzZGO0FBQ3pCN0Ysd0JBQXdCLEdBQUcwRjtBQUMzQjFGLGVBQWUsR0FBR3dFO0FBQ2xCeEUsaUJBQWlCLEdBQUdnRjtBQUNwQmhGLGdCQUFnQixHQUFHOEU7QUFDbkI5RSxpQkFBaUIsR0FBRytFO0FBQ3BCL0UsdUJBQXVCLEdBQUdxSTtBQUMxQnJJLG9CQUFvQixHQUFHMkk7QUFDdkIzSSxvQkFBb0IsR0FBR3lJLGNBQ3ZCLDRvVkFBNG9WIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGFwcHktbWV0ZXItdjIvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmNqcz9lZTJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5kZWxldGUtcHJvcGVydHkuanMnKTtcbnZhciBfcmVnZW5lcmF0b3JSdW50aW1lID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3InKTtcbnZhciBfYXN5bmNUb0dlbmVyYXRvciA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcicpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWZsb2F0LmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2guanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMnKTtcbnZhciBfc2xpY2VkVG9BcnJheSA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheScpO1xudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknKTtcbnZhciBfY2xhc3NDYWxsQ2hlY2sgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJyk7XG52YXIgX2NyZWF0ZUNsYXNzID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5LmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmVuZHMtd2l0aC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcycpO1xudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJlcXVpcmUoJ3JhZicpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcycpO1xudmFyIFJHQkNvbG9yID0gcmVxdWlyZSgncmdiY29sb3InKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaC5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanMnKTtcbnZhciBfaW5oZXJpdHMgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJyk7XG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTtcbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb21lLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzJyk7XG52YXIgX3RvQ29uc3VtYWJsZUFycmF5ID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheScpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanMnKTtcbnZhciBfZ2V0ID0gcmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXQnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWxsLmpzJyk7XG52YXIgc3ZnUGF0aGRhdGEgPSByZXF1aXJlKCdzdmctcGF0aGRhdGEnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzJyk7XG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZCA9IHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXNzZXJ0VGhpc0luaXRpYWxpemVkJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMnKTtcbnJlcXVpcmUoJ2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMubWFwLmpzJyk7XG5yZXF1aXJlKCdjb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5hcHBseS5qcycpO1xucmVxdWlyZSgnY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcycpO1xudmFyIHN0YWNrYmx1ckNhbnZhcyA9IHJlcXVpcmUoJ3N0YWNrYmx1ci1jYW52YXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfcmVnZW5lcmF0b3JSdW50aW1lKTtcbnZhciBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2FzeW5jVG9HZW5lcmF0b3IpO1xudmFyIF9zbGljZWRUb0FycmF5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfc2xpY2VkVG9BcnJheSk7XG52YXIgX2RlZmluZVByb3BlcnR5X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfZGVmaW5lUHJvcGVydHkpO1xudmFyIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX2NsYXNzQ2FsbENoZWNrKTtcbnZhciBfY3JlYXRlQ2xhc3NfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KF9jcmVhdGVDbGFzcyk7XG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShyZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xudmFyIFJHQkNvbG9yX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSR0JDb2xvcik7XG52YXIgX2luaGVyaXRzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfaW5oZXJpdHMpO1xudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybik7XG52YXIgX2dldFByb3RvdHlwZU9mX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfZ2V0UHJvdG90eXBlT2YpO1xudmFyIF90b0NvbnN1bWFibGVBcnJheV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koX3RvQ29uc3VtYWJsZUFycmF5KTtcbnZhciBfZ2V0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfZ2V0KTtcbnZhciBfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKTtcblxuLyoqXHJcbiAqIE9wdGlvbnMgcHJlc2V0IGZvciBgT2Zmc2NyZWVuQ2FudmFzYC5cclxuICogQHBhcmFtIGNvbmZpZyAtIFByZXNldCByZXF1aXJlbWVudHMuXHJcbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG9mZnNjcmVlbigpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgRE9NUGFyc2VyRmFsbGJhY2sgPSBfcmVmLkRPTVBhcnNlcjtcblxuICB2YXIgcHJlc2V0ID0ge1xuICAgIHdpbmRvdzogbnVsbCxcbiAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgaWdub3JlTW91c2U6IHRydWUsXG4gICAgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFjayxcbiAgICBjcmVhdGVDYW52YXM6IGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGNyZWF0ZUltYWdlOiBmdW5jdGlvbiBjcmVhdGVJbWFnZSh1cmwpIHtcbiAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciByZXNwb25zZSwgYmxvYiwgaW1nO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGJsb2IgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcChibG9iKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgaW1nID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGltZyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKSgpO1xuICAgIH1cbiAgfTtcblxuICBpZiAodHlwZW9mIERPTVBhcnNlciAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIERPTVBhcnNlckZhbGxiYWNrID09PSAndW5kZWZpbmVkJykge1xuICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkocHJlc2V0LCAnRE9NUGFyc2VyJyk7XG4gIH1cblxuICByZXR1cm4gcHJlc2V0O1xufVxuXG4vKipcclxuICogT3B0aW9ucyBwcmVzZXQgZm9yIGBub2RlLWNhbnZhc2AuXHJcbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLkRPTVBhcnNlciAtIFhNTC9IVE1MIHBhcnNlciBmcm9tIHN0cmluZyBpbnRvIERPTSBEb2N1bWVudC5cclxuICogQHBhcmFtIGNvbmZpZy5jYW52YXMgLSBgbm9kZS1jYW52YXNgIGV4cG9ydHMuXHJcbiAqIEBwYXJhbSBjb25maWcuZmV0Y2ggLSBXSEFUV0ctY29tcGF0aWJsZSBgZmV0Y2hgIGZ1bmN0aW9uLlxyXG4gKiBAcmV0dXJucyBQcmVzZXQgb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIG5vZGUoX3JlZikge1xuICB2YXIgRE9NUGFyc2VyID0gX3JlZi5ET01QYXJzZXIsXG4gICAgICBjYW52YXMgPSBfcmVmLmNhbnZhcyxcbiAgICAgIGZldGNoID0gX3JlZi5mZXRjaDtcbiAgcmV0dXJuIHtcbiAgICB3aW5kb3c6IG51bGwsXG4gICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgIERPTVBhcnNlcjogRE9NUGFyc2VyLFxuICAgIGZldGNoOiBmZXRjaCxcbiAgICBjcmVhdGVDYW52YXM6IGNhbnZhcy5jcmVhdGVDYW52YXMsXG4gICAgY3JlYXRlSW1hZ2U6IGNhbnZhcy5sb2FkSW1hZ2VcbiAgfTtcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdG9mZnNjcmVlbjogb2Zmc2NyZWVuLFxuXHRub2RlOiBub2RlXG59KTtcblxuLyoqXHJcbiAqIEhUTUwtc2FmZSBjb21wcmVzcyB3aGl0ZS1zcGFjZXMuXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gY29tcHJlc3MuXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5mdW5jdGlvbiBjb21wcmVzc1NwYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oPyFcXHUzMDAwKVxccysvZ20sICcgJyk7XG59XG4vKipcclxuICogSFRNTC1zYWZlIGxlZnQgdHJpbS5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcbiBcXHRdKy8sICcnKTtcbn1cbi8qKlxyXG4gKiBIVE1MLXNhZmUgcmlnaHQgdHJpbS5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmltUmlnaHQoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcbiBcXHRdKyQvLCAnJyk7XG59XG4vKipcclxuICogU3RyaW5nIHRvIG51bWJlcnMgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cclxuICogQHJldHVybnMgTnVtYmVycyBhcnJheS5cclxuICovXG5cbmZ1bmN0aW9uIHRvTnVtYmVycyhzdHIpIHtcbiAgdmFyIG1hdGNoZXMgPSAoc3RyIHx8ICcnKS5tYXRjaCgvLT8oXFxkKyg/OlxcLlxcZCooPzpbZUVdWystXT9cXGQrKT8pP3xcXC5cXGQrKSg/PVxcRHwkKS9nbSkgfHwgW107XG4gIHJldHVybiBtYXRjaGVzLm1hcChwYXJzZUZsb2F0KTtcbn0gLy8gTWljcm9zb2Z0IEVkZ2UgZml4XG5cbnZhciBhbGxVcHBlcmNhc2UgPSAvXltBLVotXSskLztcbi8qKlxyXG4gKiBOb3JtYWxpemUgYXR0cmlidXRlIG5hbWUuXHJcbiAqIEBwYXJhbSBuYW1lIC0gQXR0cmlidXRlIG5hbWUuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgYXR0cmlidXRlIG5hbWUuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgaWYgKGFsbFVwcGVyY2FzZS50ZXN0KG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuLyoqXHJcbiAqIFBhcnNlIGV4dGVybmFsIFVSTC5cclxuICogQHBhcmFtIHVybCAtIENTUyB1cmwgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBQYXJzZWQgVVJMLlxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFVybCh1cmwpIHtcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgc2luZ2xlIHF1b3RlcyBbMl1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIGRvdWJsZSBxdW90ZXMgWzNdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgbm8gcXVvdGVzIFs0XVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgdiAgICAgICAgIHZcbiAgdmFyIHVybE1hdGNoID0gL3VybFxcKCgnKFteJ10rKSd8XCIoW15cIl0rKVwifChbXidcIildKykpXFwpLy5leGVjKHVybCkgfHwgW107XG4gIHJldHVybiB1cmxNYXRjaFsyXSB8fCB1cmxNYXRjaFszXSB8fCB1cmxNYXRjaFs0XTtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gZmxvYXRzIHRvIGludGVnZXJzIGluIHJnYiBjb2xvcnMuXHJcbiAqIEBwYXJhbSBjb2xvciAtIENvbG9yIHRvIG5vcm1hbGl6ZS5cclxuICogQHJldHVybnMgTm9ybWFsaXplZCBjb2xvci5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGlmICghY29sb3Iuc3RhcnRzV2l0aCgncmdiJykpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICB2YXIgcmdiUGFydHMgPSAzO1xuICB2YXIgbm9ybWFsaXplZENvbG9yID0gY29sb3IucmVwbGFjZSgvXFxkKyhcXC5cXGQrKT8vZywgZnVuY3Rpb24gKG51bSwgaXNGbG9hdCkge1xuICAgIHJldHVybiByZ2JQYXJ0cy0tICYmIGlzRmxvYXQgPyBTdHJpbmcoTWF0aC5yb3VuZChwYXJzZUZsb2F0KG51bSkpKSA6IG51bTtcbiAgfSk7XG4gIHJldHVybiBub3JtYWxpemVkQ29sb3I7XG59XG5cbi8vIHNsaWdodGx5IG1vZGlmaWVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tlZWdhbnN0cmVldC9zcGVjaWZpY2l0eS9ibG9iL21hc3Rlci9zcGVjaWZpY2l0eS5qc1xudmFyIGF0dHJpYnV0ZVJlZ2V4ID0gLyhcXFtbXlxcXV0rXFxdKS9nO1xudmFyIGlkUmVnZXggPSAvKCNbXlxccys+fi5bOl0rKS9nO1xudmFyIGNsYXNzUmVnZXggPSAvKFxcLlteXFxzKz5+Lls6XSspL2c7XG52YXIgcHNldWRvRWxlbWVudFJlZ2V4ID0gLyg6OlteXFxzKz5+Lls6XSt8OmZpcnN0LWxpbmV8OmZpcnN0LWxldHRlcnw6YmVmb3JlfDphZnRlcikvZ2k7XG52YXIgcHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCA9IC8oOltcXHctXStcXChbXildKlxcKSkvZ2k7XG52YXIgcHNldWRvQ2xhc3NSZWdleCA9IC8oOlteXFxzKz5+Lls6XSspL2c7XG52YXIgZWxlbWVudFJlZ2V4ID0gLyhbXlxccys+fi5bOl0rKS9nO1xuXG5mdW5jdGlvbiBmaW5kU2VsZWN0b3JNYXRjaChzZWxlY3RvciwgcmVnZXgpIHtcbiAgdmFyIG1hdGNoZXMgPSByZWdleC5leGVjKHNlbGVjdG9yKTtcblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gW3NlbGVjdG9yLCAwXTtcbiAgfVxuXG4gIHJldHVybiBbc2VsZWN0b3IucmVwbGFjZShyZWdleCwgJyAnKSwgbWF0Y2hlcy5sZW5ndGhdO1xufVxuLyoqXHJcbiAqIE1lYXN1cmUgc2VsZWN0b3Igc3BlY2lmaWNpdHkuXHJcbiAqIEBwYXJhbSBzZWxlY3RvciAtIFNlbGVjdG9yIHRvIG1lYXN1cmUuXHJcbiAqIEByZXR1cm5zIFNwZWNpZmljaXR5LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTZWxlY3RvclNwZWNpZmljaXR5KHNlbGVjdG9yKSB7XG4gIHZhciBzcGVjaWZpY2l0eSA9IFswLCAwLCAwXTtcbiAgdmFyIGN1cnJlbnRTZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoLzpub3RcXCgoW14pXSopXFwpL2csICcgICAgICQxICcpLnJlcGxhY2UoL3tbXFxzXFxTXSovZ20sICcgJyk7XG4gIHZhciBkZWx0YSA9IDA7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaCA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgYXR0cmlidXRlUmVnZXgpO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2gyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9maW5kU2VsZWN0b3JNYXRjaCwgMik7XG5cbiAgY3VycmVudFNlbGVjdG9yID0gX2ZpbmRTZWxlY3Rvck1hdGNoMlswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2gyWzFdO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoMyA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgaWRSZWdleCk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDQgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2ZpbmRTZWxlY3Rvck1hdGNoMywgMik7XG5cbiAgY3VycmVudFNlbGVjdG9yID0gX2ZpbmRTZWxlY3Rvck1hdGNoNFswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2g0WzFdO1xuICBzcGVjaWZpY2l0eVswXSArPSBkZWx0YTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoNSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgY2xhc3NSZWdleCk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDYgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2ZpbmRTZWxlY3Rvck1hdGNoNSwgMik7XG5cbiAgY3VycmVudFNlbGVjdG9yID0gX2ZpbmRTZWxlY3Rvck1hdGNoNlswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2g2WzFdO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoNyA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvRWxlbWVudFJlZ2V4KTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoOCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZmluZFNlbGVjdG9yTWF0Y2g3LCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2g4WzBdO1xuICBkZWx0YSA9IF9maW5kU2VsZWN0b3JNYXRjaDhbMV07XG4gIHNwZWNpZmljaXR5WzJdICs9IGRlbHRhO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2g5ID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4KTtcblxuICB2YXIgX2ZpbmRTZWxlY3Rvck1hdGNoMTAgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2ZpbmRTZWxlY3Rvck1hdGNoOSwgMik7XG5cbiAgY3VycmVudFNlbGVjdG9yID0gX2ZpbmRTZWxlY3Rvck1hdGNoMTBbMF07XG4gIGRlbHRhID0gX2ZpbmRTZWxlY3Rvck1hdGNoMTBbMV07XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2gxMSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NSZWdleCk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDEyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9maW5kU2VsZWN0b3JNYXRjaDExLCAyKTtcblxuICBjdXJyZW50U2VsZWN0b3IgPSBfZmluZFNlbGVjdG9yTWF0Y2gxMlswXTtcbiAgZGVsdGEgPSBfZmluZFNlbGVjdG9yTWF0Y2gxMlsxXTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIGN1cnJlbnRTZWxlY3RvciA9IGN1cnJlbnRTZWxlY3Rvci5yZXBsYWNlKC9bKlxccys+fl0vZywgJyAnKS5yZXBsYWNlKC9bIy5dL2csICcgJyk7XG5cbiAgdmFyIF9maW5kU2VsZWN0b3JNYXRjaDEzID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBlbGVtZW50UmVnZXgpO1xuXG4gIHZhciBfZmluZFNlbGVjdG9yTWF0Y2gxNCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZmluZFNlbGVjdG9yTWF0Y2gxMywgMik7XG5cbiAgY3VycmVudFNlbGVjdG9yID0gX2ZpbmRTZWxlY3Rvck1hdGNoMTRbMF07XG4gIGRlbHRhID0gX2ZpbmRTZWxlY3Rvck1hdGNoMTRbMV07XG4gIC8vIGxndG0gW2pzL3VzZWxlc3MtYXNzaWdubWVudC10by1sb2NhbF1cbiAgc3BlY2lmaWNpdHlbMl0gKz0gZGVsdGE7XG4gIHJldHVybiBzcGVjaWZpY2l0eS5qb2luKCcnKTtcbn1cblxudmFyIFBTRVVET19aRVJPID0gLjAwMDAwMDAxO1xuLyoqXHJcbiAqIFZlY3RvciBtYWduaXR1ZGUuXHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JNYWduaXR1ZGUodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sIDIpICsgTWF0aC5wb3codlsxXSwgMikpO1xufVxuLyoqXHJcbiAqIFJhdGlvIGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAqIEBwYXJhbSB1XHJcbiAqIEBwYXJhbSB2XHJcbiAqIEByZXR1cm5zIE51bWJlciByZXN1bHQuXHJcbiAqL1xuXG5mdW5jdGlvbiB2ZWN0b3JzUmF0aW8odSwgdikge1xuICByZXR1cm4gKHVbMF0gKiB2WzBdICsgdVsxXSAqIHZbMV0pIC8gKHZlY3Rvck1hZ25pdHVkZSh1KSAqIHZlY3Rvck1hZ25pdHVkZSh2KSk7XG59XG4vKipcclxuICogQW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICogQHBhcmFtIHVcclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3RvcnNBbmdsZSh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModmVjdG9yc1JhdGlvKHUsIHYpKTtcbn1cbmZ1bmN0aW9uIENCMSh0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5mdW5jdGlvbiBDQjIodCkge1xuICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIENCMyh0KSB7XG4gIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0I0KHQpIHtcbiAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIFFCMSh0KSB7XG4gIHJldHVybiB0ICogdDtcbn1cbmZ1bmN0aW9uIFFCMih0KSB7XG4gIHJldHVybiAyICogdCAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBRQjModCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCk7XG59XG5cbnZhciBQcm9wZXJ0eSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb3BlcnR5KGRvY3VtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUHJvcGVydHkpO1xuXG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaXNOb3JtYWxpemVkQ29sb3IgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUHJvcGVydHksIFt7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KCkge1xuICAgICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyAnO1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgcmV0dXJuIGNvbXByZXNzU3BhY2VzKHRoaXMuZ2V0U3RyaW5nKCkpLnRyaW0oKS5zcGxpdChzZXBhcmF0b3IpLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhc1ZhbHVlKHplcm9Jc1ZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAoemVyb0lzVmFsdWUgfHwgdmFsdWUgIT09IDApICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3RyaW5nKHJlZ2V4cCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVnZXhwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVXJsRGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1VybERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1N0cmluZygvXnVybFxcKC8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BpeGVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BpeGVscygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFzU3RyaW5nID0gdGhpcy5nZXRTdHJpbmcoKTtcblxuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgYXNTdHJpbmcuZW5kc1dpdGgoJ3B4Jyk6XG4gICAgICAgIGNhc2UgL15bMC05XSskLy50ZXN0KGFzU3RyaW5nKTpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShkZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROdW1iZXIoZGVmKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KGRlZik7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICBpZiAodGhpcy5pc1N0cmluZygvJSQvKSkge1xuICAgICAgICBuIC89IDEwMC4wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0cmluZyhkZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAndW5kZWZpbmVkJyB8fCB0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLnZhbHVlID09PSAndW5kZWZpbmVkJyA/ICcnIDogU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3RyaW5nKGRlZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbG9yKGRlZikge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5nZXRTdHJpbmcoZGVmKTtcblxuICAgICAgaWYgKHRoaXMuaXNOb3JtYWxpemVkQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmlzTm9ybWFsaXplZENvbG9yID0gdHJ1ZTtcbiAgICAgIGNvbG9yID0gbm9ybWFsaXplQ29sb3IoY29sb3IpO1xuICAgICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREcGlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHBpKCkge1xuICAgICAgcmV0dXJuIDk2LjA7IC8vIFRPRE86IGNvbXB1dGU/XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5yb290RW1TaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRFbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmVtU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VW5pdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdHJpbmcoKS5yZXBsYWNlKC9bMC05Li1dL2csICcnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGl4ZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpeGVscyhheGlzT3JJc0ZvbnRTaXplKSB7XG4gICAgICB2YXIgcHJvY2Vzc1BlcmNlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9yZWYgPSB0eXBlb2YgYXhpc09ySXNGb250U2l6ZSA9PT0gJ2Jvb2xlYW4nID8gW3VuZGVmaW5lZCwgYXhpc09ySXNGb250U2l6ZV0gOiBbYXhpc09ySXNGb250U2l6ZV0sXG4gICAgICAgICAgX3JlZjIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3JlZiwgMiksXG4gICAgICAgICAgYXhpcyA9IF9yZWYyWzBdLFxuICAgICAgICAgIGlzRm9udFNpemUgPSBfcmVmMlsxXTtcblxuICAgICAgdmFyIHZpZXdQb3J0ID0gdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQ7XG5cbiAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtaW4kLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIE1hdGgubWluKHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1heCQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogTWF0aC5tYXgodmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKSwgdmlld1BvcnQuY29tcHV0ZVNpemUoJ3knKSk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92dyQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAvIDEwMC4wICogdmlld1BvcnQuY29tcHV0ZVNpemUoJ3gnKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZoJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmVtJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRSZW0oKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2VtJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpO1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZXgkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCkgLyAyLjA7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9weCQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B0JC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAqICgxLjAgLyA3Mi4wKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3BjJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogMTU7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9jbSQvKTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgLyAyLjU0O1xuXG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvbW0kLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldERwaSgpIC8gMjUuNDtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2luJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLykgJiYgaXNGb250U2l6ZTpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcblxuICAgICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZShheGlzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuID0gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgICAgICAgaWYgKHByb2Nlc3NQZXJjZW50ICYmIG4gPCAxLjApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG4gKiB2aWV3UG9ydC5jb21wdXRlU2l6ZShheGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaWxsaXNlY29uZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRzKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzU3RyaW5nKC9tcyQvKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAxMDAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRSYWRpYW5zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJhZGlhbnMoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZGVnJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAxODAuMCk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9ncmFkJC8pOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAyMDAuMCk7XG5cbiAgICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9yYWQkLyk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICB2YXIgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuICAgICAgdmFyIG5hbWUgPSAvIyhbXiknXCJdKykvLmV4ZWMoYXNTdHJpbmcpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZVsxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBhc1N0cmluZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZGVmaW5pdGlvbnNbbmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpbGxTdHlsZURlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbihlbGVtZW50LCBvcGFjaXR5KSB7XG4gICAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmICghZGVmKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBncmFkaWVudFxuXG5cbiAgICAgIGlmICh0eXBlb2YgZGVmLmNyZWF0ZUdyYWRpZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBkZWYuY3JlYXRlR3JhZGllbnQodGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgICAgfSAvLyBwYXR0ZXJuXG5cblxuICAgICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlUGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm5UcmFuc2Zvcm0gPSBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJyk7XG4gICAgICAgICAgZGVmID0gZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgICBpZiAocGF0dGVyblRyYW5zZm9ybS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBkZWYuZ2V0QXR0cmlidXRlKCdwYXR0ZXJuVHJhbnNmb3JtJywgdHJ1ZSkuc2V0VmFsdWUocGF0dGVyblRyYW5zZm9ybS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZi5jcmVhdGVQYXR0ZXJuKHRoaXMuZG9jdW1lbnQuY3R4LCBlbGVtZW50LCBvcGFjaXR5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRleHRCYXNlbGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb3BlcnR5LnRleHRCYXNlbGluZU1hcHBpbmdbdGhpcy5nZXRTdHJpbmcoKV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldENvbG9yKCk7XG4gICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgdmFyIGNvbW1hcyA9IDA7IC8vIFNpbXVsYXRlIG9sZCBSR0JDb2xvciB2ZXJzaW9uLCB3aGljaCBjYW4ndCBwYXJzZSByZ2JhLlxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJywnKSB7XG4gICAgICAgICAgY29tbWFzKys7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tbWFzID09PSAzKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wYWNpdHkuaGFzVmFsdWUoKSAmJiB0aGlzLmlzU3RyaW5nKCkgJiYgY29tbWFzICE9PSAzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IG5ldyBSR0JDb2xvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odmFsdWUpO1xuXG4gICAgICAgIGlmIChjb2xvci5vaykge1xuICAgICAgICAgIGNvbG9yLmFscGhhID0gb3BhY2l0eS5nZXROdW1iZXIoKTtcbiAgICAgICAgICB2YWx1ZSA9IGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgdGhpcy5uYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1wdHkoZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdFTVBUWScsICcnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJvcGVydHk7XG59KCk7XG5Qcm9wZXJ0eS50ZXh0QmFzZWxpbmVNYXBwaW5nID0ge1xuICAnYmFzZWxpbmUnOiAnYWxwaGFiZXRpYycsXG4gICdiZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAndGV4dC1iZWZvcmUtZWRnZSc6ICd0b3AnLFxuICAnbWlkZGxlJzogJ21pZGRsZScsXG4gICdjZW50cmFsJzogJ21pZGRsZScsXG4gICdhZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICd0ZXh0LWFmdGVyLWVkZ2UnOiAnYm90dG9tJyxcbiAgJ2lkZW9ncmFwaGljJzogJ2lkZW9ncmFwaGljJyxcbiAgJ2FscGhhYmV0aWMnOiAnYWxwaGFiZXRpYycsXG4gICdoYW5naW5nJzogJ2hhbmdpbmcnLFxuICAnbWF0aGVtYXRpY2FsJzogJ2FscGhhYmV0aWMnXG59O1xuXG52YXIgVmlld1BvcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3UG9ydCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFZpZXdQb3J0KTtcblxuICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFZpZXdQb3J0LCBbe1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMudmlld1BvcnRzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEN1cnJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnZpZXdQb3J0cy5wdXNoKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUN1cnJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ3VycmVudCgpIHtcbiAgICAgIHRoaXMudmlld1BvcnRzLnBvcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDdXJyZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnQoKSB7XG4gICAgICB2YXIgdmlld1BvcnRzID0gdGhpcy52aWV3UG9ydHM7XG4gICAgICByZXR1cm4gdmlld1BvcnRzW3ZpZXdQb3J0cy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZVNpemUoZCkge1xuICAgICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGQgPT09ICd4Jykge1xuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGQgPT09ICd5Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmhlaWdodCwgMikpIC8gTWF0aC5zcXJ0KDIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudCgpLndpZHRoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnQoKS5oZWlnaHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZpZXdQb3J0O1xufSgpO1xuXG52YXIgUG9pbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBQb2ludCk7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvaW50LCBbe1xuICAgIGtleTogXCJhbmdsZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuZ2xlVG8ocG9pbnQpIHtcbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKHBvaW50LnkgLSB0aGlzLnksIHBvaW50LnggLSB0aGlzLngpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgIHkgPSB0aGlzLnk7XG4gICAgICB2YXIgeHAgPSB4ICogdHJhbnNmb3JtWzBdICsgeSAqIHRyYW5zZm9ybVsyXSArIHRyYW5zZm9ybVs0XTtcbiAgICAgIHZhciB5cCA9IHggKiB0cmFuc2Zvcm1bMV0gKyB5ICogdHJhbnNmb3JtWzNdICsgdHJhbnNmb3JtWzVdO1xuICAgICAgdGhpcy54ID0geHA7XG4gICAgICB0aGlzLnkgPSB5cDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShwb2ludCkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgdmFyIF90b051bWJlcnMgPSB0b051bWJlcnMocG9pbnQpLFxuICAgICAgICAgIF90b051bWJlcnMyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90b051bWJlcnMsIDIpLFxuICAgICAgICAgIF90b051bWJlcnMyJCA9IF90b051bWJlcnMyWzBdLFxuICAgICAgICAgIHggPSBfdG9OdW1iZXJzMiQgPT09IHZvaWQgMCA/IGRlZmF1bHRWYWx1ZSA6IF90b051bWJlcnMyJCxcbiAgICAgICAgICBfdG9OdW1iZXJzMiQyID0gX3RvTnVtYmVyczJbMV0sXG4gICAgICAgICAgeSA9IF90b051bWJlcnMyJDIgPT09IHZvaWQgMCA/IGRlZmF1bHRWYWx1ZSA6IF90b051bWJlcnMyJDI7XG5cbiAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlU2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTY2FsZShzY2FsZSkge1xuICAgICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMTtcblxuICAgICAgdmFyIF90b051bWJlcnMzID0gdG9OdW1iZXJzKHNjYWxlKSxcbiAgICAgICAgICBfdG9OdW1iZXJzNCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdG9OdW1iZXJzMywgMiksXG4gICAgICAgICAgX3RvTnVtYmVyczQkID0gX3RvTnVtYmVyczRbMF0sXG4gICAgICAgICAgeCA9IF90b051bWJlcnM0JCA9PT0gdm9pZCAwID8gZGVmYXVsdFZhbHVlIDogX3RvTnVtYmVyczQkLFxuICAgICAgICAgIF90b051bWJlcnM0JDIgPSBfdG9OdW1iZXJzNFsxXSxcbiAgICAgICAgICB5ID0gX3RvTnVtYmVyczQkMiA9PT0gdm9pZCAwID8geCA6IF90b051bWJlcnM0JDI7XG5cbiAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICAgICAgdmFyIHBvaW50cyA9IHRvTnVtYmVycyhwYXRoKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIHBhdGhQb2ludHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICBwYXRoUG9pbnRzLnB1c2gobmV3IFBvaW50KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aFBvaW50cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9pbnQ7XG59KCk7XG5cbnZhciBNb3VzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1vdXNlKHNjcmVlbikge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgTW91c2UpO1xuXG4gICAgdGhpcy5zY3JlZW4gPSBzY3JlZW47XG4gICAgdGhpcy53b3JraW5nID0gZmFsc2U7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuXG4gICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcblxuICAgIHRoaXMub25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1vdXNlLCBbe1xuICAgIGtleTogXCJpc1dvcmtpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNXb3JraW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMud29ya2luZztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICBpZiAodGhpcy53b3JraW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcmVlbiA9IHRoaXMuc2NyZWVuLFxuICAgICAgICAgIG9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2ssXG4gICAgICAgICAgb25Nb3VzZU1vdmUgPSB0aGlzLm9uTW91c2VNb3ZlO1xuICAgICAgdmFyIGNhbnZhcyA9IHNjcmVlbi5jdHguY2FudmFzO1xuICAgICAgY2FudmFzLm9uY2xpY2sgPSBvbkNsaWNrO1xuICAgICAgY2FudmFzLm9ubW91c2Vtb3ZlID0gb25Nb3VzZU1vdmU7XG4gICAgICB0aGlzLndvcmtpbmcgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICBpZiAoIXRoaXMud29ya2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLnNjcmVlbi5jdHguY2FudmFzO1xuICAgICAgdGhpcy53b3JraW5nID0gZmFsc2U7XG4gICAgICBjYW52YXMub25jbGljayA9IG51bGw7XG4gICAgICBjYW52YXMub25tb3VzZW1vdmUgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzRXZlbnRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMud29ya2luZyAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJydW5FdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuRXZlbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLnNjcmVlbixcbiAgICAgICAgICBldmVudHMgPSB0aGlzLmV2ZW50cyxcbiAgICAgICAgICBldmVudEVsZW1lbnRzID0gdGhpcy5ldmVudEVsZW1lbnRzO1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3R4LmNhbnZhcy5zdHlsZTtcblxuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgfVxuXG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZiwgaSkge1xuICAgICAgICB2YXIgcnVuID0gX3JlZi5ydW47XG4gICAgICAgIHZhciBlbGVtZW50ID0gZXZlbnRFbGVtZW50c1tpXTtcblxuICAgICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICAgIHJ1bihlbGVtZW50KTtcbiAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBkb25lIHJ1bm5pbmcsIGNsZWFyXG5cbiAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUGF0aChlbGVtZW50LCBjdHgpIHtcbiAgICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFjdHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudHMsXG4gICAgICAgICAgZXZlbnRFbGVtZW50cyA9IHRoaXMuZXZlbnRFbGVtZW50cztcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMiwgaSkge1xuICAgICAgICB2YXIgeCA9IF9yZWYyLngsXG4gICAgICAgICAgICB5ID0gX3JlZjIueTtcblxuICAgICAgICBpZiAoIWV2ZW50RWxlbWVudHNbaV0gJiYgY3R4LmlzUG9pbnRJblBhdGggJiYgY3R4LmlzUG9pbnRJblBhdGgoeCwgeSkpIHtcbiAgICAgICAgICBldmVudEVsZW1lbnRzW2ldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tCb3VuZGluZ0JveChlbGVtZW50LCBib3VuZGluZ0JveCkge1xuICAgICAgaWYgKCF0aGlzLndvcmtpbmcgfHwgIWJvdW5kaW5nQm94KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuZXZlbnRzLFxuICAgICAgICAgIGV2ZW50RWxlbWVudHMgPSB0aGlzLmV2ZW50RWxlbWVudHM7XG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMsIGkpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgICAgICAgeSA9IF9yZWYzLnk7XG5cbiAgICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGJvdW5kaW5nQm94LmlzUG9pbnRJbkJveCh4LCB5KSkge1xuICAgICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFwWFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwWFkoeCwgeSkge1xuICAgICAgdmFyIF90aGlzJHNjcmVlbiA9IHRoaXMuc2NyZWVuLFxuICAgICAgICAgIHdpbmRvdyA9IF90aGlzJHNjcmVlbi53aW5kb3csXG4gICAgICAgICAgY3R4ID0gX3RoaXMkc2NyZWVuLmN0eDtcbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgIHZhciBlbGVtZW50ID0gY3R4LmNhbnZhcztcblxuICAgICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgICAgcG9pbnQueCAtPSBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIHBvaW50LnkgLT0gZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy5zY3JvbGxYKSB7XG4gICAgICAgIHBvaW50LnggKz0gd2luZG93LnNjcm9sbFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgICBwb2ludC55ICs9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgICAgdmFyIF90aGlzJG1hcFhZID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSxcbiAgICAgICAgICB4ID0gX3RoaXMkbWFwWFkueCxcbiAgICAgICAgICB5ID0gX3RoaXMkbWFwWFkueTtcblxuICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdvbmNsaWNrJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4oZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25DbGljaykge1xuICAgICAgICAgICAgZXZlbnRUYXJnZXQub25DbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMkbWFwWFkyID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSxcbiAgICAgICAgICB4ID0gX3RoaXMkbWFwWFkyLngsXG4gICAgICAgICAgeSA9IF90aGlzJG1hcFhZMi55O1xuXG4gICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ29ubW91c2Vtb3ZlJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcnVuOiBmdW5jdGlvbiBydW4oZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQub25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTW91c2U7XG59KCk7XG5cbnZhciBkZWZhdWx0V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xudmFyIGRlZmF1bHRGZXRjaCQxID0gdHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyA/IGZldGNoLmJpbmQodW5kZWZpbmVkKSAvLyBgZmV0Y2hgIGRlcGVuZHMgb24gY29udGV4dDogYHNvbWVPYmplY3QuZmV0Y2goLi4uKWAgd2lsbCB0aHJvdyBlcnJvci5cbjogbnVsbDtcblxudmFyIFNjcmVlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcmVlbihjdHgpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIF9yZWYkZmV0Y2ggPSBfcmVmLmZldGNoLFxuICAgICAgICBmZXRjaCA9IF9yZWYkZmV0Y2ggPT09IHZvaWQgMCA/IGRlZmF1bHRGZXRjaCQxIDogX3JlZiRmZXRjaCxcbiAgICAgICAgX3JlZiR3aW5kb3cgPSBfcmVmLndpbmRvdyxcbiAgICAgICAgd2luZG93ID0gX3JlZiR3aW5kb3cgPT09IHZvaWQgMCA/IGRlZmF1bHRXaW5kb3cgOiBfcmVmJHdpbmRvdztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU2NyZWVuKTtcblxuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuRlJBTUVSQVRFID0gMzA7XG4gICAgdGhpcy5NQVhfVklSVFVBTF9QSVhFTFMgPSAzMDAwMDtcbiAgICB0aGlzLkNMSUVOVF9XSURUSCA9IDgwMDtcbiAgICB0aGlzLkNMSUVOVF9IRUlHSFQgPSA2MDA7XG4gICAgdGhpcy52aWV3UG9ydCA9IG5ldyBWaWV3UG9ydCgpO1xuICAgIHRoaXMubW91c2UgPSBuZXcgTW91c2UodGhpcyk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gW107XG4gICAgdGhpcy53YWl0cyA9IFtdO1xuICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pc1JlYWR5TG9jayA9IGZhbHNlO1xuICAgIHRoaXMuaXNGaXJzdFJlbmRlciA9IHRydWU7XG4gICAgdGhpcy5pbnRlcnZhbElkID0gbnVsbDtcbiAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNjcmVlbiwgW3tcbiAgICBrZXk6IFwid2FpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0KGNoZWNrZXIpIHtcbiAgICAgIHRoaXMud2FpdHMucHVzaChjaGVja2VyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICAgIGlmICh0aGlzLmlzUmVhZHlMb2NrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNSZWFkeUxvY2sgPSB0aGlzLndhaXRzLmV2ZXJ5KGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBfKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzUmVhZHlMb2NrKSB7XG4gICAgICAgIHRoaXMud2FpdHMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5yZXNvbHZlUmVhZHkpIHtcbiAgICAgICAgICB0aGlzLnJlc29sdmVSZWFkeSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNSZWFkeUxvY2sgPSBpc1JlYWR5TG9jaztcbiAgICAgIHJldHVybiBpc1JlYWR5TG9jaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0RGVmYXVsdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdHMoY3R4KSB7XG4gICAgICAvLyBpbml0aWFsIHZhbHVlcyBhbmQgZGVmYXVsdHNcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICAgIGN0eC5taXRlckxpbWl0ID0gNDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vmlld0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWV3Qm94KF9yZWYyKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSBfcmVmMi5kb2N1bWVudCxcbiAgICAgICAgICBjdHggPSBfcmVmMi5jdHgsXG4gICAgICAgICAgYXNwZWN0UmF0aW8gPSBfcmVmMi5hc3BlY3RSYXRpbyxcbiAgICAgICAgICB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICAgIGRlc2lyZWRXaWR0aCA9IF9yZWYyLmRlc2lyZWRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQsXG4gICAgICAgICAgZGVzaXJlZEhlaWdodCA9IF9yZWYyLmRlc2lyZWRIZWlnaHQsXG4gICAgICAgICAgX3JlZjIkbWluWCA9IF9yZWYyLm1pblgsXG4gICAgICAgICAgbWluWCA9IF9yZWYyJG1pblggPT09IHZvaWQgMCA/IDAgOiBfcmVmMiRtaW5YLFxuICAgICAgICAgIF9yZWYyJG1pblkgPSBfcmVmMi5taW5ZLFxuICAgICAgICAgIG1pblkgPSBfcmVmMiRtaW5ZID09PSB2b2lkIDAgPyAwIDogX3JlZjIkbWluWSxcbiAgICAgICAgICByZWZYID0gX3JlZjIucmVmWCxcbiAgICAgICAgICByZWZZID0gX3JlZjIucmVmWSxcbiAgICAgICAgICBfcmVmMiRjbGlwID0gX3JlZjIuY2xpcCxcbiAgICAgICAgICBjbGlwID0gX3JlZjIkY2xpcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRjbGlwLFxuICAgICAgICAgIF9yZWYyJGNsaXBYID0gX3JlZjIuY2xpcFgsXG4gICAgICAgICAgY2xpcFggPSBfcmVmMiRjbGlwWCA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJGNsaXBYLFxuICAgICAgICAgIF9yZWYyJGNsaXBZID0gX3JlZjIuY2xpcFksXG4gICAgICAgICAgY2xpcFkgPSBfcmVmMiRjbGlwWSA9PT0gdm9pZCAwID8gMCA6IF9yZWYyJGNsaXBZO1xuICAgICAgLy8gYXNwZWN0IHJhdGlvIC0gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2Nvb3Jkcy5odG1sI1ByZXNlcnZlQXNwZWN0UmF0aW9BdHRyaWJ1dGVcbiAgICAgIHZhciBjbGVhbkFzcGVjdFJhdGlvID0gY29tcHJlc3NTcGFjZXMoYXNwZWN0UmF0aW8pLnJlcGxhY2UoL15kZWZlclxccy8sICcnKTsgLy8gaWdub3JlIGRlZmVyXG5cbiAgICAgIHZhciBfY2xlYW5Bc3BlY3RSYXRpbyRzcGwgPSBjbGVhbkFzcGVjdFJhdGlvLnNwbGl0KCcgJyksXG4gICAgICAgICAgX2NsZWFuQXNwZWN0UmF0aW8kc3BsMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfY2xlYW5Bc3BlY3RSYXRpbyRzcGwsIDIpLFxuICAgICAgICAgIGFzcGVjdFJhdGlvQWxpZ24gPSBfY2xlYW5Bc3BlY3RSYXRpbyRzcGwyWzBdLFxuICAgICAgICAgIGFzcGVjdFJhdGlvTWVldE9yU2xpY2UgPSBfY2xlYW5Bc3BlY3RSYXRpbyRzcGwyWzFdO1xuXG4gICAgICB2YXIgYWxpZ24gPSBhc3BlY3RSYXRpb0FsaWduIHx8ICd4TWlkWU1pZCc7XG4gICAgICB2YXIgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb01lZXRPclNsaWNlIHx8ICdtZWV0JzsgLy8gY2FsY3VsYXRlIHNjYWxlXG5cbiAgICAgIHZhciBzY2FsZVggPSB3aWR0aCAvIGRlc2lyZWRXaWR0aDtcbiAgICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBkZXNpcmVkSGVpZ2h0O1xuICAgICAgdmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgdmFyIHNjYWxlTWF4ID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgdmFyIGZpbmFsRGVzaXJlZFdpZHRoID0gZGVzaXJlZFdpZHRoO1xuICAgICAgdmFyIGZpbmFsRGVzaXJlZEhlaWdodCA9IGRlc2lyZWRIZWlnaHQ7XG5cbiAgICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ21lZXQnKSB7XG4gICAgICAgIGZpbmFsRGVzaXJlZFdpZHRoICo9IHNjYWxlTWluO1xuICAgICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWV0T3JTbGljZSA9PT0gJ3NsaWNlJykge1xuICAgICAgICBmaW5hbERlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDtcbiAgICAgICAgZmluYWxEZXNpcmVkSGVpZ2h0ICo9IHNjYWxlTWF4O1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmWFByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZYJywgcmVmWCk7XG4gICAgICB2YXIgcmVmWVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZZJywgcmVmWSk7XG4gICAgICB2YXIgaGFzUmVmcyA9IHJlZlhQcm9wLmhhc1ZhbHVlKCkgJiYgcmVmWVByb3AuaGFzVmFsdWUoKTtcblxuICAgICAgaWYgKGhhc1JlZnMpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtc2NhbGVNaW4gKiByZWZYUHJvcC5nZXRQaXhlbHMoJ3gnKSwgLXNjYWxlTWluICogcmVmWVByb3AuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB2YXIgc2NhbGVkQ2xpcFggPSBzY2FsZU1pbiAqIGNsaXBYO1xuICAgICAgICB2YXIgc2NhbGVkQ2xpcFkgPSBzY2FsZU1pbiAqIGNsaXBZO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8oc2NhbGVkQ2xpcFgsIHNjYWxlZENsaXBZKTtcbiAgICAgICAgY3R4LmxpbmVUbyh3aWR0aCwgc2NhbGVkQ2xpcFkpO1xuICAgICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKHNjYWxlZENsaXBYLCBoZWlnaHQpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFzUmVmcykge1xuICAgICAgICB2YXIgaXNNZWV0TWluWSA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWTtcbiAgICAgICAgdmFyIGlzU2xpY2VNYXhZID0gbWVldE9yU2xpY2UgPT09ICdzbGljZScgJiYgc2NhbGVNYXggPT09IHNjYWxlWTtcbiAgICAgICAgdmFyIGlzTWVldE1pblggPSBtZWV0T3JTbGljZSA9PT0gJ21lZXQnICYmIHNjYWxlTWluID09PSBzY2FsZVg7XG4gICAgICAgIHZhciBpc1NsaWNlTWF4WCA9IG1lZXRPclNsaWNlID09PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09PSBzY2FsZVg7XG5cbiAgICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNaWQnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC8gMi4wIC0gZmluYWxEZXNpcmVkV2lkdGggLyAyLjAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWlkJykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLyAyLjAgLSBmaW5hbERlc2lyZWRIZWlnaHQgLyAyLjApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduLnN0YXJ0c1dpdGgoJ3hNYXgnKSAmJiAoaXNNZWV0TWluWSB8fCBpc1NsaWNlTWF4WSkpIHtcbiAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoIC0gZmluYWxEZXNpcmVkV2lkdGgsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsaWduLmVuZHNXaXRoKCdZTWF4JykgJiYgKGlzTWVldE1pblggfHwgaXNTbGljZU1heFgpKSB7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBoZWlnaHQgLSBmaW5hbERlc2lyZWRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHNjYWxlXG5cblxuICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgIGNhc2UgYWxpZ24gPT09ICdub25lJzpcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgbWVldE9yU2xpY2UgPT09ICdtZWV0JzpcbiAgICAgICAgICBjdHguc2NhbGUoc2NhbGVNaW4sIHNjYWxlTWluKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnc2xpY2UnOlxuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZU1heCwgc2NhbGVNYXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyB0cmFuc2xhdGVcblxuXG4gICAgICBjdHgudHJhbnNsYXRlKC1taW5YLCAtbWluWSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGVsZW1lbnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgICAgX3JlZjMkZW5hYmxlUmVkcmF3ID0gX3JlZjMuZW5hYmxlUmVkcmF3LFxuICAgICAgICAgIGVuYWJsZVJlZHJhdyA9IF9yZWYzJGVuYWJsZVJlZHJhdyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRlbmFibGVSZWRyYXcsXG4gICAgICAgICAgX3JlZjMkaWdub3JlTW91c2UgPSBfcmVmMy5pZ25vcmVNb3VzZSxcbiAgICAgICAgICBpZ25vcmVNb3VzZSA9IF9yZWYzJGlnbm9yZU1vdXNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlnbm9yZU1vdXNlLFxuICAgICAgICAgIF9yZWYzJGlnbm9yZUFuaW1hdGlvbiA9IF9yZWYzLmlnbm9yZUFuaW1hdGlvbixcbiAgICAgICAgICBpZ25vcmVBbmltYXRpb24gPSBfcmVmMyRpZ25vcmVBbmltYXRpb24gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjMkaWdub3JlQW5pbWF0aW9uLFxuICAgICAgICAgIF9yZWYzJGlnbm9yZURpbWVuc2lvbiA9IF9yZWYzLmlnbm9yZURpbWVuc2lvbnMsXG4gICAgICAgICAgaWdub3JlRGltZW5zaW9ucyA9IF9yZWYzJGlnbm9yZURpbWVuc2lvbiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRpZ25vcmVEaW1lbnNpb24sXG4gICAgICAgICAgX3JlZjMkaWdub3JlQ2xlYXIgPSBfcmVmMy5pZ25vcmVDbGVhcixcbiAgICAgICAgICBpZ25vcmVDbGVhciA9IF9yZWYzJGlnbm9yZUNsZWFyID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlnbm9yZUNsZWFyLFxuICAgICAgICAgIGZvcmNlUmVkcmF3ID0gX3JlZjMuZm9yY2VSZWRyYXcsXG4gICAgICAgICAgc2NhbGVXaWR0aCA9IF9yZWYzLnNjYWxlV2lkdGgsXG4gICAgICAgICAgc2NhbGVIZWlnaHQgPSBfcmVmMy5zY2FsZUhlaWdodCxcbiAgICAgICAgICBvZmZzZXRYID0gX3JlZjMub2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZID0gX3JlZjMub2Zmc2V0WTtcblxuICAgICAgdmFyIEZSQU1FUkFURSA9IHRoaXMuRlJBTUVSQVRFLFxuICAgICAgICAgIG1vdXNlID0gdGhpcy5tb3VzZTtcbiAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gMTAwMCAvIEZSQU1FUkFURTtcbiAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgICB0aGlzLnJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIF90aGlzLnJlc29sdmVSZWFkeSA9IHJlc29sdmU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgIHRoaXMucmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZW5hYmxlUmVkcmF3KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICB2YXIgdGhlbiA9IG5vdztcbiAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgIHZhciB0aWNrID0gZnVuY3Rpb24gdGljaygpIHtcbiAgICAgICAgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgZGVsdGEgPSBub3cgLSB0aGVuO1xuXG4gICAgICAgIGlmIChkZWx0YSA+PSBmcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhlbiA9IG5vdyAtIGRlbHRhICUgZnJhbWVEdXJhdGlvbjtcblxuICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRVcGRhdGUoaWdub3JlQW5pbWF0aW9uLCBmb3JjZVJlZHJhdykpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlcihlbGVtZW50LCBpZ25vcmVEaW1lbnNpb25zLCBpZ25vcmVDbGVhciwgc2NhbGVXaWR0aCwgc2NhbGVIZWlnaHQsIG9mZnNldFgsIG9mZnNldFkpO1xuXG4gICAgICAgICAgICBtb3VzZS5ydW5FdmVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aWNrKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghaWdub3JlTW91c2UpIHtcbiAgICAgICAgbW91c2Uuc3RhcnQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aWNrKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNhbmNlbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vdXNlLnN0b3AoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvdWxkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShpZ25vcmVBbmltYXRpb24sIGZvcmNlUmVkcmF3KSB7XG4gICAgICAvLyBuZWVkIHVwZGF0ZSBmcm9tIGFuaW1hdGlvbnM/XG4gICAgICBpZiAoIWlnbm9yZUFuaW1hdGlvbikge1xuICAgICAgICB2YXIgZnJhbWVEdXJhdGlvbiA9IHRoaXMuZnJhbWVEdXJhdGlvbjtcbiAgICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuYW5pbWF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHNob3VsZFVwZGF0ZSwgYW5pbWF0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi51cGRhdGUoZnJhbWVEdXJhdGlvbikgfHwgc2hvdWxkVXBkYXRlO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIG5lZWQgdXBkYXRlIGZyb20gcmVkcmF3P1xuXG5cbiAgICAgIGlmICh0eXBlb2YgZm9yY2VSZWRyYXcgPT09ICdmdW5jdGlvbicgJiYgZm9yY2VSZWRyYXcoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmlzUmVhZHlMb2NrICYmIHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSAvLyBuZWVkIHVwZGF0ZSBmcm9tIG1vdXNlIGV2ZW50cz9cblxuXG4gICAgICBpZiAodGhpcy5tb3VzZS5oYXNFdmVudHMoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgICAgdmFyIENMSUVOVF9XSURUSCA9IHRoaXMuQ0xJRU5UX1dJRFRILFxuICAgICAgICAgIENMSUVOVF9IRUlHSFQgPSB0aGlzLkNMSUVOVF9IRUlHSFQsXG4gICAgICAgICAgdmlld1BvcnQgPSB0aGlzLnZpZXdQb3J0LFxuICAgICAgICAgIGN0eCA9IHRoaXMuY3R4LFxuICAgICAgICAgIGlzRmlyc3RSZW5kZXIgPSB0aGlzLmlzRmlyc3RSZW5kZXI7XG4gICAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgIHZpZXdQb3J0LmNsZWFyKCk7XG5cbiAgICAgIGlmIChjYW52YXMud2lkdGggJiYgY2FudmFzLmhlaWdodCkge1xuICAgICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KENMSUVOVF9XSURUSCwgQ0xJRU5UX0hFSUdIVCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgIHZhciBoZWlnaHRTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgICBpZiAoIWlnbm9yZURpbWVuc2lvbnMgJiYgKGlzRmlyc3RSZW5kZXIgfHwgdHlwZW9mIHNjYWxlV2lkdGggIT09ICdudW1iZXInICYmIHR5cGVvZiBzY2FsZUhlaWdodCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIC8vIHNldCBjYW52YXMgc2l6ZVxuICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcblxuICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGNhbnZhcy53aWR0aCwgXCJweFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgICAgIGlmIChjYW52YXMuc3R5bGUpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChjYW52YXMuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY1dpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoIHx8IGNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBjSGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodCB8fCBjYW52YXMuaGVpZ2h0O1xuXG4gICAgICBpZiAoaWdub3JlRGltZW5zaW9ucyAmJiB3aWR0aFN0eWxlLmhhc1ZhbHVlKCkgJiYgaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICBjV2lkdGggPSB3aWR0aFN0eWxlLmdldFBpeGVscygneCcpO1xuICAgICAgICBjSGVpZ2h0ID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB9XG5cbiAgICAgIHZpZXdQb3J0LnNldEN1cnJlbnQoY1dpZHRoLCBjSGVpZ2h0KTtcblxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXRYID09PSAnbnVtYmVyJykge1xuICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcsIHRydWUpLnNldFZhbHVlKG9mZnNldFgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9mZnNldFkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd5JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgdmlld0JveCA9IHRvTnVtYmVycyhlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgdmFyIHhSYXRpbyA9IDA7XG4gICAgICAgIHZhciB5UmF0aW8gPSAwO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgX3dpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuXG4gICAgICAgICAgaWYgKF93aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHhSYXRpbyA9IF93aWR0aFN0eWxlLmdldFBpeGVscygneCcpIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2aWV3Qm94WzJdKSkge1xuICAgICAgICAgICAgeFJhdGlvID0gdmlld0JveFsyXSAvIHNjYWxlV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzY2FsZUhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YXIgX2hlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgICAgICBpZiAoX2hlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHlSYXRpbyA9IF9oZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB7XG4gICAgICAgICAgICB5UmF0aW8gPSB2aWV3Qm94WzNdIC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF4UmF0aW8pIHtcbiAgICAgICAgICB4UmF0aW8gPSB5UmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXlSYXRpbykge1xuICAgICAgICAgIHlSYXRpbyA9IHhSYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpLnNldFZhbHVlKHNjYWxlV2lkdGgpO1xuICAgICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoc2NhbGVIZWlnaHQpO1xuICAgICAgICB2YXIgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdHJhbnNmb3JtU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQodHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIFwiIHNjYWxlKFwiKS5jb25jYXQoMS4wIC8geFJhdGlvLCBcIiwgXCIpLmNvbmNhdCgxLjAgLyB5UmF0aW8sIFwiKVwiKSk7XG4gICAgICB9IC8vIGNsZWFyIGFuZCByZW5kZXJcblxuXG4gICAgICBpZiAoIWlnbm9yZUNsZWFyKSB7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY1dpZHRoLCBjSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5yZW5kZXIoY3R4KTtcblxuICAgICAgaWYgKGlzRmlyc3RSZW5kZXIpIHtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjcmVlbjtcbn0oKTtcblNjcmVlbi5kZWZhdWx0V2luZG93ID0gZGVmYXVsdFdpbmRvdztcblNjcmVlbi5kZWZhdWx0RmV0Y2ggPSBkZWZhdWx0RmV0Y2gkMTtcblxudmFyIGRlZmF1bHRGZXRjaCA9IFNjcmVlbi5kZWZhdWx0RmV0Y2g7XG52YXIgRGVmYXVsdERPTVBhcnNlciA9IHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gRE9NUGFyc2VyIDogbnVsbDtcblxudmFyIFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkZmV0Y2ggPSBfcmVmLmZldGNoLFxuICAgICAgICBmZXRjaCA9IF9yZWYkZmV0Y2ggPT09IHZvaWQgMCA/IGRlZmF1bHRGZXRjaCA6IF9yZWYkZmV0Y2gsXG4gICAgICAgIF9yZWYkRE9NUGFyc2VyID0gX3JlZi5ET01QYXJzZXIsXG4gICAgICAgIERPTVBhcnNlciA9IF9yZWYkRE9NUGFyc2VyID09PSB2b2lkIDAgPyBEZWZhdWx0RE9NUGFyc2VyIDogX3JlZiRET01QYXJzZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBhcnNlcik7XG5cbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgdGhpcy5ET01QYXJzZXIgPSBET01QYXJzZXI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBhcnNlciwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9wYXJzZSA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIXJlc291cmNlLnN0YXJ0c1dpdGgoJzwnKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucGFyc2VGcm9tU3RyaW5nKHJlc291cmNlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5sb2FkKHJlc291cmNlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBwYXJzZShfeCkge1xuICAgICAgICByZXR1cm4gX3BhcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VGcm9tU3RyaW5nKHhtbCkge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyB0aGlzLkRPTVBhcnNlcigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAnaW1hZ2Uvc3ZnK3htbCcpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAndGV4dC94bWwnKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrRG9jdW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgdmFyIHBhcnNlckVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJylbMF07XG5cbiAgICAgIGlmIChwYXJzZXJFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VyRXJyb3IudGV4dENvbnRlbnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMih1cmwpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlLCB4bWw7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2godXJsKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgeG1sID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdGhpcy5wYXJzZUZyb21TdHJpbmcoeG1sKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWQoX3gyKSB7XG4gICAgICAgIHJldHVybiBfbG9hZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbG9hZDtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBQYXJzZXI7XG59KCk7XG5cbnZhciBUcmFuc2xhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2xhdGUoXywgcG9pbnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFRyYW5zbGF0ZSk7XG5cbiAgICB0aGlzLnR5cGUgPSAndHJhbnNsYXRlJztcbiAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICB0aGlzLnBvaW50ID0gUG9pbnQucGFyc2UocG9pbnQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUcmFuc2xhdGUsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCkge1xuICAgICAgdmFyIF90aGlzJHBvaW50ID0gdGhpcy5wb2ludCxcbiAgICAgICAgICB4ID0gX3RoaXMkcG9pbnQueCxcbiAgICAgICAgICB5ID0gX3RoaXMkcG9pbnQueTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCB8fCAwLjAsIHkgfHwgMC4wKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmFwcGx5KGN0eCkge1xuICAgICAgdmFyIF90aGlzJHBvaW50MiA9IHRoaXMucG9pbnQsXG4gICAgICAgICAgeCA9IF90aGlzJHBvaW50Mi54LFxuICAgICAgICAgIHkgPSBfdGhpcyRwb2ludDIueTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLTEuMCAqIHggfHwgMC4wLCAtMS4wICogeSB8fCAwLjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICB2YXIgX3RoaXMkcG9pbnQzID0gdGhpcy5wb2ludCxcbiAgICAgICAgICB4ID0gX3RoaXMkcG9pbnQzLngsXG4gICAgICAgICAgeSA9IF90aGlzJHBvaW50My55O1xuICAgICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIHggfHwgMC4wLCB5IHx8IDAuMF0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUcmFuc2xhdGU7XG59KCk7XG5cbnZhciBSb3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSb3RhdGUoZG9jdW1lbnQsIHJvdGF0ZSwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBSb3RhdGUpO1xuXG4gICAgdGhpcy50eXBlID0gJ3JvdGF0ZSc7XG4gICAgdGhpcy5hbmdsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHRoaXMuY3ggPSAwO1xuICAgIHRoaXMuY3kgPSAwO1xuICAgIHZhciBudW1iZXJzID0gdG9OdW1iZXJzKHJvdGF0ZSk7XG4gICAgdGhpcy5hbmdsZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2FuZ2xlJywgbnVtYmVyc1swXSk7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgICB0aGlzLmN4ID0gbnVtYmVyc1sxXSB8fCAwO1xuICAgIHRoaXMuY3kgPSBudW1iZXJzWzJdIHx8IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFJvdGF0ZSwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgY3ggPSB0aGlzLmN4LFxuICAgICAgICAgIGN5ID0gdGhpcy5jeSxcbiAgICAgICAgICBvcmlnaW5YID0gdGhpcy5vcmlnaW5YLFxuICAgICAgICAgIG9yaWdpblkgPSB0aGlzLm9yaWdpblksXG4gICAgICAgICAgYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgICAgdmFyIHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgY3R4LnJvdGF0ZShhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5hcHBseShjdHgpIHtcbiAgICAgIHZhciBjeCA9IHRoaXMuY3gsXG4gICAgICAgICAgY3kgPSB0aGlzLmN5LFxuICAgICAgICAgIG9yaWdpblggPSB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSA9IHRoaXMub3JpZ2luWSxcbiAgICAgICAgICBhbmdsZSA9IHRoaXMuYW5nbGU7XG4gICAgICB2YXIgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBjeSArIG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgICBjdHgucm90YXRlKC0xLjAgKiBhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBjeCA9IHRoaXMuY3gsXG4gICAgICAgICAgY3kgPSB0aGlzLmN5LFxuICAgICAgICAgIGFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICAgIHZhciByYWQgPSBhbmdsZS5nZXRSYWRpYW5zKCk7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgY3ggfHwgMC4wLCBjeSB8fCAwLjAgLy8gdGhpcy5wLnlcbiAgICAgIF0pO1xuICAgICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKHJhZCksIE1hdGguc2luKHJhZCksIC1NYXRoLnNpbihyYWQpLCBNYXRoLmNvcyhyYWQpLCAwLCAwXSk7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbMSwgMCwgMCwgMSwgLWN4IHx8IDAuMCwgLWN5IHx8IDAuMCAvLyAtdGhpcy5wLnlcbiAgICAgIF0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSb3RhdGU7XG59KCk7XG5cbnZhciBTY2FsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjYWxlKF8sIHNjYWxlLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFNjYWxlKTtcblxuICAgIHRoaXMudHlwZSA9ICdzY2FsZSc7XG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5YID0gbnVsbDtcbiAgICB0aGlzLm9yaWdpblkgPSBudWxsO1xuICAgIHZhciBzY2FsZVNpemUgPSBQb2ludC5wYXJzZVNjYWxlKHNjYWxlKTsgLy8gV29ya2Fyb3VuZCBmb3Igbm9kZS1jYW52YXNcblxuICAgIGlmIChzY2FsZVNpemUueCA9PT0gMCB8fCBzY2FsZVNpemUueSA9PT0gMCkge1xuICAgICAgc2NhbGVTaXplLnggPSBQU0VVRE9fWkVSTztcbiAgICAgIHNjYWxlU2l6ZS55ID0gUFNFVURPX1pFUk87XG4gICAgfVxuXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlU2l6ZTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTY2FsZSwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgICAgICAgIHggPSBfdGhpcyRzY2FsZS54LFxuICAgICAgICAgIHkgPSBfdGhpcyRzY2FsZS55LFxuICAgICAgICAgIG9yaWdpblggPSB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSA9IHRoaXMub3JpZ2luWTtcbiAgICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgY3R4LnNjYWxlKHgsIHkgfHwgeCk7XG4gICAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5hcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmFwcGx5KGN0eCkge1xuICAgICAgdmFyIF90aGlzJHNjYWxlMiA9IHRoaXMuc2NhbGUsXG4gICAgICAgICAgeCA9IF90aGlzJHNjYWxlMi54LFxuICAgICAgICAgIHkgPSBfdGhpcyRzY2FsZTIueSxcbiAgICAgICAgICBvcmlnaW5YID0gdGhpcy5vcmlnaW5YLFxuICAgICAgICAgIG9yaWdpblkgPSB0aGlzLm9yaWdpblk7XG4gICAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAgIGN0eC5zY2FsZSgxLjAgLyB4LCAxLjAgLyB5IHx8IHgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtdHgsIC10eSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VG9Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseVRvUG9pbnQocG9pbnQpIHtcbiAgICAgIHZhciBfdGhpcyRzY2FsZTMgPSB0aGlzLnNjYWxlLFxuICAgICAgICAgIHggPSBfdGhpcyRzY2FsZTMueCxcbiAgICAgICAgICB5ID0gX3RoaXMkc2NhbGUzLnk7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybShbeCB8fCAwLjAsIDAsIDAsIHkgfHwgMC4wLCAwLCAwXSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjYWxlO1xufSgpO1xuXG52YXIgTWF0cml4ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWF0cml4KF8sIG1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBNYXRyaXgpO1xuXG4gICAgdGhpcy50eXBlID0gJ21hdHJpeCc7XG4gICAgdGhpcy5tYXRyaXggPSBbXTtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdGhpcy5tYXRyaXggPSB0b051bWJlcnMobWF0cml4KTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShNYXRyaXgsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCkge1xuICAgICAgdmFyIG9yaWdpblggPSB0aGlzLm9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSA9IHRoaXMub3JpZ2luWSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgb3JpZ2luWCA9IHRoaXMub3JpZ2luWCxcbiAgICAgICAgICBvcmlnaW5ZID0gdGhpcy5vcmlnaW5ZLFxuICAgICAgICAgIG1hdHJpeCA9IHRoaXMubWF0cml4O1xuICAgICAgdmFyIGEgPSBtYXRyaXhbMF07XG4gICAgICB2YXIgYiA9IG1hdHJpeFsyXTtcbiAgICAgIHZhciBjID0gbWF0cml4WzRdO1xuICAgICAgdmFyIGQgPSBtYXRyaXhbMV07XG4gICAgICB2YXIgZSA9IG1hdHJpeFszXTtcbiAgICAgIHZhciBmID0gbWF0cml4WzVdO1xuICAgICAgdmFyIGcgPSAwLjA7XG4gICAgICB2YXIgaCA9IDAuMDtcbiAgICAgIHZhciBpID0gMS4wO1xuICAgICAgdmFyIGRldCA9IDEgLyAoYSAqIChlICogaSAtIGYgKiBoKSAtIGIgKiAoZCAqIGkgLSBmICogZykgKyBjICogKGQgKiBoIC0gZSAqIGcpKTtcbiAgICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICAgY3R4LnRyYW5zZm9ybShkZXQgKiAoZSAqIGkgLSBmICogaCksIGRldCAqIChmICogZyAtIGQgKiBpKSwgZGV0ICogKGMgKiBoIC0gYiAqIGkpLCBkZXQgKiAoYSAqIGkgLSBjICogZyksIGRldCAqIChiICogZiAtIGMgKiBlKSwgZGV0ICogKGMgKiBkIC0gYSAqIGYpKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICBwb2ludC5hcHBseVRyYW5zZm9ybSh0aGlzLm1hdHJpeCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hdHJpeDtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJE0oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkTSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkTSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTa2V3ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTWF0cml4KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU2tldywgX01hdHJpeCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRNKFNrZXcpO1xuXG4gIGZ1bmN0aW9uIFNrZXcoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU2tldyk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIF90aGlzLnR5cGUgPSAnc2tldyc7XG4gICAgX3RoaXMuYW5nbGUgPSBudWxsO1xuICAgIF90aGlzLmFuZ2xlID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnYW5nbGUnLCBza2V3KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2tldztcbn0oTWF0cml4KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEwoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkTCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkTCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTa2V3WCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NrZXcpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTa2V3WCwgX1NrZXcpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkTChTa2V3WCk7XG5cbiAgZnVuY3Rpb24gU2tld1goZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU2tld1gpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICBfdGhpcy50eXBlID0gJ3NrZXdYJztcbiAgICBfdGhpcy5tYXRyaXggPSBbMSwgMCwgTWF0aC50YW4oX3RoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwgMSwgMCwgMF07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNrZXdYO1xufShTa2V3KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEsoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTa2V3WSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NrZXcpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTa2V3WSwgX1NrZXcpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkSyhTa2V3WSk7XG5cbiAgZnVuY3Rpb24gU2tld1koZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU2tld1kpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICBfdGhpcy50eXBlID0gJ3NrZXdZJztcbiAgICBfdGhpcy5tYXRyaXggPSBbMSwgTWF0aC50YW4oX3RoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwgMCwgMSwgMCwgMF07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFNrZXdZO1xufShTa2V3KTtcblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKHRyYW5zZm9ybSkge1xuICByZXR1cm4gY29tcHJlc3NTcGFjZXModHJhbnNmb3JtKS50cmltKCkucmVwbGFjZSgvXFwpKFthLXpBLVpdKS9nLCAnKSAkMScpLnJlcGxhY2UoL1xcKShcXHM/LFxccz8pL2csICcpICcpLnNwbGl0KC9cXHMoPz1bYS16XSkvKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIHZhciBfdHJhbnNmb3JtJHNwbGl0ID0gdHJhbnNmb3JtLnNwbGl0KCcoJyksXG4gICAgICBfdHJhbnNmb3JtJHNwbGl0MiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdHJhbnNmb3JtJHNwbGl0LCAyKSxcbiAgICAgIHR5cGUgPSBfdHJhbnNmb3JtJHNwbGl0MlswXSxcbiAgICAgIHZhbHVlID0gX3RyYW5zZm9ybSRzcGxpdDJbMV07XG5cbiAgcmV0dXJuIFt0eXBlLnRyaW0oKSwgdmFsdWUudHJpbSgpLnJlcGxhY2UoJyknLCAnJyldO1xufVxuXG52YXIgVHJhbnNmb3JtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNmb3JtKGRvY3VtZW50LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFRyYW5zZm9ybSk7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgdmFyIGRhdGEgPSBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtKTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wYXJzZVRyYW5zZm9ybSA9IHBhcnNlVHJhbnNmb3JtKHRyYW5zZm9ybSksXG4gICAgICAgICAgX3BhcnNlVHJhbnNmb3JtMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfcGFyc2VUcmFuc2Zvcm0sIDIpLFxuICAgICAgICAgIHR5cGUgPSBfcGFyc2VUcmFuc2Zvcm0yWzBdLFxuICAgICAgICAgIHZhbHVlID0gX3BhcnNlVHJhbnNmb3JtMlsxXTtcblxuICAgICAgdmFyIFRyYW5zZm9ybVR5cGUgPSBUcmFuc2Zvcm0udHJhbnNmb3JtVHlwZXNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgVHJhbnNmb3JtVHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX3RoaXMudHJhbnNmb3Jtcy5wdXNoKG5ldyBUcmFuc2Zvcm1UeXBlKF90aGlzLmRvY3VtZW50LCB2YWx1ZSwgdHJhbnNmb3JtT3JpZ2luKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRyYW5zZm9ybSwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IHRoaXMudHJhbnNmb3JtcztcbiAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0cmFuc2Zvcm1zW2ldLmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5hcHBseShjdHgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gdGhpcy50cmFuc2Zvcm1zO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdHJhbnNmb3Jtc1tpXS51bmFwcGx5KGN0eCk7XG4gICAgICB9XG4gICAgfSAvLyBUT0RPOiBhcHBseVRvUG9pbnQgdW51c2VkIC4uLiByZW1vdmU/XG5cbiAgfSwge1xuICAgIGtleTogXCJhcHBseVRvUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgICB2YXIgdHJhbnNmb3JtcyA9IHRoaXMudHJhbnNmb3JtcztcbiAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0cmFuc2Zvcm1zW2ldLmFwcGx5VG9Qb2ludChwb2ludCk7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbUVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGVsZW1lbnQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKTtcblxuICAgICAgdmFyIF9lbGVtZW50JGdldFN0eWxlJHNwbCA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBmYWxzZSwgdHJ1ZSkuc3BsaXQoKSxcbiAgICAgICAgICBfZWxlbWVudCRnZXRTdHlsZSRzcGwyID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9lbGVtZW50JGdldFN0eWxlJHNwbCwgMiksXG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5ID0gX2VsZW1lbnQkZ2V0U3R5bGUkc3BsMlswXSxcbiAgICAgICAgICBfZWxlbWVudCRnZXRTdHlsZSRzcGwzID0gX2VsZW1lbnQkZ2V0U3R5bGUkc3BsMlsxXSxcbiAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkgPSBfZWxlbWVudCRnZXRTdHlsZSRzcGwzID09PSB2b2lkIDAgPyB0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHkgOiBfZWxlbWVudCRnZXRTdHlsZSRzcGwzO1xuXG4gICAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gW3RyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSwgdHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5XTtcblxuICAgICAgaWYgKHRyYW5zZm9ybVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0oZG9jdW1lbnQsIHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVHJhbnNmb3JtO1xufSgpO1xuVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzID0ge1xuICB0cmFuc2xhdGU6IFRyYW5zbGF0ZSxcbiAgcm90YXRlOiBSb3RhdGUsXG4gIHNjYWxlOiBTY2FsZSxcbiAgbWF0cml4OiBNYXRyaXgsXG4gIHNrZXdYOiBTa2V3WCxcbiAgc2tld1k6IFNrZXdZXG59O1xuXG52YXIgRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNhcHR1cmVUZXh0Tm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBFbGVtZW50KTtcblxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IGNhcHR1cmVUZXh0Tm9kZXM7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbmltYXRpb25Gcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb3plblZhbHVlID0gJyc7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBFTEVNRU5UX05PREVcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGFkZCBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBub2RlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgIF90aGlzLmF0dHJpYnV0ZXNbbm9kZU5hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBub2RlTmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTsgLy8gYWRkIGlubGluZSBzdHlsZXNcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuZ2V0U3RyaW5nKCkuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8udHJpbSgpO1xuICAgICAgfSk7XG4gICAgICBzdHlsZXMuZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3R5bGUkc3BsaXQkbWFwID0gc3R5bGUuc3BsaXQoJzonKS5tYXAoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICByZXR1cm4gXy50cmltKCk7XG4gICAgICAgIH0pLFxuICAgICAgICAgICAgX3N0eWxlJHNwbGl0JG1hcDIgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3N0eWxlJHNwbGl0JG1hcCwgMiksXG4gICAgICAgICAgICBuYW1lID0gX3N0eWxlJHNwbGl0JG1hcDJbMF0sXG4gICAgICAgICAgICB2YWx1ZSA9IF9zdHlsZSRzcGxpdCRtYXAyWzFdO1xuXG4gICAgICAgIF90aGlzLnN0eWxlc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmluaXRpb25zID0gZG9jdW1lbnQuZGVmaW5pdGlvbnM7XG4gICAgdmFyIGlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lkJyk7IC8vIGFkZCBpZFxuXG4gICAgaWYgKGlkLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbnNbaWQuZ2V0U3RyaW5nKCldKSB7XG4gICAgICAgIGRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICBfdGhpcy5hZGRDaGlsZChjaGlsZE5vZGUpOyAvLyBFTEVNRU5UX05PREVcblxuICAgICAgfSBlbHNlIGlmIChjYXB0dXJlVGV4dE5vZGVzICYmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMgfHwgY2hpbGROb2RlLm5vZGVUeXBlID09PSA0KSkge1xuICAgICAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZE5vZGUpO1xuXG4gICAgICAgIGlmICh0ZXh0Tm9kZS5nZXRUZXh0KCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIF90aGlzLmFkZENoaWxkKHRleHROb2RlKTsgLy8gVEVYVF9OT0RFXG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICAgIHZhciBjcmVhdGVJZk5vdEV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKCFhdHRyICYmIGNyZWF0ZUlmTm90RXhpc3RzKSB7XG4gICAgICAgIHZhciBfYXR0ciA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG5cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gX2F0dHI7XG4gICAgICAgIHJldHVybiBfYXR0cjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF0dHIgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEhyZWZBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SHJlZkF0dHJpYnV0ZSgpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2hyZWYnIHx8IGtleS5lbmRzV2l0aCgnOmhyZWYnKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0eWxlKG5hbWUpIHtcbiAgICAgIHZhciBjcmVhdGVJZk5vdEV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgc2tpcEFuY2VzdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlc1tuYW1lXTtcblxuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcblxuICAgICAgaWYgKGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gdm9pZCAwICYmIGF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IGF0dHI7IC8vIG1vdmUgdXAgdG8gbWUgdG8gY2FjaGVcblxuICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFza2lwQW5jZXN0b3JzKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgdmFyIHBhcmVudFN0eWxlID0gcGFyZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICAgICAgaWYgKHBhcmVudFN0eWxlICE9PSBudWxsICYmIHBhcmVudFN0eWxlICE9PSB2b2lkIDAgJiYgcGFyZW50U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFN0eWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgICAgdmFyIF9zdHlsZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBfc3R5bGU7XG4gICAgICAgIHJldHVybiBfc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZSB8fCBQcm9wZXJ0eS5lbXB0eSh0aGlzLmRvY3VtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjdHgpIHtcbiAgICAgIC8vIGRvbid0IHJlbmRlciBkaXNwbGF5PW5vbmVcbiAgICAgIC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxuICAgICAgaWYgKHRoaXMuZ2V0U3R5bGUoJ2Rpc3BsYXknKS5nZXRTdHJpbmcoKSA9PT0gJ25vbmUnIHx8IHRoaXMuZ2V0U3R5bGUoJ3Zpc2liaWxpdHknKS5nZXRTdHJpbmcoKSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBpZiAodGhpcy5nZXRTdHlsZSgnbWFzaycpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gbWFza1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuZ2V0U3R5bGUoJ21hc2snKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpO1xuICAgICAgICAgIG1hc2suYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXRWYWx1ZSgnbm9uZScpICE9PSAnbm9uZScpIHtcbiAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIHZhciBmaWx0ZXIgPSB0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7XG4gICAgICAgICAgZmlsdGVyLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dChjdHgpO1xuICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7XG4gICAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGV4dChfKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5RWZmZWN0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUVmZmVjdHMoY3R4KSB7XG4gICAgICAvLyB0cmFuc2Zvcm1cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQodGhpcy5kb2N1bWVudCwgdGhpcyk7XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICB9IC8vIGNsaXBcblxuXG4gICAgICB2YXIgY2xpcFBhdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdjbGlwLXBhdGgnLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChjbGlwUGF0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBjbGlwID0gY2xpcFBhdGhTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGlmIChjbGlwKSB7XG4gICAgICAgICAgY2xpcC5hcHBseShjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckNvbnRleHQoXykgey8vIE5PIFJFTkRFUlxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2hpbGQoY2hpbGROb2RlKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ID8gY2hpbGROb2RlIDogdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xuXG4gICAgICBpZiAoIUVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcy5pbmNsdWRlcyhjaGlsZC50eXBlKSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXRjaGVzU2VsZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlLm1hdGNoZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZUNsYXNzZXMgPSAoX25vZGUkZ2V0QXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUpID09PSBudWxsIHx8IF9ub2RlJGdldEF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlLmNhbGwobm9kZSwgJ2NsYXNzJyk7XG5cbiAgICAgIGlmICghc3R5bGVDbGFzc2VzIHx8IHN0eWxlQ2xhc3NlcyA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3R5bGVDbGFzc2VzLnNwbGl0KCcgJykuc29tZShmdW5jdGlvbiAoc3R5bGVDbGFzcykge1xuICAgICAgICByZXR1cm4gXCIuXCIuY29uY2F0KHN0eWxlQ2xhc3MpID09PSBzZWxlY3RvcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKSB7XG4gICAgICB2YXIgX3RoaXMkZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIHN0eWxlcyA9IF90aGlzJGRvY3VtZW50LnN0eWxlcyxcbiAgICAgICAgICBzdHlsZXNTcGVjaWZpY2l0eSA9IF90aGlzJGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5O1xuXG4gICAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKCFzZWxlY3Rvci5zdGFydHNXaXRoKCdAJykgJiYgdGhpcy5tYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpKSB7XG4gICAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVzW3NlbGVjdG9yXTtcbiAgICAgICAgICB2YXIgc3BlY2lmaWNpdHkgPSBzdHlsZXNTcGVjaWZpY2l0eVtzZWxlY3Rvcl07XG5cbiAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdTcGVjaWZpY2l0eSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1NwZWNpZmljaXR5ID0gJzAwMCc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoc3BlY2lmaWNpdHkgPj0gZXhpc3RpbmdTcGVjaWZpY2l0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gc3R5bGVbbmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXSA9IHNwZWNpZmljaXR5O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTdHlsZXMoZWxlbWVudCwgaWdub3JlU3R5bGVzKSB7XG4gICAgICB2YXIgdG9SZXN0b3JlID0gaWdub3JlU3R5bGVzLnJlZHVjZShmdW5jdGlvbiAodG9SZXN0b3JlLCBuYW1lKSB7XG4gICAgICAgIHZhciBzdHlsZVByb3AgPSBlbGVtZW50LmdldFN0eWxlKG5hbWUpO1xuXG4gICAgICAgIGlmICghc3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdG9SZXN0b3JlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgICBzdHlsZVByb3Auc2V0VmFsdWUoJycpO1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odG9SZXN0b3JlKSwgW1tuYW1lLCB2YWx1ZV1dKTtcbiAgICAgIH0sIFtdKTtcbiAgICAgIHJldHVybiB0b1Jlc3RvcmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc3RvcmVTdHlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdG9yZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICAgIHN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfcmVmLCAyKSxcbiAgICAgICAgICAgIG5hbWUgPSBfcmVmMlswXSxcbiAgICAgICAgICAgIHZhbHVlID0gX3JlZjJbMV07XG5cbiAgICAgICAgZWxlbWVudC5nZXRTdHlsZShuYW1lLCB0cnVlKS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNGaXJzdENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRmlyc3RDaGlsZCgpIHtcbiAgICAgIHZhciBfdGhpcyRwYXJlbnQ7XG5cbiAgICAgIHJldHVybiAoKF90aGlzJHBhcmVudCA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpKSA9PT0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRWxlbWVudDtcbn0oKTtcbkVsZW1lbnQuaWdub3JlQ2hpbGRUeXBlcyA9IFsndGl0bGUnXTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEooRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBVbmtub3duRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShVbmtub3duRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkSihVbmtub3duRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVW5rbm93bkVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFVua25vd25FbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFVua25vd25FbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gd3JhcEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICB2YXIgdHJpbW1lZCA9IGZvbnRGYW1pbHkudHJpbSgpO1xuICByZXR1cm4gL14oJ3xcIikvLnRlc3QodHJpbW1lZCkgPyB0cmltbWVkIDogXCJcXFwiXCIuY29uY2F0KHRyaW1tZWQsIFwiXFxcIlwiKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnID8gZm9udEZhbWlseSA6IGZvbnRGYW1pbHkudHJpbSgpLnNwbGl0KCcsJykubWFwKHdyYXBGb250RmFtaWx5KS5qb2luKCcsJyk7XG59XG4vKipcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtc3R5bGVcclxuICogQHBhcmFtIGZvbnRTdHlsZVxyXG4gKiBAcmV0dXJucyBDU1MgZm9udCBzdHlsZS5cclxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRTdHlsZShmb250U3R5bGUpIHtcbiAgaWYgKCFmb250U3R5bGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGFyZ2V0Rm9udFN0eWxlID0gZm9udFN0eWxlLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAodGFyZ2V0Rm9udFN0eWxlKSB7XG4gICAgY2FzZSAnbm9ybWFsJzpcbiAgICBjYXNlICdpdGFsaWMnOlxuICAgIGNhc2UgJ29ibGlxdWUnOlxuICAgIGNhc2UgJ2luaGVyaXQnOlxuICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgIHJldHVybiB0YXJnZXRGb250U3R5bGU7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eb2JsaXF1ZVxccysoLXwpXFxkK2RlZyQvLnRlc3QodGFyZ2V0Rm9udFN0eWxlKSkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC13ZWlnaHRcclxuICogQHBhcmFtIGZvbnRXZWlnaHRcclxuICogQHJldHVybnMgQ1NTIGZvbnQgd2VpZ2h0LlxyXG4gKi9cblxuXG5mdW5jdGlvbiBwcmVwYXJlRm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gIGlmICghZm9udFdlaWdodCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0YXJnZXRGb250V2VpZ2h0ID0gZm9udFdlaWdodC50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRhcmdldEZvbnRXZWlnaHQpIHtcbiAgICBjYXNlICdub3JtYWwnOlxuICAgIGNhc2UgJ2JvbGQnOlxuICAgIGNhc2UgJ2xpZ2h0ZXInOlxuICAgIGNhc2UgJ2JvbGRlcic6XG4gICAgY2FzZSAnaW5oZXJpdCc6XG4gICAgY2FzZSAnaW5pdGlhbCc6XG4gICAgY2FzZSAndW5zZXQnOlxuICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKC9eW1xcZC5dKyQvLnRlc3QodGFyZ2V0Rm9udFdlaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRXZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG52YXIgRm9udCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbnQoZm9udFN0eWxlLCBmb250VmFyaWFudCwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHksIGluaGVyaXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZvbnQpO1xuXG4gICAgdmFyIGluaGVyaXRGb250ID0gaW5oZXJpdCA/IHR5cGVvZiBpbmhlcml0ID09PSAnc3RyaW5nJyA/IEZvbnQucGFyc2UoaW5oZXJpdCkgOiBpbmhlcml0IDoge307XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCBpbmhlcml0Rm9udC5mb250RmFtaWx5O1xuICAgIHRoaXMuZm9udFNpemUgPSBmb250U2l6ZSB8fCBpbmhlcml0Rm9udC5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8fCBpbmhlcml0Rm9udC5mb250U3R5bGU7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gZm9udFdlaWdodCB8fCBpbmhlcml0Rm9udC5mb250V2VpZ2h0O1xuICAgIHRoaXMuZm9udFZhcmlhbnQgPSBmb250VmFyaWFudCB8fCBpbmhlcml0Rm9udC5mb250VmFyaWFudDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRm9udCwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gW3ByZXBhcmVGb250U3R5bGUodGhpcy5mb250U3R5bGUpLCB0aGlzLmZvbnRWYXJpYW50LCBwcmVwYXJlRm9udFdlaWdodCh0aGlzLmZvbnRXZWlnaHQpLCB0aGlzLmZvbnRTaXplLCAvLyBXcmFwIGZvbnRGYW1pbHkgb25seSBvbiBub2RlanMgYW5kIG9ubHkgZm9yIGNhbnZhcy5jdHhcbiAgICAgIHByZXBhcmVGb250RmFtaWx5KHRoaXMuZm9udEZhbWlseSldLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICB2YXIgZm9udCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgICB2YXIgaW5oZXJpdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGZvbnRTdHlsZSA9ICcnO1xuICAgICAgdmFyIGZvbnRWYXJpYW50ID0gJyc7XG4gICAgICB2YXIgZm9udFdlaWdodCA9ICcnO1xuICAgICAgdmFyIGZvbnRTaXplID0gJyc7XG4gICAgICB2YXIgZm9udEZhbWlseSA9ICcnO1xuICAgICAgdmFyIHBhcnRzID0gY29tcHJlc3NTcGFjZXMoZm9udCkudHJpbSgpLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgc2V0ID0ge1xuICAgICAgICBmb250U2l6ZTogZmFsc2UsXG4gICAgICAgIGZvbnRTdHlsZTogZmFsc2UsXG4gICAgICAgIGZvbnRXZWlnaHQ6IGZhbHNlLFxuICAgICAgICBmb250VmFyaWFudDogZmFsc2VcbiAgICAgIH07XG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgIXNldC5mb250U3R5bGUgJiYgRm9udC5zdHlsZXMuaW5jbHVkZXMocGFydCk6XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgIGZvbnRTdHlsZSA9IHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICFzZXQuZm9udFZhcmlhbnQgJiYgRm9udC52YXJpYW50cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgZm9udFZhcmlhbnQgPSBwYXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5mb250VmFyaWFudCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgIXNldC5mb250V2VpZ2h0ICYmIEZvbnQud2VpZ2h0cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgICAgZm9udFdlaWdodCA9IHBhcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5mb250V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAhc2V0LmZvbnRTaXplOlxuICAgICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgICB2YXIgX3BhcnQkc3BsaXQgPSBwYXJ0LnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgICAgdmFyIF9wYXJ0JHNwbGl0MiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfcGFydCRzcGxpdCwgMSk7XG5cbiAgICAgICAgICAgICAgZm9udFNpemUgPSBfcGFydCRzcGxpdDJbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgICAgc2V0LmZvbnRWYXJpYW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5mb250V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldC5mb250U2l6ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICAgIGZvbnRGYW1pbHkgKz0gcGFydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgRm9udChmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnQ7XG59KCk7XG5Gb250LnN0eWxlcyA9ICdub3JtYWx8aXRhbGljfG9ibGlxdWV8aW5oZXJpdCc7XG5Gb250LnZhcmlhbnRzID0gJ25vcm1hbHxzbWFsbC1jYXBzfGluaGVyaXQnO1xuRm9udC53ZWlnaHRzID0gJ25vcm1hbHxib2xkfGJvbGRlcnxsaWdodGVyfDEwMHwyMDB8MzAwfDQwMHw1MDB8NjAwfDcwMHw4MDB8OTAwfGluaGVyaXQnO1xuXG52YXIgQm91bmRpbmdCb3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3VuZGluZ0JveCgpIHtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHkxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeTIgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IE51bWJlci5OYU47XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEJvdW5kaW5nQm94KTtcblxuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcbiAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShCb3VuZGluZ0JveCwgW3tcbiAgICBrZXk6IFwiYWRkUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUG9pbnQoeCwgeSkge1xuICAgICAgaWYgKHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcbiAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkWFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRYKHgpIHtcbiAgICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkWSh5KSB7XG4gICAgICB0aGlzLmFkZFBvaW50KG51bGwsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRCb3VuZGluZ0JveChib3VuZGluZ0JveCkge1xuICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4MSA9IGJvdW5kaW5nQm94LngxLFxuICAgICAgICAgIHkxID0gYm91bmRpbmdCb3gueTEsXG4gICAgICAgICAgeDIgPSBib3VuZGluZ0JveC54MixcbiAgICAgICAgICB5MiA9IGJvdW5kaW5nQm94LnkyO1xuICAgICAgdGhpcy5hZGRQb2ludCh4MSwgeTEpO1xuICAgICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdW1DdWJpY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHAwICsgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiBwMSArIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiBwMiArIE1hdGgucG93KHQsIDMpICogcDM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlemllckN1cnZlQWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJlemllckN1cnZlQWRkKGZvclgsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgICB2YXIgYiA9IDYgKiBwMCAtIDEyICogcDEgKyA2ICogcDI7XG4gICAgICB2YXIgYSA9IC0zICogcDAgKyA5ICogcDEgLSA5ICogcDIgKyAzICogcDM7XG4gICAgICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcblxuICAgICAgaWYgKGEgPT09IDApIHtcbiAgICAgICAgaWYgKGIgPT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IC1jIC8gYjtcblxuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgICAgdGhpcy5hZGRYKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiMmFjID0gTWF0aC5wb3coYiwgMikgLSA0ICogYyAqIGE7XG5cbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICBpZiAoZm9yWCkge1xuICAgICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBmcm9tIGh0dHA6Ly9ibG9nLmhhY2tlcnMtY2FmZS5uZXQvMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQmV6aWVyQ3VydmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQmV6aWVyQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICAgIHRoaXMuYWRkUG9pbnQocDB4LCBwMHkpO1xuICAgICAgdGhpcy5hZGRQb2ludChwM3gsIHAzeSk7XG4gICAgICB0aGlzLmJlemllckN1cnZlQWRkKHRydWUsIHAweCwgcDF4LCBwMngsIHAzeCk7XG4gICAgICB0aGlzLmJlemllckN1cnZlQWRkKGZhbHNlLCBwMHksIHAxeSwgcDJ5LCBwM3kpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRRdWFkcmF0aWNDdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRRdWFkcmF0aWNDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gICAgICB2YXIgY3AxeCA9IHAweCArIDIgLyAzICogKHAxeCAtIHAweCk7IC8vIENQMSA9IFFQMCArIDIvMyAqKFFQMS1RUDApXG5cbiAgICAgIHZhciBjcDF5ID0gcDB5ICsgMiAvIDMgKiAocDF5IC0gcDB5KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcblxuICAgICAgdmFyIGNwMnggPSBjcDF4ICsgMSAvIDMgKiAocDJ4IC0gcDB4KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAocDJ5IC0gcDB5KTsgLy8gQ1AyID0gQ1AxICsgMS8zICooUVAyLVFQMClcblxuICAgICAgdGhpcy5hZGRCZXppZXJDdXJ2ZShwMHgsIHAweSwgY3AxeCwgY3AyeCwgY3AxeSwgY3AyeSwgcDJ4LCBwMnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1BvaW50SW5Cb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQb2ludEluQm94KHgsIHkpIHtcbiAgICAgIHZhciB4MSA9IHRoaXMueDEsXG4gICAgICAgICAgeTEgPSB0aGlzLnkxLFxuICAgICAgICAgIHgyID0gdGhpcy54MixcbiAgICAgICAgICB5MiA9IHRoaXMueTI7XG4gICAgICByZXR1cm4geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwieFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnkxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ3aWR0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWlnaHRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQm91bmRpbmdCb3g7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRJKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUGF0aFBhcnNlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NWR1BhdGhEYXRhKSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUGF0aFBhcnNlciwgX1NWR1BhdGhEYXRhKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJEkoUGF0aFBhcnNlcik7XG5cbiAgZnVuY3Rpb24gUGF0aFBhcnNlcihwYXRoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBQYXRoUGFyc2VyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGF0aCAvLyBGaXggc3BhY2VzIGFmdGVyIHNpZ25zLlxuICAgIC5yZXBsYWNlKC8oWytcXC0uXSlcXHMrL2dtLCAnJDEnKSAvLyBSZW1vdmUgaW52YWxpZCBwYXJ0LlxuICAgIC5yZXBsYWNlKC9bXk1tWnpMbEhoVnZDY1NzUXFUdEFhZVxcZFxccy4sKy1dLiovZywgJycpKTtcbiAgICBfdGhpcy5jb250cm9sID0gbnVsbDtcbiAgICBfdGhpcy5zdGFydCA9IG51bGw7XG4gICAgX3RoaXMuY3VycmVudCA9IG51bGw7XG4gICAgX3RoaXMuY29tbWFuZCA9IG51bGw7XG4gICAgX3RoaXMuY29tbWFuZHMgPSBfdGhpcy5jb21tYW5kcztcbiAgICBfdGhpcy5pID0gLTE7XG4gICAgX3RoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICBfdGhpcy5wb2ludHMgPSBbXTtcbiAgICBfdGhpcy5hbmdsZXMgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBhdGhQYXJzZXIsIFt7XG4gICAga2V5OiBcInJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5pID0gLTE7XG4gICAgICB0aGlzLmNvbW1hbmQgPSBudWxsO1xuICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSBudWxsO1xuICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgIHRoaXMuY29udHJvbCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0VuZCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy5pLFxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICAgIHJldHVybiBpID49IGNvbW1hbmRzLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBjb21tYW5kID0gdGhpcy5jb21tYW5kc1srK3RoaXMuaV07XG4gICAgICB0aGlzLnByZXZpb3VzQ29tbWFuZCA9IHRoaXMuY29tbWFuZDtcbiAgICAgIHRoaXMuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICByZXR1cm4gY29tbWFuZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQoKSB7XG4gICAgICB2YXIgeFByb3AgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd4JztcbiAgICAgIHZhciB5UHJvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3knO1xuICAgICAgdmFyIHBvaW50ID0gbmV3IFBvaW50KHRoaXMuY29tbWFuZFt4UHJvcF0sIHRoaXMuY29tbWFuZFt5UHJvcF0pO1xuICAgICAgcmV0dXJuIHRoaXMubWFrZUFic29sdXRlKHBvaW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXNDb250cm9sUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXNDb250cm9sUG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgICB0aGlzLmNvbnRyb2wgPSBwb2ludDtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXNDdXJyZW50UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXNDdXJyZW50UG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldFBvaW50KHhQcm9wLCB5UHJvcCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBwb2ludDtcbiAgICAgIHJldHVybiBwb2ludDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpIHtcbiAgICAgIHZhciBwcmV2aW91c0NvbW1hbmQgPSB0aGlzLnByZXZpb3VzQ29tbWFuZC50eXBlO1xuXG4gICAgICBpZiAocHJldmlvdXNDb21tYW5kICE9PSBzdmdQYXRoZGF0YS5TVkdQYXRoRGF0YS5DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IHN2Z1BhdGhkYXRhLlNWR1BhdGhEYXRhLlNNT09USF9DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IHN2Z1BhdGhkYXRhLlNWR1BhdGhEYXRhLlFVQURfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBzdmdQYXRoZGF0YS5TVkdQYXRoRGF0YS5TTU9PVEhfUVVBRF9UTykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgICAgfSAvLyByZWZsZWN0IHBvaW50XG5cblxuICAgICAgdmFyIF90aGlzJGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQsXG4gICAgICAgICAgY3ggPSBfdGhpcyRjdXJyZW50LngsXG4gICAgICAgICAgY3kgPSBfdGhpcyRjdXJyZW50LnksXG4gICAgICAgICAgX3RoaXMkY29udHJvbCA9IHRoaXMuY29udHJvbCxcbiAgICAgICAgICBveCA9IF90aGlzJGNvbnRyb2wueCxcbiAgICAgICAgICBveSA9IF90aGlzJGNvbnRyb2wueTtcbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgyICogY3ggLSBveCwgMiAqIGN5IC0gb3kpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYWtlQWJzb2x1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFrZUFic29sdXRlKHBvaW50KSB7XG4gICAgICBpZiAodGhpcy5jb21tYW5kLnJlbGF0aXZlKSB7XG4gICAgICAgIHZhciBfdGhpcyRjdXJyZW50MiA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgICAgIHggPSBfdGhpcyRjdXJyZW50Mi54LFxuICAgICAgICAgICAgeSA9IF90aGlzJGN1cnJlbnQyLnk7XG4gICAgICAgIHBvaW50LnggKz0geDtcbiAgICAgICAgcG9pbnQueSArPSB5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE1hcmtlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRNYXJrZXIocG9pbnQsIGZyb20sIHByaW9yVG8pIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgICBhbmdsZXMgPSB0aGlzLmFuZ2xlczsgLy8gaWYgdGhlIGxhc3QgYW5nbGUgaXNuJ3QgZmlsbGVkIGluIGJlY2F1c2Ugd2UgZGlkbid0IGhhdmUgdGhpcyBwb2ludCB5ZXQgLi4uXG5cbiAgICAgIGlmIChwcmlvclRvICYmIGFuZ2xlcy5sZW5ndGggPiAwICYmICFhbmdsZXNbYW5nbGVzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGFuZ2xlc1thbmdsZXMubGVuZ3RoIC0gMV0gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmFuZ2xlVG8ocHJpb3JUbyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkTWFya2VyQW5nbGUocG9pbnQsIGZyb20gPyBmcm9tLmFuZ2xlVG8ocG9pbnQpIDogbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE1hcmtlckFuZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcmtlckFuZ2xlKHBvaW50LCBhbmdsZSkge1xuICAgICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgICB0aGlzLmFuZ2xlcy5wdXNoKGFuZ2xlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2VyUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlclBvaW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvaW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2VyQW5nbGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlckFuZ2xlcygpIHtcbiAgICAgIHZhciBhbmdsZXMgPSB0aGlzLmFuZ2xlcztcbiAgICAgIHZhciBsZW4gPSBhbmdsZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghYW5nbGVzW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChhbmdsZXNbal0pIHtcbiAgICAgICAgICAgICAgYW5nbGVzW2ldID0gYW5nbGVzW2pdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuZ2xlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0aFBhcnNlcjtcbn0oc3ZnUGF0aGRhdGEuU1ZHUGF0aERhdGEpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkSChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRIKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRIKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFJlbmRlcmVkRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSZW5kZXJlZEVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJEgoUmVuZGVyZWRFbGVtZW50KTtcblxuICBmdW5jdGlvbiBSZW5kZXJlZEVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBSZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSZW5kZXJlZEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImNhbGN1bGF0ZU9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlT3BhY2l0eSgpIHtcbiAgICAgIHZhciBvcGFjaXR5ID0gMS4wOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBvcGFjaXR5U3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCdvcGFjaXR5JywgZmFsc2UsIHRydWUpOyAvLyBubyBhbmNlc3RvcnMgb24gc3R5bGUgY2FsbFxuXG4gICAgICAgIGlmIChvcGFjaXR5U3R5bGUuaGFzVmFsdWUodHJ1ZSkpIHtcbiAgICAgICAgICBvcGFjaXR5ICo9IG9wYWNpdHlTdHlsZS5nZXROdW1iZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wYWNpdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGV4dChjdHgpIHtcbiAgICAgIHZhciBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIGlmICghZnJvbU1lYXN1cmUpIHtcbiAgICAgICAgLy8gY2F1c2VzIHN0YWNrIG92ZXJmbG93IHdoZW4gbWVhc3VyaW5nIHRleHQgd2l0aCBncmFkaWVudHNcbiAgICAgICAgLy8gZmlsbFxuICAgICAgICB2YXIgZmlsbFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwnKTtcbiAgICAgICAgdmFyIGZpbGxPcGFjaXR5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1vcGFjaXR5Jyk7XG4gICAgICAgIHZhciBzdHJva2VTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UnKTtcbiAgICAgICAgdmFyIHN0cm9rZU9wYWNpdHlQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW9wYWNpdHknKTtcblxuICAgICAgICBpZiAoZmlsbFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgZmlsbE9wYWNpdHlTdHlsZVByb3ApO1xuXG4gICAgICAgICAgaWYgKGZpbGxTdHlsZSkge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgaWYgKGZpbGxTdHlsZVByb3AuZ2V0U3RyaW5nKCkgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgICAgICAgICBmaWxsU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9maWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldENvbG9yKCk7XG5cbiAgICAgICAgICBpZiAoX2ZpbGxTdHlsZSAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZSA9PT0gJ25vbmUnID8gJ3JnYmEoMCwwLDAsMCknIDogX2ZpbGxTdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbE9wYWNpdHlTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHZhciBfZmlsbFN0eWxlMiA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIGN0eC5maWxsU3R5bGUpLmFkZE9wYWNpdHkoZmlsbE9wYWNpdHlTdHlsZVByb3ApLmdldENvbG9yKCk7XG5cbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gX2ZpbGxTdHlsZTI7XG4gICAgICAgIH0gLy8gc3Ryb2tlXG5cblxuICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgdmFyIHN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGVQcm9wLmdldEZpbGxTdHlsZURlZmluaXRpb24odGhpcywgc3Ryb2tlT3BhY2l0eVByb3ApO1xuXG4gICAgICAgICAgaWYgKHN0cm9rZVN0eWxlKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3Ryb2tlU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgICAgc3Ryb2tlU3R5bGVQcm9wLnNldFZhbHVlKHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJykuZ2V0Q29sb3IoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcblxuICAgICAgICAgIGlmIChfc3Ryb2tlU3R5bGUgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gX3N0cm9rZVN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBfc3Ryb2tlU3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cm9rZU9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB2YXIgX3N0cm9rZVN0eWxlMiA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgY3R4LnN0cm9rZVN0eWxlKS5hZGRPcGFjaXR5KHN0cm9rZU9wYWNpdHlQcm9wKS5nZXRTdHJpbmcoKTtcblxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IF9zdHJva2VTdHlsZTI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3Ryb2tlV2lkdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utd2lkdGgnKTtcblxuICAgICAgICBpZiAoc3Ryb2tlV2lkdGhTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHZhciBuZXdMaW5lV2lkdGggPSBzdHJva2VXaWR0aFN0eWxlUHJvcC5nZXRQaXhlbHMoKTtcbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gIW5ld0xpbmVXaWR0aCA/IFBTRVVET19aRVJPIC8vIGJyb3dzZXJzIGRvbid0IHJlc3BlY3QgMCAob3Igbm9kZS1jYW52YXM/IDotKVxuICAgICAgICAgIDogbmV3TGluZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZUxpbmVjYXBTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWNhcCcpO1xuICAgICAgICB2YXIgc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWpvaW4nKTtcbiAgICAgICAgdmFyIHN0cm9rZU1pdGVybGltaXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLW1pdGVybGltaXQnKTsgLy8gTkVFRCBURVNUXG4gICAgICAgIC8vIGNvbnN0IHBvaW50T3JkZXJTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdwYWludC1vcmRlcicpO1xuXG4gICAgICAgIHZhciBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtZGFzaGFycmF5Jyk7XG4gICAgICAgIHZhciBzdHJva2VEYXNob2Zmc2V0UHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ3N0cm9rZS1kYXNob2Zmc2V0Jyk7XG5cbiAgICAgICAgaWYgKHN0cm9rZUxpbmVjYXBTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGN0eC5saW5lQ2FwID0gc3Ryb2tlTGluZWNhcFN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJva2VMaW5lam9pblN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY3R4LmxpbmVKb2luID0gc3Ryb2tlTGluZWpvaW5TdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Ryb2tlTWl0ZXJsaW1pdFByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gc3Ryb2tlTWl0ZXJsaW1pdFByb3AuZ2V0TnVtYmVyKCk7XG4gICAgICAgIH0gLy8gTkVFRCBURVNUXG4gICAgICAgIC8vIGlmIChwb2ludE9yZGVyU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gXHQvLyA/XG4gICAgICAgIC8vIFx0Y3R4LnBhaW50T3JkZXIgPSBwb2ludE9yZGVyU3R5bGVQcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIC8vIH1cblxuXG4gICAgICAgIGlmIChzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuaGFzVmFsdWUoKSAmJiBzdHJva2VEYXNoYXJyYXlTdHlsZVByb3AuZ2V0U3RyaW5nKCkgIT09ICdub25lJykge1xuICAgICAgICAgIHZhciBnYXBzID0gdG9OdW1iZXJzKHN0cm9rZURhc2hhcnJheVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0eC5zZXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChnYXBzKTtcbiAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGN0eC53ZWJraXRMaW5lRGFzaCA9IGdhcHM7XG4gICAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4Lm1vekRhc2ggIT09ICd1bmRlZmluZWQnICYmICEoZ2Fwcy5sZW5ndGggPT09IDEgJiYgZ2Fwc1swXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgICBjdHgubW96RGFzaCA9IGdhcHM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvZmZzZXQgPSBzdHJva2VEYXNob2Zmc2V0UHJvcC5nZXRQaXhlbHMoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY3R4LmxpbmVEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5tb3pEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9udFxuXG5cbiAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZm9udFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQnKTtcbiAgICAgICAgdmFyIGZvbnRTdHlsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKTtcbiAgICAgICAgdmFyIGZvbnRWYXJpYW50U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC12YXJpYW50Jyk7XG4gICAgICAgIHZhciBmb250V2VpZ2h0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC13ZWlnaHQnKTtcbiAgICAgICAgdmFyIGZvbnRTaXplU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1zaXplJyk7XG4gICAgICAgIHZhciBmb250RmFtaWx5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcbiAgICAgICAgdmFyIGZvbnQgPSBuZXcgRm9udChmb250U3R5bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRWYXJpYW50U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250V2VpZ2h0U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250U2l6ZVN0eWxlUHJvcC5oYXNWYWx1ZSgpID8gXCJcIi5jb25jYXQoZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKHRydWUpLCBcInB4XCIpIDogJycsIGZvbnRGYW1pbHlTdHlsZVByb3AuZ2V0U3RyaW5nKCksIEZvbnQucGFyc2UoZm9udFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgY3R4LmZvbnQpKTtcbiAgICAgICAgZm9udFN0eWxlU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFN0eWxlKTtcbiAgICAgICAgZm9udFZhcmlhbnRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250VmFyaWFudCk7XG4gICAgICAgIGZvbnRXZWlnaHRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250V2VpZ2h0KTtcbiAgICAgICAgZm9udFNpemVTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250U2l6ZSk7XG4gICAgICAgIGZvbnRGYW1pbHlTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250RmFtaWx5KTtcbiAgICAgICAgY3R4LmZvbnQgPSBmb250LnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKGZvbnRTaXplU3R5bGVQcm9wLmlzUGl4ZWxzKCkpIHtcbiAgICAgICAgICB0aGlzLmRvY3VtZW50LmVtU2l6ZSA9IGZvbnRTaXplU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgIHRoaXMuYXBwbHlFZmZlY3RzKGN0eCk7IC8vIG9wYWNpdHlcblxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmNhbGN1bGF0ZU9wYWNpdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQ29udGV4dChjdHgpIHtcbiAgICAgIF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oUmVuZGVyZWRFbGVtZW50LnByb3RvdHlwZSksIFwiY2xlYXJDb250ZXh0XCIsIHRoaXMpLmNhbGwodGhpcywgY3R4KTtcblxuICAgICAgaWYgKHRoaXMubW9kaWZpZWRFbVNpemVTdGFjaykge1xuICAgICAgICB0aGlzLmRvY3VtZW50LnBvcEVtU2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZW5kZXJlZEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkRyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRHKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRHKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFBhdGhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVuZGVyZWRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUGF0aEVsZW1lbnQsIF9SZW5kZXJlZEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkRyhQYXRoRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUGF0aEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBhdGhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAncGF0aCc7XG4gICAgX3RoaXMucGF0aFBhcnNlciA9IG51bGw7XG4gICAgX3RoaXMucGF0aFBhcnNlciA9IG5ldyBQYXRoUGFyc2VyKF90aGlzLmdldEF0dHJpYnV0ZSgnZCcpLmdldFN0cmluZygpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBhdGhFbGVtZW50LCBbe1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoY3R4KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgcGF0aFBhcnNlci5yZXNldCgpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCFwYXRoUGFyc2VyLmlzRW5kKCkpIHtcbiAgICAgICAgc3dpdGNoIChwYXRoUGFyc2VyLm5leHQoKS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgICB0aGlzLnBhdGhNKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aEwoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5IT1JJWl9MSU5FX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoSChjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aFYoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aEMoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfQ1VSVkVfVE86XG4gICAgICAgICAgICB0aGlzLnBhdGhTKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aFEoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aFQoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAgICB0aGlzLnBhdGhBKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICAgIHRoaXMucGF0aFooY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94KF8pIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGgoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXJrZXJzKCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG4gICAgICB2YXIgcG9pbnRzID0gcGF0aFBhcnNlci5nZXRNYXJrZXJQb2ludHMoKTtcbiAgICAgIHZhciBhbmdsZXMgPSBwYXRoUGFyc2VyLmdldE1hcmtlckFuZ2xlcygpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBwb2ludHMubWFwKGZ1bmN0aW9uIChwb2ludCwgaSkge1xuICAgICAgICByZXR1cm4gW3BvaW50LCBhbmdsZXNbaV1dO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya2VycztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICB0aGlzLnBhdGgoY3R4KTtcbiAgICAgIHRoaXMuZG9jdW1lbnQuc2NyZWVuLm1vdXNlLmNoZWNrUGF0aCh0aGlzLCBjdHgpO1xuICAgICAgdmFyIGZpbGxSdWxlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1ydWxlJyk7XG5cbiAgICAgIGlmIChjdHguZmlsbFN0eWxlICE9PSAnJykge1xuICAgICAgICBpZiAoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCdpbmhlcml0JykgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGN0eC5maWxsKGZpbGxSdWxlU3R5bGVQcm9wLmdldFN0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09ICcnKSB7XG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgndmVjdG9yLWVmZmVjdCcpLmdldFN0cmluZygpID09PSAnbm9uLXNjYWxpbmctc3Ryb2tlJykge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcblxuICAgICAgaWYgKG1hcmtlcnMpIHtcbiAgICAgICAgdmFyIG1hcmtlcnNMYXN0SW5kZXggPSBtYXJrZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBtYXJrZXJTdGFydFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ21hcmtlci1zdGFydCcpO1xuICAgICAgICB2YXIgbWFya2VyTWlkU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLW1pZCcpO1xuICAgICAgICB2YXIgbWFya2VyRW5kU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLWVuZCcpO1xuXG4gICAgICAgIGlmIChtYXJrZXJTdGFydFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJTdGFydFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgICB2YXIgX21hcmtlcnMkID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKG1hcmtlcnNbMF0sIDIpLFxuICAgICAgICAgICAgICBwb2ludCA9IF9tYXJrZXJzJFswXSxcbiAgICAgICAgICAgICAgYW5nbGUgPSBfbWFya2VycyRbMV07XG5cbiAgICAgICAgICBtYXJrZXIucmVuZGVyKGN0eCwgcG9pbnQsIGFuZ2xlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJrZXJNaWRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgICB2YXIgX21hcmtlciA9IG1hcmtlck1pZFN0eWxlUHJvcC5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hcmtlcnNMYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9tYXJrZXJzJGkgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0obWFya2Vyc1tpXSwgMiksXG4gICAgICAgICAgICAgICAgX3BvaW50ID0gX21hcmtlcnMkaVswXSxcbiAgICAgICAgICAgICAgICBfYW5nbGUgPSBfbWFya2VycyRpWzFdO1xuXG4gICAgICAgICAgICBfbWFya2VyLnJlbmRlcihjdHgsIF9wb2ludCwgX2FuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya2VyRW5kU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgICAgdmFyIF9tYXJrZXIyID0gbWFya2VyRW5kU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICAgIHZhciBfbWFya2VycyRtYXJrZXJzTGFzdEkgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0obWFya2Vyc1ttYXJrZXJzTGFzdEluZGV4XSwgMiksXG4gICAgICAgICAgICAgIF9wb2ludDIgPSBfbWFya2VycyRtYXJrZXJzTGFzdElbMF0sXG4gICAgICAgICAgICAgIF9hbmdsZTIgPSBfbWFya2VycyRtYXJrZXJzTGFzdElbMV07XG5cbiAgICAgICAgICBfbWFya2VyMi5yZW5kZXIoY3R4LCBfcG9pbnQyLCBfYW5nbGUyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoTSA9IFBhdGhFbGVtZW50LnBhdGhNKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIHBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhNLnBvaW50O1xuXG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTChjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoTCA9IFBhdGhFbGVtZW50LnBhdGhMKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEwuY3VycmVudCxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoTC5wb2ludDtcblxuICAgICAgdmFyIHggPSBwb2ludC54LFxuICAgICAgICAgIHkgPSBwb2ludC55O1xuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aEhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aEgoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG5cbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aEggPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjdXJyZW50ID0gX1BhdGhFbGVtZW50JHBhdGhILmN1cnJlbnQsXG4gICAgICAgICAgcG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEgucG9pbnQ7XG5cbiAgICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKHBvaW50LCBjdXJyZW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhWXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhWKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhWID0gUGF0aEVsZW1lbnQucGF0aFYocGF0aFBhcnNlciksXG4gICAgICAgICAgY3VycmVudCA9IF9QYXRoRWxlbWVudCRwYXRoVi5jdXJyZW50LFxuICAgICAgICAgIHBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhWLnBvaW50O1xuXG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihwb2ludCwgY3VycmVudCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRQb2ludCh4LCB5KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQyhjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoQyA9IFBhdGhFbGVtZW50LnBhdGhDKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEMuY3VycmVudCxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5wb2ludCxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEMuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBwb2ludCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRCZXppZXJDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgcG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFMoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG5cbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFMgPSBQYXRoRWxlbWVudC5wYXRoUyhwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjdXJyZW50ID0gX1BhdGhFbGVtZW50JHBhdGhTLmN1cnJlbnQsXG4gICAgICAgICAgcG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMucG9pbnQsXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhTLmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMuY3VycmVudFBvaW50O1xuXG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgcG9pbnQpO1xuICAgICAgYm91bmRpbmdCb3guYWRkQmV6aWVyQ3VydmUoY3VycmVudC54LCBjdXJyZW50LnksIHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhRXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhRKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIHZhciBwYXRoUGFyc2VyID0gdGhpcy5wYXRoUGFyc2VyO1xuXG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhRID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlciksXG4gICAgICAgICAgY3VycmVudCA9IF9QYXRoRWxlbWVudCRwYXRoUS5jdXJyZW50LFxuICAgICAgICAgIGNvbnRyb2xQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoUS5jb250cm9sUG9pbnQsXG4gICAgICAgICAgY3VycmVudFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhRLmN1cnJlbnRQb2ludDtcblxuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIGNvbnRyb2xQb2ludCk7XG4gICAgICBib3VuZGluZ0JveC5hZGRRdWFkcmF0aWNDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFQoY3R4LCBib3VuZGluZ0JveCkge1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSB0aGlzLnBhdGhQYXJzZXI7XG5cbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFQgPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKSxcbiAgICAgICAgICBjdXJyZW50ID0gX1BhdGhFbGVtZW50JHBhdGhULmN1cnJlbnQsXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhULmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFQuY3VycmVudFBvaW50O1xuXG4gICAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgY29udHJvbFBvaW50KTtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQShjdHgsIGJvdW5kaW5nQm94KSB7XG4gICAgICB2YXIgcGF0aFBhcnNlciA9IHRoaXMucGF0aFBhcnNlcjtcblxuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoQSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQS5jdXJyZW50UG9pbnQsXG4gICAgICAgICAgclggPSBfUGF0aEVsZW1lbnQkcGF0aEEuclgsXG4gICAgICAgICAgclkgPSBfUGF0aEVsZW1lbnQkcGF0aEEuclksXG4gICAgICAgICAgc3dlZXBGbGFnID0gX1BhdGhFbGVtZW50JHBhdGhBLnN3ZWVwRmxhZyxcbiAgICAgICAgICB4QXhpc1JvdGF0aW9uID0gX1BhdGhFbGVtZW50JHBhdGhBLnhBeGlzUm90YXRpb24sXG4gICAgICAgICAgY2VudHAgPSBfUGF0aEVsZW1lbnQkcGF0aEEuY2VudHAsXG4gICAgICAgICAgYTEgPSBfUGF0aEVsZW1lbnQkcGF0aEEuYTEsXG4gICAgICAgICAgYWQgPSBfUGF0aEVsZW1lbnQkcGF0aEEuYWQ7IC8vIGZvciBtYXJrZXJzXG5cblxuICAgICAgdmFyIGRpciA9IDEgLSBzd2VlcEZsYWcgPyAxLjAgOiAtMS4wO1xuICAgICAgdmFyIGFoID0gYTEgKyBkaXIgKiAoYWQgLyAyLjApO1xuICAgICAgdmFyIGhhbGZXYXkgPSBuZXcgUG9pbnQoY2VudHAueCArIHJYICogTWF0aC5jb3MoYWgpLCBjZW50cC55ICsgclkgKiBNYXRoLnNpbihhaCkpO1xuICAgICAgcGF0aFBhcnNlci5hZGRNYXJrZXJBbmdsZShoYWxmV2F5LCBhaCAtIGRpciAqIE1hdGguUEkgLyAyKTtcbiAgICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyQW5nbGUoY3VycmVudFBvaW50LCBhaCAtIGRpciAqIE1hdGguUEkpO1xuICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTsgLy8gVE9ETzogdGhpcyBpcyB0b28gbmFpdmUsIG1ha2UgaXQgYmV0dGVyXG5cbiAgICAgIGlmIChjdHggJiYgIWlzTmFOKGExKSAmJiAhaXNOYU4oYWQpKSB7XG4gICAgICAgIHZhciByID0gclggPiByWSA/IHJYIDogclk7XG4gICAgICAgIHZhciBzeCA9IHJYID4gclkgPyAxIDogclggLyByWTtcbiAgICAgICAgdmFyIHN5ID0gclggPiByWSA/IHJZIC8gclggOiAxO1xuICAgICAgICBjdHgudHJhbnNsYXRlKGNlbnRwLngsIGNlbnRwLnkpO1xuICAgICAgICBjdHgucm90YXRlKHhBeGlzUm90YXRpb24pO1xuICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcbiAgICAgICAgY3R4LmFyYygwLCAwLCByLCBhMSwgYTEgKyBhZCwgQm9vbGVhbigxIC0gc3dlZXBGbGFnKSk7XG4gICAgICAgIGN0eC5zY2FsZSgxIC8gc3gsIDEgLyBzeSk7XG4gICAgICAgIGN0eC5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xuICAgICAgICBjdHgudHJhbnNsYXRlKC1jZW50cC54LCAtY2VudHAueSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhaKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICAgIFBhdGhFbGVtZW50LnBhdGhaKHRoaXMucGF0aFBhcnNlcik7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgLy8gb25seSBjbG9zZSBwYXRoIGlmIGl0IGlzIG5vdCBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94LngxICE9PSBib3VuZGluZ0JveC54MiAmJiBib3VuZGluZ0JveC55MSAhPT0gYm91bmRpbmdCb3gueTIpIHtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXRoTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTShwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICBwYXRoUGFyc2VyLnN0YXJ0ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTChwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgIHBvaW50OiBwb2ludFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aEhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aEgocGF0aFBhcnNlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQsXG4gICAgICAgICAgY29tbWFuZCA9IHBhdGhQYXJzZXIuY29tbWFuZDtcbiAgICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgoY29tbWFuZC5yZWxhdGl2ZSA/IGN1cnJlbnQueCA6IDApICsgY29tbWFuZC54LCBjdXJyZW50LnkpO1xuICAgICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcG9pbnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICBwb2ludDogcG9pbnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhWXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhWKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50LFxuICAgICAgICAgIGNvbW1hbmQgPSBwYXRoUGFyc2VyLmNvbW1hbmQ7XG4gICAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoY3VycmVudC54LCAoY29tbWFuZC5yZWxhdGl2ZSA/IGN1cnJlbnQueSA6IDApICsgY29tbWFuZC55KTtcbiAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgcG9pbnQ6IHBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQyhwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50OiBjdXJyZW50LFxuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGNvbnRyb2xQb2ludDogY29udHJvbFBvaW50LFxuICAgICAgICBjdXJyZW50UG9pbnQ6IGN1cnJlbnRQb2ludFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFMocGF0aFBhcnNlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQ7XG4gICAgICB2YXIgcG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBjb250cm9sUG9pbnQ6IGNvbnRyb2xQb2ludCxcbiAgICAgICAgY3VycmVudFBvaW50OiBjdXJyZW50UG9pbnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhRXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhRKHBhdGhQYXJzZXIpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gcGF0aFBhcnNlci5jdXJyZW50O1xuICAgICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gxJywgJ3kxJyk7XG4gICAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVudDogY3VycmVudCxcbiAgICAgICAgY29udHJvbFBvaW50OiBjb250cm9sUG9pbnQsXG4gICAgICAgIGN1cnJlbnRQb2ludDogY3VycmVudFBvaW50XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoVFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoVChwYXRoUGFyc2VyKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgICAgcGF0aFBhcnNlci5jb250cm9sID0gY29udHJvbFBvaW50O1xuICAgICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgIGNvbnRyb2xQb2ludDogY29udHJvbFBvaW50LFxuICAgICAgICBjdXJyZW50UG9pbnQ6IGN1cnJlbnRQb2ludFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aEFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aEEocGF0aFBhcnNlcikge1xuICAgICAgdmFyIGN1cnJlbnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQsXG4gICAgICAgICAgY29tbWFuZCA9IHBhdGhQYXJzZXIuY29tbWFuZDtcbiAgICAgIHZhciByWCA9IGNvbW1hbmQuclgsXG4gICAgICAgICAgclkgPSBjb21tYW5kLnJZLFxuICAgICAgICAgIHhSb3QgPSBjb21tYW5kLnhSb3QsXG4gICAgICAgICAgbEFyY0ZsYWcgPSBjb21tYW5kLmxBcmNGbGFnLFxuICAgICAgICAgIHN3ZWVwRmxhZyA9IGNvbW1hbmQuc3dlZXBGbGFnO1xuICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSB4Um90ICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpOyAvLyBDb252ZXJzaW9uIGZyb20gZW5kcG9pbnQgdG8gY2VudGVyIHBhcmFtZXRlcml6YXRpb25cbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgICAgLy8geDEnLCB5MSdcblxuICAgICAgdmFyIGN1cnJwID0gbmV3IFBvaW50KE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCwgLU1hdGguc2luKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueCAtIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogKGN1cnJlbnQueSAtIGN1cnJlbnRQb2ludC55KSAvIDIuMCk7IC8vIGFkanVzdCByYWRpaVxuXG4gICAgICB2YXIgbCA9IE1hdGgucG93KGN1cnJwLngsIDIpIC8gTWF0aC5wb3coclgsIDIpICsgTWF0aC5wb3coY3VycnAueSwgMikgLyBNYXRoLnBvdyhyWSwgMik7XG5cbiAgICAgIGlmIChsID4gMSkge1xuICAgICAgICByWCAqPSBNYXRoLnNxcnQobCk7XG4gICAgICAgIHJZICo9IE1hdGguc3FydChsKTtcbiAgICAgIH0gLy8gY3gnLCBjeSdcblxuXG4gICAgICB2YXIgcyA9IChsQXJjRmxhZyA9PT0gc3dlZXBGbGFnID8gLTEgOiAxKSAqIE1hdGguc3FydCgoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coclksIDIpIC0gTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgLSBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkgLyAoTWF0aC5wb3coclgsIDIpICogTWF0aC5wb3coY3VycnAueSwgMikgKyBNYXRoLnBvdyhyWSwgMikgKiBNYXRoLnBvdyhjdXJycC54LCAyKSkpO1xuXG4gICAgICBpZiAoaXNOYU4ocykpIHtcbiAgICAgICAgcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjcHAgPSBuZXcgUG9pbnQocyAqIHJYICogY3VycnAueSAvIHJZLCBzICogLXJZICogY3VycnAueCAvIHJYKTsgLy8gY3gsIGN5XG5cbiAgICAgIHZhciBjZW50cCA9IG5ldyBQb2ludCgoY3VycmVudC54ICsgY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueCAtIE1hdGguc2luKHhBeGlzUm90YXRpb24pICogY3BwLnksIChjdXJyZW50LnkgKyBjdXJyZW50UG9pbnQueSkgLyAyLjAgKyBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC54ICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiBjcHAueSk7IC8vIGluaXRpYWwgYW5nbGVcblxuICAgICAgdmFyIGExID0gdmVjdG9yc0FuZ2xlKFsxLCAwXSwgWyhjdXJycC54IC0gY3BwLngpIC8gclgsIChjdXJycC55IC0gY3BwLnkpIC8gclldKTsgLy8gzrgxXG4gICAgICAvLyBhbmdsZSBkZWx0YVxuXG4gICAgICB2YXIgdSA9IFsoY3VycnAueCAtIGNwcC54KSAvIHJYLCAoY3VycnAueSAtIGNwcC55KSAvIHJZXTtcbiAgICAgIHZhciB2ID0gWygtY3VycnAueCAtIGNwcC54KSAvIHJYLCAoLWN1cnJwLnkgLSBjcHAueSkgLyByWV07XG4gICAgICB2YXIgYWQgPSB2ZWN0b3JzQW5nbGUodSwgdik7IC8vIM6UzrhcblxuICAgICAgaWYgKHZlY3RvcnNSYXRpbyh1LCB2KSA8PSAtMSkge1xuICAgICAgICBhZCA9IE1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZWN0b3JzUmF0aW8odSwgdikgPj0gMSkge1xuICAgICAgICBhZCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnRQb2ludDogY3VycmVudFBvaW50LFxuICAgICAgICByWDogclgsXG4gICAgICAgIHJZOiByWSxcbiAgICAgICAgc3dlZXBGbGFnOiBzd2VlcEZsYWcsXG4gICAgICAgIHhBeGlzUm90YXRpb246IHhBeGlzUm90YXRpb24sXG4gICAgICAgIGNlbnRwOiBjZW50cCxcbiAgICAgICAgYTE6IGExLFxuICAgICAgICBhZDogYWRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhaXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhaKHBhdGhQYXJzZXIpIHtcbiAgICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBhdGhQYXJzZXIuc3RhcnQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhdGhFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkRihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRGKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRGKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEdseXBoRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhdGhFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oR2x5cGhFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkRihHbHlwaEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEdseXBoRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgR2x5cGhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZ2x5cGgnO1xuICAgIF90aGlzLmhvcml6QWR2WCA9IF90aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICBfdGhpcy51bmljb2RlID0gX3RoaXMuZ2V0QXR0cmlidXRlKCd1bmljb2RlJykuZ2V0U3RyaW5nKCk7XG4gICAgX3RoaXMuYXJhYmljRm9ybSA9IF90aGlzLmdldEF0dHJpYnV0ZSgnYXJhYmljLWZvcm0nKS5nZXRTdHJpbmcoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gR2x5cGhFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRFKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEUoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVGV4dEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlZEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUZXh0RWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRFKFRleHRFbGVtZW50KTtcblxuICBmdW5jdGlvbiBUZXh0RWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVGV4dEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgKHRoaXMgaW5zdGFuY2VvZiBUZXh0RWxlbWVudCA/IHRoaXMuY29uc3RydWN0b3IgOiB2b2lkIDApID09PSBUZXh0RWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ3RleHQnO1xuICAgIF90aGlzLnggPSAwO1xuICAgIF90aGlzLnkgPSAwO1xuICAgIF90aGlzLm1lYXN1cmVDYWNoZSA9IC0xO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVGV4dEVsZW1lbnQsIFt7XG4gICAga2V5OiBcInNldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGV4dChjdHgpIHtcbiAgICAgIHZhciBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgIF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oVGV4dEVsZW1lbnQucHJvdG90eXBlKSwgXCJzZXRDb250ZXh0XCIsIHRoaXMpLmNhbGwodGhpcywgY3R4LCBmcm9tTWVhc3VyZSk7XG5cbiAgICAgIHZhciB0ZXh0QmFzZWxpbmUgPSB0aGlzLmdldFN0eWxlKCdkb21pbmFudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpIHx8IHRoaXMuZ2V0U3R5bGUoJ2FsaWdubWVudC1iYXNlbGluZScpLmdldFRleHRCYXNlbGluZSgpO1xuXG4gICAgICBpZiAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplQ29vcmRpbmF0ZXMoKSB7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMubGVhZlRleHRzID0gW107XG4gICAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gMDtcbiAgICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIHRoaXMubWF4WCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KTtcbiAgICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBudWxsOyAvLyB0aGVuIGNhbGN1bGF0ZSBib3VuZGluZyBib3hcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gX3RoaXMyLmdldENoaWxkQm91bmRpbmdCb3goY3R4LCBfdGhpczIsIF90aGlzMiwgaSk7XG5cbiAgICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICAgIGJvdW5kaW5nQm94ID0gY2hpbGRCb3VuZGluZ0JveDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZvbnRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvbnRTaXplKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgIHZhciBpbmhlcml0Rm9udFNpemUgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KS5mb250U2l6ZTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGluaGVyaXRGb250U2l6ZSk7XG4gICAgICByZXR1cm4gZm9udFNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRFbGVtZW50Qm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnkgLSBmb250U2l6ZSwgdGhpcy54ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB0aGlzLnkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRHbHlwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHbHlwaChmb250LCB0ZXh0LCBpKSB7XG4gICAgICB2YXIgY2hhciA9IHRleHRbaV07XG4gICAgICB2YXIgZ2x5cGggPSBudWxsO1xuXG4gICAgICBpZiAoZm9udC5pc0FyYWJpYykge1xuICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBwcmV2Q2hhciA9IHRleHRbaSAtIDFdO1xuICAgICAgICB2YXIgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgdmFyIGFyYWJpY0Zvcm0gPSAnaXNvbGF0ZWQnO1xuXG4gICAgICAgIGlmICgoaSA9PT0gMCB8fCBwcmV2Q2hhciA9PT0gJyAnKSAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgYXJhYmljRm9ybSA9ICd0ZXJtaW5hbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiBpIDwgbGVuIC0gMSAmJiBuZXh0Q2hhciAhPT0gJyAnKSB7XG4gICAgICAgICAgYXJhYmljRm9ybSA9ICdtZWRpYWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPiAwICYmIHByZXZDaGFyICE9PSAnICcgJiYgKGkgPT09IGxlbiAtIDEgfHwgbmV4dENoYXIgPT09ICcgJykpIHtcbiAgICAgICAgICBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb250LmdseXBoc1tjaGFyXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBORUVEIFRFU1RcbiAgICAgICAgICB2YXIgbWF5YmVHbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgICAgIGdseXBoID0gbWF5YmVHbHlwaCBpbnN0YW5jZW9mIEdseXBoRWxlbWVudCA/IG1heWJlR2x5cGggOiBtYXliZUdseXBoW2FyYWJpY0Zvcm1dO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzW2NoYXJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIGdseXBoID0gZm9udC5taXNzaW5nR2x5cGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0RnJvbU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dEZyb21Ob2RlKG5vZGUpIHtcbiAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUgfHwgdGhpcy5ub2RlO1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHRleHROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICB2YXIgaW5kZXggPSBjaGlsZE5vZGVzLmluZGV4T2YodGV4dE5vZGUpO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IGNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciB0ZXh0ID0gY29tcHJlc3NTcGFjZXMoIC8vIHRleHROb2RlLnZhbHVlXG4gICAgICAvLyB8fCB0ZXh0Tm9kZS50ZXh0XG4gICAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCB8fCAnJyk7XG5cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB0ZXh0ID0gdHJpbUxlZnQodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHRleHQgPSB0cmltUmlnaHQodGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJDaGlsZHJlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJURWxlbWVudENoaWxkcmVuKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZmlyc3QsIGNhbGN1bGF0ZSBjaGlsZCBwb3NpdGlvbnNcblxuXG4gICAgICB0aGlzLmluaXRpYWxpemVDb29yZGluYXRlcygpO1xuICAgICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7IC8vIHRoZW4gcmVuZGVyXG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICBfdGhpczMucmVuZGVyQ2hpbGQoY3R4LCBfdGhpczMsIF90aGlzMywgaSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBtb3VzZSA9IHRoaXMuZG9jdW1lbnQuc2NyZWVuLm1vdXNlOyAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG5cbiAgICAgIGlmIChtb3VzZS5pc1dvcmtpbmcoKSkge1xuICAgICAgICBtb3VzZS5jaGVja0JvdW5kaW5nQm94KHRoaXMsIHRoaXMuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclRFbGVtZW50Q2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVEVsZW1lbnRDaGlsZHJlbihjdHgpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgdmFyIGN1c3RvbUZvbnQgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoY3VzdG9tRm9udCkge1xuICAgICAgICB2YXIgdW5pdHNQZXJFbSA9IGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcbiAgICAgICAgdmFyIGN0eEZvbnQgPSBGb250LnBhcnNlKGRvY3VtZW50LmN0eC5mb250KTtcbiAgICAgICAgdmFyIGZvbnRTaXplID0gcGFyZW50LmdldFN0eWxlKCdmb250LXNpemUnKS5nZXROdW1iZXIoY3R4Rm9udC5mb250U2l6ZSk7XG4gICAgICAgIHZhciBmb250U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtc3R5bGUnKS5nZXRTdHJpbmcoY3R4Rm9udC5mb250U3R5bGUpO1xuICAgICAgICB2YXIgc2NhbGUgPSBmb250U2l6ZSAvIHVuaXRzUGVyRW07XG4gICAgICAgIHZhciB0ZXh0ID0gY3VzdG9tRm9udC5pc1JUTCA/IHJlbmRlclRleHQuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IHJlbmRlclRleHQ7XG4gICAgICAgIHZhciBkeCA9IHRvTnVtYmVycyhwYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKGN1c3RvbUZvbnQsIHRleHQsIGkpO1xuICAgICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54LCB0aGlzLnkpO1xuICAgICAgICAgIGN0eC5zY2FsZShzY2FsZSwgLXNjYWxlKTtcbiAgICAgICAgICB2YXIgbHcgPSBjdHgubGluZVdpZHRoO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjdHgubGluZVdpZHRoICogdW5pdHNQZXJFbSAvIGZvbnRTaXplO1xuXG4gICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLjQsIDEsIDAsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdseXBoLnJlbmRlcihjdHgpO1xuXG4gICAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0oMSwgMCwgLS40LCAxLCAwLCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gbHc7XG4gICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZSwgLTEgLyBzY2FsZSk7XG4gICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTtcbiAgICAgICAgICB0aGlzLnggKz0gZm9udFNpemUgKiAoZ2x5cGguaG9yaXpBZHZYIHx8IGN1c3RvbUZvbnQuaG9yaXpBZHZYKSAvIHVuaXRzUGVyRW07XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGR4W2ldICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOYU4oZHhbaV0pKSB7XG4gICAgICAgICAgICB0aGlzLnggKz0gZHhbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgICB5ID0gdGhpcy55OyAvLyBORUVEIFRFU1RcbiAgICAgIC8vIGlmIChjdHgucGFpbnRPcmRlciA9PT0gJ3N0cm9rZScpIHtcbiAgICAgIC8vIFx0aWYgKGN0eC5zdHJva2VTdHlsZSkge1xuICAgICAgLy8gXHRcdGN0eC5zdHJva2VUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgICAgLy8gXHR9XG4gICAgICAvLyBcdGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAvLyBcdFx0Y3R4LmZpbGxUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgICAgLy8gXHR9XG4gICAgICAvLyB9IGVsc2Uge1xuXG4gICAgICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgICBjdHguZmlsbFRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQocmVuZGVyVGV4dCwgeCwgeSk7XG4gICAgICB9IC8vIH1cblxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhcHBseUFuY2hvcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUFuY2hvcmluZygpIHtcbiAgICAgIGlmICh0aGlzLnRleHRDaHVua1N0YXJ0ID49IHRoaXMubGVhZlRleHRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBcIkFwcGx5IGFuY2hvcmluZ1wiIHBhcnQgb2YgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzIvdGV4dC5odG1sI1RleHRMYXlvdXRBbGdvcml0aG0uXG4gICAgICAvLyBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IHdlIGFwcGx5IHRoZSBhbmNob3JpbmcgYXMgc29vbiBhcyBhIGNodW5rIGlzIGZpbmlzaGVkLiBUaGlzIHNhdmVzIHNvbWUgZXh0cmEgbG9vcGluZy5cbiAgICAgIC8vIFZlcnRpY2FsIHRleHQgaXMgbm90IHN1cHBvcnRlZC5cblxuXG4gICAgICB2YXIgZmlyc3RFbGVtZW50ID0gdGhpcy5sZWFmVGV4dHNbdGhpcy50ZXh0Q2h1bmtTdGFydF07XG4gICAgICB2YXIgdGV4dEFuY2hvciA9IGZpcnN0RWxlbWVudC5nZXRTdHlsZSgndGV4dC1hbmNob3InKS5nZXRTdHJpbmcoJ3N0YXJ0Jyk7XG4gICAgICB2YXIgaXNSVEwgPSBmYWxzZTsgLy8gd2UgdHJlYXQgUlRMIGxpa2UgTFRSXG5cbiAgICAgIHZhciBzaGlmdCA9IDA7XG5cbiAgICAgIGlmICh0ZXh0QW5jaG9yID09PSAnc3RhcnQnICYmICFpc1JUTCB8fCB0ZXh0QW5jaG9yID09PSAnZW5kJyAmJiBpc1JUTCkge1xuICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5taW5YO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QW5jaG9yID09PSAnZW5kJyAmJiAhaXNSVEwgfHwgdGV4dEFuY2hvciA9PT0gJ3N0YXJ0JyAmJiBpc1JUTCkge1xuICAgICAgICBzaGlmdCA9IGZpcnN0RWxlbWVudC54IC0gdGhpcy5tYXhYO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtICh0aGlzLm1pblggKyB0aGlzLm1heFgpIC8gMjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudGV4dENodW5rU3RhcnQ7IGkgPCB0aGlzLmxlYWZUZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmxlYWZUZXh0c1tpXS54ICs9IHNoaWZ0O1xuICAgICAgfSAvLyBzdGFydCBuZXcgY2h1bmtcblxuXG4gICAgICB0aGlzLm1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICB0aGlzLnRleHRDaHVua1N0YXJ0ID0gdGhpcy5sZWFmVGV4dHMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgIF90aGlzNC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIF90aGlzNCwgX3RoaXM0LCBpKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hcHBseUFuY2hvcmluZygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChfLCBpKSB7XG4gICAgICAgICAgdGV4dFBhcmVudC5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlQ29yZShjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbmx5IGxlYWZzIGFyZSByZWxldmFudFxuICAgICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5tZWFzdXJlVGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjaGlsZC5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgICB2YXIgeEF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICAgIHZhciB5QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgneScpO1xuICAgICAgdmFyIGR4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHgnKTtcbiAgICAgIHZhciBkeUF0dHIgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2R5Jyk7XG4gICAgICB2YXIgY3VzdG9tRm9udCA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpLmdldERlZmluaXRpb24oKTtcbiAgICAgIHZhciBpc1JUTCA9IEJvb2xlYW4oY3VzdG9tRm9udCkgJiYgY3VzdG9tRm9udC5pc1JUTDtcblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgLy8gRmlyc3QgY2hpbGRyZW4gaW5oZXJpdCBhdHRyaWJ1dGVzIGZyb20gcGFyZW50KHMpLiBQb3NpdGlvbmFsIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXQncyBmaXJzdCBjaGlsZC5cbiAgICAgICAgaWYgKCF4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgeEF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgeUF0dHIuc2V0VmFsdWUoY2hpbGQuZ2V0SW5oZXJpdGVkQXR0cmlidXRlKCd5JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGR4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R4JykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGR5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ2R5JykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IGNoaWxkLm1lYXN1cmVUZXh0KGN0eCk7XG5cbiAgICAgIGlmIChpc1JUTCkge1xuICAgICAgICB0ZXh0UGFyZW50LnggLT0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIC8vIGFuIFwieFwiIGF0dHJpYnV0ZSBtYXJrcyB0aGUgc3RhcnQgb2YgYSBuZXcgY2h1bmtcbiAgICAgICAgdGV4dFBhcmVudC5hcHBseUFuY2hvcmluZygpO1xuICAgICAgICBjaGlsZC54ID0geEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG5cbiAgICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgY2hpbGQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHRleHRQYXJlbnQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC54ID0gdGV4dFBhcmVudC54O1xuICAgICAgfVxuXG4gICAgICB0ZXh0UGFyZW50LnggPSBjaGlsZC54O1xuXG4gICAgICBpZiAoIWlzUlRMKSB7XG4gICAgICAgIHRleHRQYXJlbnQueCArPSB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2hpbGQueSA9IHlBdHRyLmdldFBpeGVscygneScpO1xuXG4gICAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGNoaWxkLnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB0ZXh0UGFyZW50LnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQueSA9IHRleHRQYXJlbnQueTtcbiAgICAgIH1cblxuICAgICAgdGV4dFBhcmVudC55ID0gY2hpbGQueTsgLy8gdXBkYXRlIHRoZSBjdXJyZW50IGNodW5rIGFuZCBpdCdzIGJvdW5kc1xuXG4gICAgICB0ZXh0UGFyZW50LmxlYWZUZXh0cy5wdXNoKGNoaWxkKTtcbiAgICAgIHRleHRQYXJlbnQubWluWCA9IE1hdGgubWluKHRleHRQYXJlbnQubWluWCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICAgIHRleHRQYXJlbnQubWF4WCA9IE1hdGgubWF4KHRleHRQYXJlbnQubWF4WCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICAgIGNoaWxkLmNsZWFyQ29udGV4dChjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2hpbGRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07IC8vIG5vdCBhIHRleHQgbm9kZT9cblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5nZXRCb3VuZGluZ0JveCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICB2YXIgY2hpbGRCb3VuZGluZ0JveCA9IHRleHRQYXJlbnQuZ2V0Q2hpbGRCb3VuZGluZ0JveChjdHgsIHRleHRQYXJlbnQsIGNoaWxkLCBpKTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGRCb3VuZGluZ0JveCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGQoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLnJlbmRlcihjdHgpO1xuICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoXywgaSkge1xuICAgICAgICB0ZXh0UGFyZW50LnJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lYXN1cmVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGN0eCkge1xuICAgICAgdmFyIG1lYXN1cmVDYWNoZSA9IHRoaXMubWVhc3VyZUNhY2hlO1xuXG4gICAgICBpZiAofm1lYXN1cmVDYWNoZSkge1xuICAgICAgICByZXR1cm4gbWVhc3VyZUNhY2hlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgICAgdmFyIG1lYXN1cmUgPSB0aGlzLm1lYXN1cmVUYXJnZXRUZXh0KGN0eCwgcmVuZGVyVGV4dCk7XG4gICAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IG1lYXN1cmU7XG4gICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWVhc3VyZVRhcmdldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVhc3VyZVRhcmdldFRleHQoY3R4LCB0YXJnZXRUZXh0KSB7XG4gICAgICBpZiAoIXRhcmdldFRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICB2YXIgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICAgIGlmIChjdXN0b21Gb250KSB7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgICAgdmFyIHRleHQgPSBjdXN0b21Gb250LmlzUlRMID8gdGFyZ2V0VGV4dC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogdGFyZ2V0VGV4dDtcbiAgICAgICAgdmFyIGR4ID0gdG9OdW1iZXJzKHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBfbWVhc3VyZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgICAgX21lYXN1cmUgKz0gKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgKiBmb250U2l6ZSAvIGN1c3RvbUZvbnQuZm9udEZhY2UudW5pdHNQZXJFbTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICAgIF9tZWFzdXJlICs9IGR4W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfbWVhc3VyZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdHgubWVhc3VyZVRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFRleHQubGVuZ3RoICogMTA7XG4gICAgICB9XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLnNldENvbnRleHQoY3R4LCB0cnVlKTtcblxuICAgICAgdmFyIF9jdHgkbWVhc3VyZVRleHQgPSBjdHgubWVhc3VyZVRleHQodGFyZ2V0VGV4dCksXG4gICAgICAgICAgbWVhc3VyZSA9IF9jdHgkbWVhc3VyZVRleHQud2lkdGg7XG5cbiAgICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIG1lYXN1cmU7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogSW5oZXJpdHMgcG9zaXRpb25hbCBhdHRyaWJ1dGVzIGZyb20ge0BsaW5rIFRleHRFbGVtZW50fSBwYXJlbnQocykuIEF0dHJpYnV0ZXNcclxuICAgICAqIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0cyBmaXJzdCBjaGlsZC5cclxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIGF0dHJpYnV0ZSBuYW1lLlxyXG4gICAgICogQHJldHVybnMgVGhlIGF0dHJpYnV0ZSB2YWx1ZSBvciBudWxsLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmhlcml0ZWRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5oZXJpdGVkQXR0cmlidXRlKG5hbWUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyxjb25zaXN0ZW50LXRoaXNcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcztcblxuICAgICAgd2hpbGUgKGN1cnJlbnQgaW5zdGFuY2VvZiBUZXh0RWxlbWVudCAmJiBjdXJyZW50LmlzRmlyc3RDaGlsZCgpKSB7XG4gICAgICAgIHZhciBwYXJlbnRBdHRyID0gY3VycmVudC5wYXJlbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICAgIGlmIChwYXJlbnRBdHRyLmhhc1ZhbHVlKHRydWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudEF0dHIuZ2V0VmFsdWUoJzAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRleHRFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkRChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCREKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCREKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFRTcGFuRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVFNwYW5FbGVtZW50LCBfVGV4dEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkRChUU3BhbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFRTcGFuRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVFNwYW5FbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsICh0aGlzIGluc3RhbmNlb2YgVFNwYW5FbGVtZW50ID8gdGhpcy5jb25zdHJ1Y3RvciA6IHZvaWQgMCkgPT09IFRTcGFuRWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ3RzcGFuJzsgLy8gaWYgdGhpcyBub2RlIGhhcyBjaGlsZHJlbiwgdGhlbiB0aGV5IG93biB0aGUgdGV4dFxuXG4gICAgX3RoaXMudGV4dCA9IF90aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnJyA6IF90aGlzLmdldFRleHRGcm9tTm9kZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVFNwYW5FbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRleHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUU3BhbkVsZW1lbnQ7XG59KFRleHRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJEMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkQygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkQygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBUZXh0Tm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RTcGFuRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFRleHROb2RlLCBfVFNwYW5FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJEMoVGV4dE5vZGUpO1xuXG4gIGZ1bmN0aW9uIFRleHROb2RlKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVGV4dE5vZGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3RleHROb2RlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gVGV4dE5vZGU7XG59KFRTcGFuRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRCKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgU1ZHRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVkRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFNWR0VsZW1lbnQsIF9SZW5kZXJlZEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkQihTVkdFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTVkdFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU1ZHRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnc3ZnJztcbiAgICBfdGhpcy5yb290ID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTVkdFbGVtZW50LCBbe1xuICAgIGtleTogXCJzZXRDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbnRleHQoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMkbm9kZSRwYXJlbnROb2RlO1xuXG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICAgICAgdmFyIHNjcmVlbiA9IGRvY3VtZW50LnNjcmVlbixcbiAgICAgICAgICB3aW5kb3cgPSBkb2N1bWVudC53aW5kb3c7XG4gICAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgIHNjcmVlbi5zZXREZWZhdWx0cyhjdHgpO1xuXG4gICAgICBpZiAoY2FudmFzLnN0eWxlICYmIHR5cGVvZiBjdHguZm9udCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHR5cGVvZiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY3R4LmZvbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICAgICAgdmFyIGZvbnRTaXplUHJvcCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShjdHguZm9udCkuZm9udFNpemUpO1xuXG4gICAgICAgIGlmIChmb250U2l6ZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIGRvY3VtZW50LnJvb3RFbVNpemUgPSBmb250U2l6ZVByb3AuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgICAgZG9jdW1lbnQuZW1TaXplID0gZG9jdW1lbnQucm9vdEVtU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxuXG5cbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5JywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfc2NyZWVuJHZpZXdQb3J0ID0gc2NyZWVuLnZpZXdQb3J0LFxuICAgICAgICAgIHdpZHRoID0gX3NjcmVlbiR2aWV3UG9ydC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBfc2NyZWVuJHZpZXdQb3J0LmhlaWdodDtcblxuICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRTdHlsZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZSgnMTAwJScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldFN0eWxlKCdjb2xvcicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRTdHlsZSgnY29sb3InLCB0cnVlKS5zZXRWYWx1ZSgnYmxhY2snKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZlhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlgnKTtcbiAgICAgIHZhciByZWZZQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJyk7XG4gICAgICB2YXIgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgdmFyIHZpZXdCb3ggPSB2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpID8gdG9OdW1iZXJzKHZpZXdCb3hBdHRyLmdldFN0cmluZygpKSA6IG51bGw7XG4gICAgICB2YXIgY2xpcCA9ICF0aGlzLnJvb3QgJiYgdGhpcy5nZXRTdHlsZSgnb3ZlcmZsb3cnKS5nZXRWYWx1ZSgnaGlkZGVuJykgIT09ICd2aXNpYmxlJztcbiAgICAgIHZhciBtaW5YID0gMDtcbiAgICAgIHZhciBtaW5ZID0gMDtcbiAgICAgIHZhciBjbGlwWCA9IDA7XG4gICAgICB2YXIgY2xpcFkgPSAwO1xuXG4gICAgICBpZiAodmlld0JveCkge1xuICAgICAgICBtaW5YID0gdmlld0JveFswXTtcbiAgICAgICAgbWluWSA9IHZpZXdCb3hbMV07XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcmtlcicpIHtcbiAgICAgICAgICBjbGlwWCA9IG1pblg7XG4gICAgICAgICAgY2xpcFkgPSBtaW5ZO1xuICAgICAgICAgIG1pblggPSAwO1xuICAgICAgICAgIG1pblkgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpOyAvLyBEZWZhdWx0IHZhbHVlIG9mIHRyYW5zZm9ybS1vcmlnaW4gaXMgY2VudGVyIG9ubHkgZm9yIHJvb3QgU1ZHIGVsZW1lbnRzXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3RyYW5zZm9ybS1vcmlnaW5cblxuICAgICAgaWYgKHRoaXMubm9kZSAvLyBpcyBub3QgdGVtcG9yYXJ5IFNWR0VsZW1lbnRcbiAgICAgICYmICghdGhpcy5wYXJlbnQgfHwgKChfdGhpcyRub2RlJHBhcmVudE5vZGUgPSB0aGlzLm5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX3RoaXMkbm9kZSRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRub2RlJHBhcmVudE5vZGUubm9kZU5hbWUpID09PSAnZm9yZWlnbk9iamVjdCcpICYmIHRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIHRydWUsIHRydWUpLnNldFZhbHVlKCc1MCUgNTAlJyk7XG4gICAgICB9XG5cbiAgICAgIF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oU1ZHRWxlbWVudC5wcm90b3R5cGUpLCBcInNldENvbnRleHRcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgpO1xuXG4gICAgICBjdHgudHJhbnNsYXRlKHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4JyksIHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5JykpO1xuXG4gICAgICBpZiAodmlld0JveCkge1xuICAgICAgICB3aWR0aCA9IHZpZXdCb3hbMl07XG4gICAgICAgIGhlaWdodCA9IHZpZXdCb3hbM107XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LnNldFZpZXdCb3goe1xuICAgICAgICBjdHg6IGN0eCxcbiAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgIHdpZHRoOiBzY3JlZW4udmlld1BvcnQud2lkdGgsXG4gICAgICAgIGRlc2lyZWRXaWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogc2NyZWVuLnZpZXdQb3J0LmhlaWdodCxcbiAgICAgICAgZGVzaXJlZEhlaWdodDogaGVpZ2h0LFxuICAgICAgICBtaW5YOiBtaW5YLFxuICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICByZWZYOiByZWZYQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgICByZWZZOiByZWZZQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgICBjbGlwOiBjbGlwLFxuICAgICAgICBjbGlwWDogY2xpcFgsXG4gICAgICAgIGNsaXBZOiBjbGlwWVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICAgIHNjcmVlbi52aWV3UG9ydC5yZW1vdmVDdXJyZW50KCk7XG4gICAgICAgIHNjcmVlbi52aWV3UG9ydC5zZXRDdXJyZW50KHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJDb250ZXh0KGN0eCkge1xuICAgICAgX2dldF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTVkdFbGVtZW50LnByb3RvdHlwZSksIFwiY2xlYXJDb250ZXh0XCIsIHRoaXMpLmNhbGwodGhpcywgY3R4KTtcblxuICAgICAgdGhpcy5kb2N1bWVudC5zY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSBTVkcgdG8gZml0IGluIGdpdmVuIHNpemUuXHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBwcmVzZXJ2ZUFzcGVjdFJhdGlvXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUod2lkdGgpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHdpZHRoO1xuICAgICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHdpZHRoQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcsIHRydWUpO1xuICAgICAgdmFyIGhlaWdodEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHJ1ZSk7XG4gICAgICB2YXIgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgdmFyIHN0eWxlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgdmFyIG9yaWdpbldpZHRoID0gd2lkdGhBdHRyLmdldE51bWJlcigwKTtcbiAgICAgIHZhciBvcmlnaW5IZWlnaHQgPSBoZWlnaHRBdHRyLmdldE51bWJlcigwKTtcblxuICAgICAgaWYgKHByZXNlcnZlQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVzZXJ2ZUFzcGVjdFJhdGlvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdHJ1ZSkuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW9BdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKTtcblxuICAgICAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5zZXRWYWx1ZShwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5nZXRTdHJpbmcoKS5yZXBsYWNlKC9eXFxzKihcXFMuKlxcUylcXHMqJC8sICckMScpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGhBdHRyLnNldFZhbHVlKHdpZHRoKTtcbiAgICAgIGhlaWdodEF0dHIuc2V0VmFsdWUoaGVpZ2h0KTtcblxuICAgICAgaWYgKCF2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZpZXdCb3hBdHRyLnNldFZhbHVlKFwiMCAwIFwiLmNvbmNhdChvcmlnaW5XaWR0aCB8fCB3aWR0aCwgXCIgXCIpLmNvbmNhdChvcmlnaW5IZWlnaHQgfHwgaGVpZ2h0KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJyk7XG4gICAgICAgIHZhciBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICB3aWR0aFN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgaGVpZ2h0U3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTVkdFbGVtZW50O1xufShSZW5kZXJlZEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkQShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRBKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRBKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFJlY3RFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShSZWN0RWxlbWVudCwgX1BhdGhFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJEEoUmVjdEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlY3RFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgUmVjdEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3JlY3QnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUmVjdEVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIGZhbHNlLCB0cnVlKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciByeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncngnKTtcbiAgICAgIHZhciByeUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKTtcbiAgICAgIHZhciByeCA9IHJ4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciByeSA9IHJ5QXR0ci5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKHJ4QXR0ci5oYXNWYWx1ZSgpICYmICFyeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICByeSA9IHJ4O1xuICAgICAgfVxuXG4gICAgICBpZiAocnlBdHRyLmhhc1ZhbHVlKCkgJiYgIXJ4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJ4ID0gcnk7XG4gICAgICB9XG5cbiAgICAgIHJ4ID0gTWF0aC5taW4ocngsIHdpZHRoIC8gMi4wKTtcbiAgICAgIHJ5ID0gTWF0aC5taW4ocnksIGhlaWdodCAvIDIuMCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgdmFyIEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpOyAvLyBhbHdheXMgc3RhcnQgdGhlIHBhdGggc28gd2UgZG9uJ3QgZmlsbCBwcmlvciBwYXRoc1xuXG4gICAgICAgIGlmIChoZWlnaHQgPiAwICYmIHdpZHRoID4gMCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIHJ4LCB5KTtcbiAgICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJ4LCB5KTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGggLSByeCArIEtBUFBBICogcngsIHksIHggKyB3aWR0aCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5ICsgS0FQUEEgKiByeSwgeCArIHdpZHRoIC0gcnggKyBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByeCwgeSArIGhlaWdodCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggKyByeCAtIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByeSArIEtBUFBBICogcnksIHgsIHkgKyBoZWlnaHQgLSByeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcnkpO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyByeCAtIEtBUFBBICogcngsIHksIHggKyByeCwgeSk7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXJrZXJzKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlY3RFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR6KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHooKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHooKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgQ2lyY2xlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BhdGhFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQ2lyY2xlRWxlbWVudCwgX1BhdGhFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHooQ2lyY2xlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQ2lyY2xlRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIENpcmNsZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2NpcmNsZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShDaXJjbGVFbGVtZW50LCBbe1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoY3R4KSB7XG4gICAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldFBpeGVscygneScpO1xuICAgICAgdmFyIHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuXG4gICAgICBpZiAoY3R4ICYmIHIgPiAwKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHIsIGN5IC0gciwgY3ggKyByLCBjeSArIHIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2lyY2xlRWxlbWVudDtcbn0oUGF0aEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkeShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR5KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR5KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEVsbGlwc2VFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShFbGxpcHNlRWxlbWVudCwgX1BhdGhFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHkoRWxsaXBzZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEVsbGlwc2VFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRWxsaXBzZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2VsbGlwc2UnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRWxsaXBzZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICB2YXIgcnggPSB0aGlzLmdldEF0dHJpYnV0ZSgncngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciByeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdyeScpLmdldFBpeGVscygneScpO1xuICAgICAgdmFyIGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgICAgaWYgKGN0eCAmJiByeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhjeCArIHJ4LCBjeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgcngsIGN5ICsgS0FQUEEgKiByeSwgY3ggKyBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCwgY3kgKyByeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gS0FQUEEgKiByeCwgY3kgKyByeSwgY3ggLSByeCwgY3kgKyBLQVBQQSAqIHJ5LCBjeCAtIHJ4LCBjeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggLSBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4ICsgS0FQUEEgKiByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgLSBLQVBQQSAqIHJ5LCBjeCArIHJ4LCBjeSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHJ4LCBjeSAtIHJ5LCBjeCArIHJ4LCBjeSArIHJ5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TWFya2Vyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXJrZXJzKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEVsbGlwc2VFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR4KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHgoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgTGluZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXRoRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKExpbmVFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkeChMaW5lRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gTGluZUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBMaW5lRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnbGluZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShMaW5lRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0UG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50cygpIHtcbiAgICAgIHJldHVybiBbbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKSksIG5ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5JykpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoKGN0eCkge1xuICAgICAgdmFyIF90aGlzJGdldFBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgX3RoaXMkZ2V0UG9pbnRzMiA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyRnZXRQb2ludHMsIDIpLFxuICAgICAgICAgIF90aGlzJGdldFBvaW50czIkID0gX3RoaXMkZ2V0UG9pbnRzMlswXSxcbiAgICAgICAgICB4MCA9IF90aGlzJGdldFBvaW50czIkLngsXG4gICAgICAgICAgeTAgPSBfdGhpcyRnZXRQb2ludHMyJC55LFxuICAgICAgICAgIF90aGlzJGdldFBvaW50czIkMiA9IF90aGlzJGdldFBvaW50czJbMV0sXG4gICAgICAgICAgeDEgPSBfdGhpcyRnZXRQb2ludHMyJDIueCxcbiAgICAgICAgICB5MSA9IF90aGlzJGdldFBvaW50czIkMi55O1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MCwgeTApO1xuICAgICAgICBjdHgubGluZVRvKHgxLCB5MSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0UG9pbnRzMyA9IHRoaXMuZ2V0UG9pbnRzKCksXG4gICAgICAgICAgX3RoaXMkZ2V0UG9pbnRzNCA9IF9zbGljZWRUb0FycmF5X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcyRnZXRQb2ludHMzLCAyKSxcbiAgICAgICAgICBwMCA9IF90aGlzJGdldFBvaW50czRbMF0sXG4gICAgICAgICAgcDEgPSBfdGhpcyRnZXRQb2ludHM0WzFdO1xuXG4gICAgICB2YXIgYSA9IHAwLmFuZ2xlVG8ocDEpO1xuICAgICAgcmV0dXJuIFtbcDAsIGFdLCBbcDEsIGFdXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZUVsZW1lbnQ7XG59KFBhdGhFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQb2x5bGluZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QYXRoRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvbHlsaW5lRWxlbWVudCwgX1BhdGhFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHcoUG9seWxpbmVFbGVtZW50KTtcblxuICBmdW5jdGlvbiBQb2x5bGluZUVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBvbHlsaW5lRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ3BvbHlsaW5lJztcbiAgICBfdGhpcy5wb2ludHMgPSBbXTtcbiAgICBfdGhpcy5wb2ludHMgPSBQb2ludC5wYXJzZVBhdGgoX3RoaXMuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5nZXRTdHJpbmcoKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQb2x5bGluZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuICAgICAgdmFyIF9wb2ludHMgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ocG9pbnRzLCAxKSxcbiAgICAgICAgICBfcG9pbnRzJCA9IF9wb2ludHNbMF0sXG4gICAgICAgICAgeDAgPSBfcG9pbnRzJC54LFxuICAgICAgICAgIHkwID0gX3BvaW50cyQueTtcblxuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgICB9XG5cbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB4ID0gX3JlZi54LFxuICAgICAgICAgICAgeSA9IF9yZWYueTtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkUG9pbnQoeCwgeSk7XG5cbiAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNYXJrZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1hcmtlcnMoKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICB2YXIgbGFzdEluZGV4ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50LCBpKSB7XG4gICAgICAgIGlmIChpID09PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJzLnB1c2goW3BvaW50LCBwb2ludC5hbmdsZVRvKHBvaW50c1tpICsgMV0pXSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBtYXJrZXJzLnB1c2goW3BvaW50c1twb2ludHMubGVuZ3RoIC0gMV0sIG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXVsxXV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFya2VycztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9seWxpbmVFbGVtZW50O1xufShQYXRoRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciR2KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHYoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgUG9seWdvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Qb2x5bGluZUVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQb2x5Z29uRWxlbWVudCwgX1BvbHlsaW5lRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciR2KFBvbHlnb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBQb2x5Z29uRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFBvbHlnb25FbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdwb2x5Z29uJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvbHlnb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoY3R4KSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBfZ2V0X19kZWZhdWx0W1wiZGVmYXVsdFwiXShfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFBvbHlnb25FbGVtZW50LnByb3RvdHlwZSksIFwicGF0aFwiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCk7XG5cbiAgICAgIHZhciBfdGhpcyRwb2ludHMgPSBfc2xpY2VkVG9BcnJheV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcy5wb2ludHMsIDEpLFxuICAgICAgICAgIF90aGlzJHBvaW50cyQgPSBfdGhpcyRwb2ludHNbMF0sXG4gICAgICAgICAgeCA9IF90aGlzJHBvaW50cyQueCxcbiAgICAgICAgICB5ID0gX3RoaXMkcG9pbnRzJC55O1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2x5Z29uRWxlbWVudDtcbn0oUG9seWxpbmVFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBQYXR0ZXJuRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQYXR0ZXJuRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkdShQYXR0ZXJuRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUGF0dGVybkVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBQYXR0ZXJuRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAncGF0dGVybic7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShQYXR0ZXJuRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlUGF0dGVyblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYXR0ZXJuKGN0eCwgXywgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4JywgdHJ1ZSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSk7IC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuXG4gICAgICB2YXIgcGF0dGVyblN2ZyA9IG5ldyBTVkdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIFwiXCIuY29uY2F0KHdpZHRoLCBcInB4XCIpKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2hlaWdodCcsIFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd0cmFuc2Zvcm0nLCB0aGlzLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB2YXIgcGF0dGVybkNhbnZhcyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgdmFyIHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkgJiYgeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBwYXR0ZXJuQ3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnLCB0cnVlKSwgeUF0dHIuZ2V0UGl4ZWxzKCd5JywgdHJ1ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLnN0eWxlc1snZmlsbC1vcGFjaXR5J10gPSBwYXJlbnRPcGFjaXR5UHJvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGhpcy5zdHlsZXMsICdmaWxsLW9wYWNpdHknKTtcbiAgICAgIH0gLy8gcmVuZGVyIDN4MyBncmlkIHNvIHdoZW4gd2UgdHJhbnNmb3JtIHRoZXJlJ3Mgbm8gd2hpdGUgc3BhY2Ugb24gZWRnZXNcblxuXG4gICAgICBmb3IgKHZhciB4ID0gLTE7IHggPD0gMTsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAtMTsgeSA8PSAxOyB5KyspIHtcbiAgICAgICAgICBwYXR0ZXJuQ3R4LnNhdmUoKTtcbiAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAneCcsIHggKiBwYXR0ZXJuQ2FudmFzLndpZHRoKTtcbiAgICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAneScsIHkgKiBwYXR0ZXJuQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgcGF0dGVyblN2Zy5yZW5kZXIocGF0dGVybkN0eCk7XG4gICAgICAgICAgcGF0dGVybkN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuQ2FudmFzLCAncmVwZWF0Jyk7XG4gICAgICByZXR1cm4gcGF0dGVybjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGF0dGVybkVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkdChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIE1hcmtlckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oTWFya2VyRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkdChNYXJrZXJFbGVtZW50KTtcblxuICBmdW5jdGlvbiBNYXJrZXJFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgTWFya2VyRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnbWFya2VyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1hcmtlckVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpIHtcbiAgICAgIGlmICghcG9pbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IHBvaW50LngsXG4gICAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgICB2YXIgb3JpZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ29yaWVudCcpLmdldFN0cmluZygnYXV0bycpO1xuICAgICAgdmFyIG1hcmtlclVuaXRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykuZ2V0U3RyaW5nKCdzdHJva2VXaWR0aCcpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgaWYgKG9yaWVudCA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgICAgY3R4LnNjYWxlKGN0eC5saW5lV2lkdGgsIGN0eC5saW5lV2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpOyAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnRcblxuICAgICAgdmFyIG1hcmtlclN2ZyA9IG5ldyBTVkdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgICAgbWFya2VyU3ZnLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnJlZlggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlgnLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpLmdldFZhbHVlKCkpO1xuICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMucmVmWSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAncmVmWScsIHRoaXMuZ2V0QXR0cmlidXRlKCdyZWZZJykuZ2V0VmFsdWUoKSk7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnd2lkdGgnLCB0aGlzLmdldEF0dHJpYnV0ZSgnbWFya2VyV2lkdGgnKS5nZXRWYWx1ZSgpKTtcbiAgICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLmdldFZhbHVlKCkpO1xuICAgICAgbWFya2VyU3ZnLmF0dHJpYnV0ZXMub3ZlcmZsb3cgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ292ZXJmbG93JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0VmFsdWUoKSk7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5maWxsID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdmaWxsJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKS5nZXRDb2xvcignYmxhY2snKSk7XG4gICAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5zdHJva2UgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHJva2UnKS5nZXRWYWx1ZSgnbm9uZScpKTtcbiAgICAgIG1hcmtlclN2Zy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICBtYXJrZXJTdmcucmVuZGVyKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAobWFya2VyVW5pdHMgPT09ICdzdHJva2VXaWR0aCcpIHtcbiAgICAgICAgY3R4LnNjYWxlKDEgLyBjdHgubGluZVdpZHRoLCAxIC8gY3R4LmxpbmVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcmllbnQgPT09ICdhdXRvJykge1xuICAgICAgICBjdHgucm90YXRlKC1hbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFya2VyRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRGVmc0VsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVmc0VsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHMoRGVmc0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIERlZnNFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRGVmc0VsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ2RlZnMnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVmc0VsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7Ly8gTk9PUFxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWZzRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgR0VsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlZEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShHRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRyKEdFbGVtZW50KTtcblxuICBmdW5jdGlvbiBHRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEdFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdnJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEdFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHRWxlbWVudDtcbn0oUmVuZGVyZWRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBHcmFkaWVudEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oR3JhZGllbnRFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRxKEdyYWRpZW50RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gR3JhZGllbnRFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBHcmFkaWVudEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMuYXR0cmlidXRlc1RvSW5oZXJpdCA9IFsnZ3JhZGllbnRVbml0cyddO1xuICAgIF90aGlzLnN0b3BzID0gW107XG5cbiAgICB2YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpLFxuICAgICAgICBzdG9wcyA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZS5zdG9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemUuY2hpbGRyZW47XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdzdG9wJykge1xuICAgICAgICBzdG9wcy5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEdyYWRpZW50RWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0R3JhZGllbnRVbml0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFkaWVudFVuaXRzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJykuZ2V0U3RyaW5nKCdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVHcmFkaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVHcmFkaWVudChjdHgsIGVsZW1lbnQsIHBhcmVudE9wYWNpdHlQcm9wKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcbiAgICAgIHZhciBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHN0b3BzQ29udGFpbmVyID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgICAgICB0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9zdG9wc0NvbnRhaW5lciA9IHN0b3BzQ29udGFpbmVyLFxuICAgICAgICAgIHN0b3BzID0gX3N0b3BzQ29udGFpbmVyLnN0b3BzO1xuICAgICAgdmFyIGdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWdyYWRpZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFBhcmVudE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3AsIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdLmNvbG9yKTtcbiAgICAgIH1cblxuICAgICAgc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIF90aGlzMi5hZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBzdG9wLmNvbG9yKSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgLy8gcmVuZGVyIGFzIHRyYW5zZm9ybWVkIHBhdHRlcm4gb24gdGVtcG9yYXJ5IGNhbnZhc1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICB2YXIgX2RvY3VtZW50JHNjcmVlbiA9IGRvY3VtZW50LnNjcmVlbixcbiAgICAgICAgICAgIE1BWF9WSVJUVUFMX1BJWEVMUyA9IF9kb2N1bWVudCRzY3JlZW4uTUFYX1ZJUlRVQUxfUElYRUxTLFxuICAgICAgICAgICAgdmlld1BvcnQgPSBfZG9jdW1lbnQkc2NyZWVuLnZpZXdQb3J0O1xuXG4gICAgICAgIHZhciBfdmlld1BvcnQkdmlld1BvcnRzID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHZpZXdQb3J0LnZpZXdQb3J0cywgMSksXG4gICAgICAgICAgICByb290VmlldyA9IF92aWV3UG9ydCR2aWV3UG9ydHNbMF07XG5cbiAgICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdEVsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgICByZWN0LmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3gnLCAtTUFYX1ZJUlRVQUxfUElYRUxTIC8gMy4wKTtcbiAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd5JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMuMCk7XG4gICAgICAgIHJlY3QuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgICAgcmVjdC5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIE1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICAgIHZhciBncm91cCA9IG5ldyBHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIGdyb3VwLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndHJhbnNmb3JtJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VHJhbnNmb3JtJykuZ2V0VmFsdWUoKSk7XG4gICAgICAgIGdyb3VwLmNoaWxkcmVuID0gW3JlY3RdO1xuICAgICAgICB2YXIgcGF0dGVyblN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd4JywgMCk7XG4gICAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy55ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneScsIDApO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd3aWR0aCcsIHJvb3RWaWV3LndpZHRoKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIHJvb3RWaWV3LmhlaWdodCk7XG4gICAgICAgIHBhdHRlcm5TdmcuY2hpbGRyZW4gPSBbZ3JvdXBdO1xuICAgICAgICB2YXIgcGF0dGVybkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyhyb290Vmlldy53aWR0aCwgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHBhdHRlcm5DdHggPSBwYXR0ZXJuQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgICByZXR1cm4gcGF0dGVybkN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm5DYW52YXMsICduby1yZXBlYXQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmhlcml0U3RvcENvbnRhaW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmhlcml0U3RvcENvbnRhaW5lcihzdG9wc0NvbnRhaW5lcikge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlc1RvSW5oZXJpdC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVUb0luaGVyaXQpIHtcbiAgICAgICAgaWYgKCFfdGhpczMuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSAmJiBzdG9wc0NvbnRhaW5lci5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlVG9Jbmhlcml0KS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgX3RoaXMzLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQsIHRydWUpLnNldFZhbHVlKHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmdldFZhbHVlKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGFyZW50T3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQYXJlbnRPcGFjaXR5KHBhcmVudE9wYWNpdHlQcm9wLCBjb2xvcikge1xuICAgICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIGNvbG9yUHJvcCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnY29sb3InLCBjb2xvcik7XG4gICAgICAgIHJldHVybiBjb2xvclByb3AuYWRkT3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCkuZ2V0Q29sb3IoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcmFkaWVudEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIExpbmVhckdyYWRpZW50RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyYWRpZW50RWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKExpbmVhckdyYWRpZW50RWxlbWVudCwgX0dyYWRpZW50RWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRwKExpbmVhckdyYWRpZW50RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gTGluZWFyR3JhZGllbnRFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBMaW5lYXJHcmFkaWVudEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdsaW5lYXJHcmFkaWVudCc7XG5cbiAgICBfdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ3gxJywgJ3kxJywgJ3gyJywgJ3kyJyk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKExpbmVhckdyYWRpZW50RWxlbWVudCwgW3tcbiAgICBrZXk6IFwiZ2V0R3JhZGllbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgICB2YXIgaXNCb3VuZGluZ0JveFVuaXRzID0gdGhpcy5nZXRHcmFkaWVudFVuaXRzKCkgPT09ICdvYmplY3RCb3VuZGluZ0JveCc7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCkgOiBudWxsO1xuXG4gICAgICBpZiAoaXNCb3VuZGluZ0JveFVuaXRzICYmICFib3VuZGluZ0JveCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5oYXNWYWx1ZSgpICYmICF0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MScsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJywgdHJ1ZSkuc2V0VmFsdWUoMSk7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicsIHRydWUpLnNldFZhbHVlKDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHkxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgeDIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIHkyID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmICh4MSA9PT0geDIgJiYgeTEgPT09IHkyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGluZWFyR3JhZGllbnRFbGVtZW50O1xufShHcmFkaWVudEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRvKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFJhZGlhbEdyYWRpZW50RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0dyYWRpZW50RWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFJhZGlhbEdyYWRpZW50RWxlbWVudCwgX0dyYWRpZW50RWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRvKFJhZGlhbEdyYWRpZW50RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUmFkaWFsR3JhZGllbnRFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBSYWRpYWxHcmFkaWVudEVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdyYWRpYWxHcmFkaWVudCc7XG5cbiAgICBfdGhpcy5hdHRyaWJ1dGVzVG9Jbmhlcml0LnB1c2goJ2N4JywgJ2N5JywgJ3InLCAnZngnLCAnZnknLCAnZnInKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oUmFkaWFsR3JhZGllbnRFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRHcmFkaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnY3knLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdyJywgdHJ1ZSkuc2V0VmFsdWUoJzUwJScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIGN5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgZnggPSBjeDtcbiAgICAgIHZhciBmeSA9IGN5O1xuXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuaGFzVmFsdWUoKSkge1xuICAgICAgICBmeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZnknKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGZ5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gaXNCb3VuZGluZ0JveFVuaXRzID8gKGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3guaGVpZ2h0KSAvIDIuMCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuICAgICAgdmFyIGZyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZyJykuZ2V0UGl4ZWxzKCk7XG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KGZ4LCBmeSwgZnIsIGN4LCBjeSwgcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhZGlhbEdyYWRpZW50RWxlbWVudDtcbn0oR3JhZGllbnRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG4oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTdG9wRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTdG9wRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbihTdG9wRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3RvcEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIFN0b3BFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnc3RvcCc7XG4gICAgdmFyIG9mZnNldCA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF90aGlzLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykuZ2V0TnVtYmVyKCkpKTtcblxuICAgIHZhciBzdG9wT3BhY2l0eSA9IF90aGlzLmdldFN0eWxlKCdzdG9wLW9wYWNpdHknKTtcblxuICAgIHZhciBzdG9wQ29sb3IgPSBfdGhpcy5nZXRTdHlsZSgnc3RvcC1jb2xvcicsIHRydWUpO1xuXG4gICAgaWYgKHN0b3BDb2xvci5nZXRTdHJpbmcoKSA9PT0gJycpIHtcbiAgICAgIHN0b3BDb2xvci5zZXRWYWx1ZSgnIzAwMCcpO1xuICAgIH1cblxuICAgIGlmIChzdG9wT3BhY2l0eS5oYXNWYWx1ZSgpKSB7XG4gICAgICBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eShzdG9wT3BhY2l0eSk7XG4gICAgfVxuXG4gICAgX3RoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIF90aGlzLmNvbG9yID0gc3RvcENvbG9yLmdldENvbG9yKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFN0b3BFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG0oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBBbmltYXRlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBbmltYXRlRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkbShBbmltYXRlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gQW5pbWF0ZUVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEFuaW1hdGVFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnYW5pbWF0ZSc7XG4gICAgX3RoaXMuZHVyYXRpb24gPSAwO1xuICAgIF90aGlzLmluaXRpYWxWYWx1ZSA9IG51bGw7XG4gICAgX3RoaXMuaW5pdGlhbFVuaXRzID0gJyc7XG4gICAgX3RoaXMucmVtb3ZlZCA9IGZhbHNlO1xuICAgIF90aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnNjcmVlbi5hbmltYXRpb25zLnB1c2goX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpKTtcbiAgICBfdGhpcy5iZWdpbiA9IF90aGlzLmdldEF0dHJpYnV0ZSgnYmVnaW4nKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICBfdGhpcy5tYXhEdXJhdGlvbiA9IF90aGlzLmJlZ2luICsgX3RoaXMuZ2V0QXR0cmlidXRlKCdkdXInKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICBfdGhpcy5mcm9tID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJyk7XG4gICAgX3RoaXMudG8gPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvJyk7XG4gICAgX3RoaXMudmFsdWVzID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmFsdWVzJywgbnVsbCk7XG5cbiAgICB2YXIgdmFsdWVzQXR0ciA9IF90aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJyk7XG5cbiAgICBpZiAodmFsdWVzQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBfdGhpcy52YWx1ZXMuc2V0VmFsdWUodmFsdWVzQXR0ci5nZXRTdHJpbmcoKS5zcGxpdCgnOycpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEFuaW1hdGVFbGVtZW50LCBbe1xuICAgIGtleTogXCJnZXRQcm9wZXJ0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVUeXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZVR5cGUnKS5nZXRTdHJpbmcoKTtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZU5hbWUnKS5nZXRTdHJpbmcoKTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZVR5cGUgPT09ICdDU1MnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRTdHlsZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNWYWx1ZSgpIHtcbiAgICAgIHZhciBpbml0aWFsVW5pdHMgPSB0aGlzLmluaXRpYWxVbml0cztcblxuICAgICAgdmFyIF90aGlzJGdldFByb2dyZXNzID0gdGhpcy5nZXRQcm9ncmVzcygpLFxuICAgICAgICAgIHByb2dyZXNzID0gX3RoaXMkZ2V0UHJvZ3Jlc3MucHJvZ3Jlc3MsXG4gICAgICAgICAgZnJvbSA9IF90aGlzJGdldFByb2dyZXNzLmZyb20sXG4gICAgICAgICAgdG8gPSBfdGhpcyRnZXRQcm9ncmVzcy50bzsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuXG4gICAgICB2YXIgbmV3VmFsdWUgPSBmcm9tLmdldE51bWJlcigpICsgKHRvLmdldE51bWJlcigpIC0gZnJvbS5nZXROdW1iZXIoKSkgKiBwcm9ncmVzcztcblxuICAgICAgaWYgKGluaXRpYWxVbml0cyA9PT0gJyUnKSB7XG4gICAgICAgIG5ld1ZhbHVlICo9IDEwMC4wOyAvLyBudW1WYWx1ZSgpIHJldHVybnMgMC0xIHdoZXJlYXMgcHJvcGVydGllcyBhcmUgMC0xMDBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5ld1ZhbHVlKS5jb25jYXQoaW5pdGlhbFVuaXRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShkZWx0YSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldFByb3BlcnR5KCk7IC8vIHNldCBpbml0aWFsIHZhbHVlXG5cbiAgICAgIGlmICghdGhpcy5pbml0aWFsVmFsdWUpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSBwcm9wLmdldFN0cmluZygpO1xuICAgICAgICB0aGlzLmluaXRpYWxVbml0cyA9IHByb3AuZ2V0VW5pdHMoKTtcbiAgICAgIH0gLy8gaWYgd2UncmUgcGFzdCB0aGUgZW5kIHRpbWVcblxuXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbiA+IHRoaXMubWF4RHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZmlsbCcpLmdldFN0cmluZygncmVtb3ZlJyk7IC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xuXG4gICAgICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0Q291bnQnKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdyZXBlYXREdXInKS5nZXRTdHJpbmcoKSA9PT0gJ2luZGVmaW5pdGUnKSB7XG4gICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XG4gICAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xuICAgICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW4gPSB0cnVlO1xuICAgICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ3JlbW92ZScgJiYgIXRoaXMucmVtb3ZlZCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgcHJvcC5zZXRWYWx1ZShwYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmR1cmF0aW9uICs9IGRlbHRhOyAvLyBpZiB3ZSdyZSBwYXN0IHRoZSBiZWdpbiB0aW1lXG5cbiAgICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLmJlZ2luIDwgdGhpcy5kdXJhdGlvbikge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGNWYWx1ZSgpOyAvLyB0d2VlblxuXG4gICAgICAgIHZhciB0eXBlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgICAgICAgaWYgKHR5cGVBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAvLyBmb3IgdHJhbnNmb3JtLCBldGMuXG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlQXR0ci5nZXRTdHJpbmcoKTtcbiAgICAgICAgICBuZXdWYWx1ZSA9IFwiXCIuY29uY2F0KHR5cGUsIFwiKFwiKS5jb25jYXQobmV3VmFsdWUsIFwiKVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3Auc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2dyZXNzKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHByb2dyZXNzOiAodGhpcy5kdXJhdGlvbiAtIHRoaXMuYmVnaW4pIC8gKHRoaXMubWF4RHVyYXRpb24gLSB0aGlzLmJlZ2luKVxuICAgICAgfTtcblxuICAgICAgaWYgKHZhbHVlcy5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBwID0gcmVzdWx0LnByb2dyZXNzICogKHZhbHVlcy5nZXRWYWx1ZSgpLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YXIgbGIgPSBNYXRoLmZsb29yKHApO1xuICAgICAgICB2YXIgdWIgPSBNYXRoLmNlaWwocCk7XG4gICAgICAgIHJlc3VsdC5mcm9tID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnZnJvbScsIHBhcnNlRmxvYXQodmFsdWVzLmdldFZhbHVlKClbbGJdKSk7XG4gICAgICAgIHJlc3VsdC50byA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3RvJywgcGFyc2VGbG9hdCh2YWx1ZXMuZ2V0VmFsdWUoKVt1Yl0pKTtcbiAgICAgICAgcmVzdWx0LnByb2dyZXNzID0gKHAgLSBsYikgLyAodWIgLSBsYik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgcmVzdWx0LnRvID0gdGhpcy50bztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5pbWF0ZUVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEFuaW1hdGVDb2xvckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRlRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEFuaW1hdGVDb2xvckVsZW1lbnQsIF9BbmltYXRlRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRsKEFuaW1hdGVDb2xvckVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEFuaW1hdGVDb2xvckVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBBbmltYXRlQ29sb3JFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdhbmltYXRlQ29sb3InO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQW5pbWF0ZUNvbG9yRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiY2FsY1ZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNWYWx1ZSgpIHtcbiAgICAgIHZhciBfdGhpcyRnZXRQcm9ncmVzcyA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKSxcbiAgICAgICAgICBwcm9ncmVzcyA9IF90aGlzJGdldFByb2dyZXNzLnByb2dyZXNzLFxuICAgICAgICAgIGZyb20gPSBfdGhpcyRnZXRQcm9ncmVzcy5mcm9tLFxuICAgICAgICAgIHRvID0gX3RoaXMkZ2V0UHJvZ3Jlc3MudG87XG5cbiAgICAgIHZhciBjb2xvckZyb20gPSBuZXcgUkdCQ29sb3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGZyb20uZ2V0Q29sb3IoKSk7XG4gICAgICB2YXIgY29sb3JUbyA9IG5ldyBSR0JDb2xvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odG8uZ2V0Q29sb3IoKSk7XG5cbiAgICAgIGlmIChjb2xvckZyb20ub2sgJiYgY29sb3JUby5vaykge1xuICAgICAgICAvLyB0d2VlbiBjb2xvciBsaW5lYXJseVxuICAgICAgICB2YXIgciA9IGNvbG9yRnJvbS5yICsgKGNvbG9yVG8uciAtIGNvbG9yRnJvbS5yKSAqIHByb2dyZXNzO1xuICAgICAgICB2YXIgZyA9IGNvbG9yRnJvbS5nICsgKGNvbG9yVG8uZyAtIGNvbG9yRnJvbS5nKSAqIHByb2dyZXNzO1xuICAgICAgICB2YXIgYiA9IGNvbG9yRnJvbS5iICsgKGNvbG9yVG8uYiAtIGNvbG9yRnJvbS5iKSAqIHByb2dyZXNzOyAvLyA/IGFscGhhXG5cbiAgICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdChNYXRoLmZsb29yKHIpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGcpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGIpLCBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZnJvbScpLmdldENvbG9yKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFuaW1hdGVDb2xvckVsZW1lbnQ7XG59KEFuaW1hdGVFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGsoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGVFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsIF9BbmltYXRlRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRrKEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50KTtcblxuICBmdW5jdGlvbiBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdhbmltYXRlVHJhbnNmb3JtJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LCBbe1xuICAgIGtleTogXCJjYWxjVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY1ZhbHVlKCkge1xuICAgICAgdmFyIF90aGlzJGdldFByb2dyZXNzID0gdGhpcy5nZXRQcm9ncmVzcygpLFxuICAgICAgICAgIHByb2dyZXNzID0gX3RoaXMkZ2V0UHJvZ3Jlc3MucHJvZ3Jlc3MsXG4gICAgICAgICAgZnJvbSA9IF90aGlzJGdldFByb2dyZXNzLmZyb20sXG4gICAgICAgICAgdG8gPSBfdGhpcyRnZXRQcm9ncmVzcy50bzsgLy8gdHdlZW4gdmFsdWUgbGluZWFybHlcblxuXG4gICAgICB2YXIgdHJhbnNmb3JtRnJvbSA9IHRvTnVtYmVycyhmcm9tLmdldFN0cmluZygpKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1UbyA9IHRvTnVtYmVycyh0by5nZXRTdHJpbmcoKSk7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0cmFuc2Zvcm1Gcm9tLm1hcChmdW5jdGlvbiAoZnJvbSwgaSkge1xuICAgICAgICB2YXIgdG8gPSB0cmFuc2Zvcm1Ub1tpXTtcbiAgICAgICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xuICAgICAgfSkuam9pbignICcpO1xuICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbmltYXRlVHJhbnNmb3JtRWxlbWVudDtcbn0oQW5pbWF0ZUVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQxKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxKG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDEoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRqKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRm9udEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRm9udEVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGooRm9udEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZvbnRFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBGb250RWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ2ZvbnQnO1xuICAgIF90aGlzLmdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgX3RoaXMuaG9yaXpBZHZYID0gX3RoaXMuZ2V0QXR0cmlidXRlKCdob3Jpei1hZHYteCcpLmdldE51bWJlcigpO1xuICAgIHZhciBkZWZpbml0aW9ucyA9IGRvY3VtZW50LmRlZmluaXRpb25zO1xuXG4gICAgdmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZSA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF90aGlzKSxcbiAgICAgICAgY2hpbGRyZW4gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemUuY2hpbGRyZW47XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShjaGlsZHJlbiksXG4gICAgICAgIF9zdGVwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHN3aXRjaCAoY2hpbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF90aGlzLmZvbnRGYWNlID0gY2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBmb250RmFtaWx5U3R5bGUgPSBjaGlsZC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKTtcblxuICAgICAgICAgICAgICBpZiAoZm9udEZhbWlseVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uc1tmb250RmFtaWx5U3R5bGUuZ2V0U3RyaW5nKCldID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZF9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgICAgICAgIF90aGlzLm1pc3NpbmdHbHlwaCA9IGNoaWxkO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdnbHlwaCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBnbHlwaCA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgIGlmIChnbHlwaC5hcmFiaWNGb3JtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNSVEwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmlzQXJhYmljID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV1bZ2x5cGguYXJhYmljRm9ybV0gPSBnbHlwaDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPSBnbHlwaDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZvbnRFbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkgey8vIE5PIFJFTkRFUlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb250RWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRpKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRm9udEZhY2VFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZvbnRGYWNlRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaShGb250RmFjZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZvbnRGYWNlRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRm9udEZhY2VFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZm9udC1mYWNlJztcbiAgICBfdGhpcy5hc2NlbnQgPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ2FzY2VudCcpLmdldE51bWJlcigpO1xuICAgIF90aGlzLmRlc2NlbnQgPSBfdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rlc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICBfdGhpcy51bml0c1BlckVtID0gX3RoaXMuZ2V0QXR0cmlidXRlKCd1bml0cy1wZXItZW0nKS5nZXROdW1iZXIoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRm9udEZhY2VFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBNaXNzaW5nR2x5cGhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUGF0aEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShNaXNzaW5nR2x5cGhFbGVtZW50LCBfUGF0aEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaChNaXNzaW5nR2x5cGhFbGVtZW50KTtcblxuICBmdW5jdGlvbiBNaXNzaW5nR2x5cGhFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgTWlzc2luZ0dseXBoRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnbWlzc2luZy1nbHlwaCc7XG4gICAgX3RoaXMuaG9yaXpBZHZYID0gMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gTWlzc2luZ0dseXBoRWxlbWVudDtcbn0oUGF0aEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFRSZWZFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUUmVmRWxlbWVudCwgX1RleHRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGcoVFJlZkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFRSZWZFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVFJlZkVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBfdGhpcy50eXBlID0gJ3RyZWYnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVFJlZkVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGVsZW1lbnQuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICByZXR1cm4gZmlyc3RDaGlsZC5nZXRUZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUUmVmRWxlbWVudDtcbn0oVGV4dEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEFFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVGV4dEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShBRWxlbWVudCwgX1RleHRFbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGYoQUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEFFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBBRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ2EnO1xuICAgIHZhciBjaGlsZE5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgIHZhciBmaXJzdENoaWxkID0gY2hpbGROb2Rlc1swXTtcbiAgICB2YXIgaGFzVGV4dCA9IGNoaWxkTm9kZXMubGVuZ3RoID4gMCAmJiBBcnJheS5mcm9tKGNoaWxkTm9kZXMpLmV2ZXJ5KGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMztcbiAgICB9KTtcbiAgICBfdGhpcy5oYXNUZXh0ID0gaGFzVGV4dDtcbiAgICBfdGhpcy50ZXh0ID0gaGFzVGV4dCA/IF90aGlzLmdldFRleHRGcm9tTm9kZShmaXJzdENoaWxkKSA6ICcnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgaWYgKHRoaXMuaGFzVGV4dCkge1xuICAgICAgICAvLyByZW5kZXIgYXMgdGV4dCBlbGVtZW50XG4gICAgICAgIF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oQUVsZW1lbnQucHJvdG90eXBlKSwgXCJyZW5kZXJDaGlsZHJlblwiLCB0aGlzKS5jYWxsKHRoaXMsIGN0eCk7XG5cbiAgICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgIHggPSB0aGlzLngsXG4gICAgICAgICAgICB5ID0gdGhpcy55O1xuICAgICAgICB2YXIgbW91c2UgPSBkb2N1bWVudC5zY3JlZW4ubW91c2U7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2ZvbnRTaXplJywgRm9udC5wYXJzZShkb2N1bWVudC5jdHguZm9udCkuZm9udFNpemUpOyAvLyBEbyBub3QgY2FsYyBib3VuZGluZyBib3ggaWYgbW91c2UgaXMgbm90IHdvcmtpbmcuXG5cbiAgICAgICAgaWYgKG1vdXNlLmlzV29ya2luZygpKSB7XG4gICAgICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLmdldFBpeGVscygneScpLCB4ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB5KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIHJlbmRlciBhcyB0ZW1wb3JhcnkgZ3JvdXBcbiAgICAgICAgdmFyIGcgPSBuZXcgR0VsZW1lbnQodGhpcy5kb2N1bWVudCwgbnVsbCk7XG4gICAgICAgIGcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIGcucmVuZGVyKGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljaygpIHtcbiAgICAgIHZhciB3aW5kb3cgPSB0aGlzLmRvY3VtZW50LndpbmRvdztcblxuICAgICAgaWYgKHdpbmRvdykge1xuICAgICAgICB3aW5kb3cub3Blbih0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uTW91c2VNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZG9jdW1lbnQuY3R4O1xuICAgICAgY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFFbGVtZW50O1xufShUZXh0RWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkZShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIFRleHRQYXRoRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1RleHRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVGV4dFBhdGhFbGVtZW50LCBfVGV4dEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZShUZXh0UGF0aEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFRleHRQYXRoRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVGV4dFBhdGhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAndGV4dFBhdGgnO1xuICAgIF90aGlzLnRleHRXaWR0aCA9IDA7XG4gICAgX3RoaXMudGV4dEhlaWdodCA9IDA7XG4gICAgX3RoaXMucGF0aExlbmd0aCA9IC0xO1xuICAgIF90aGlzLmdseXBoSW5mbyA9IG51bGw7XG4gICAgX3RoaXMubGV0dGVyU3BhY2luZ0NhY2hlID0gW107XG4gICAgX3RoaXMubWVhc3VyZXNDYWNoZSA9IG5ldyBNYXAoW1snJywgMF1dKTtcblxuICAgIHZhciBwYXRoRWxlbWVudCA9IF90aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBfdGhpcy50ZXh0ID0gX3RoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gICAgX3RoaXMuZGF0YUFycmF5ID0gX3RoaXMucGFyc2VQYXRoRGF0YShwYXRoRWxlbWVudCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShUZXh0UGF0aEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImdldFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aChjdHgpIHtcbiAgICAgIHZhciBkYXRhQXJyYXkgPSB0aGlzLmRhdGFBcnJheTtcblxuICAgICAgaWYgKGN0eCkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgICAgICAgcG9pbnRzID0gX3JlZi5wb2ludHM7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfcG9pbnRzID0gX3NsaWNlZFRvQXJyYXlfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHBvaW50cywgOCksXG4gICAgICAgICAgICAgICAgICBjeCA9IF9wb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICBjeSA9IF9wb2ludHNbMV0sXG4gICAgICAgICAgICAgICAgICByeCA9IF9wb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgICByeSA9IF9wb2ludHNbM10sXG4gICAgICAgICAgICAgICAgICB0aGV0YSA9IF9wb2ludHNbNF0sXG4gICAgICAgICAgICAgICAgICBkVGhldGEgPSBfcG9pbnRzWzVdLFxuICAgICAgICAgICAgICAgICAgcHNpID0gX3BvaW50c1s2XSxcbiAgICAgICAgICAgICAgICAgIGZzID0gX3BvaW50c1s3XTtcblxuICAgICAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICAgICAgY3R4LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIEJvb2xlYW4oMSAtIGZzKSk7XG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQ2hpbGRyZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgICB0aGlzLnNldFRleHREYXRhKGN0eCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtZGVjb3JhdGlvbicpLmdldFN0cmluZygpO1xuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgdmFyIGZpbGwgPSBjdHguZmlsbFN0eWxlO1xuXG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgZ2x5cGhJbmZvLmZvckVhY2goZnVuY3Rpb24gKGdseXBoLCBpKSB7XG4gICAgICAgIHZhciBwMCA9IGdseXBoLnAwLFxuICAgICAgICAgICAgcDEgPSBnbHlwaC5wMSxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gZ2x5cGgucm90YXRpb24sXG4gICAgICAgICAgICBwYXJ0aWFsVGV4dCA9IGdseXBoLnRleHQ7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUocDAueCwgcDAueSk7XG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuXG4gICAgICAgIGlmIChjdHguZmlsbFN0eWxlKSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlVGV4dChwYXJ0aWFsVGV4dCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwMC54LCBwMC55ICsgZm9udFNpemUgLyA4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkgKyBmb250U2l6ZSAvIDUpO1xuICAgICAgICB9IC8vIC8vIFRvIGFzc2lzdCB3aXRoIGRlYnVnZ2luZyB2aXN1YWxseSwgdW5jb21tZW50IGZvbGxvd2luZ1xuICAgICAgICAvL1xuICAgICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vIGlmIChpICUgMilcbiAgICAgICAgLy8gXHRjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyBcdGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgICAgIC8vIGN0eC5tb3ZlVG8ocDAueCwgcDAueSk7XG4gICAgICAgIC8vIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgICAgLy8gY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gZm9udFNpemUgLyAyMDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExldHRlclNwYWNpbmdBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZXR0ZXJTcGFjaW5nQXQoKSB7XG4gICAgICB2YXIgaWR4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgICAgcmV0dXJuIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlW2lkeF0gfHwgMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFNlZ21lbnRUb0ZpdENoYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFNlZ21lbnRUb0ZpdENoYXIoY3R4LCBhbmNob3IsIHRleHRGdWxsV2lkdGgsIGZ1bGxQYXRoV2lkdGgsIHNwYWNlc051bWJlciwgaW5wdXRPZmZzZXQsIGR5LCBjLCBjaGFySSkge1xuICAgICAgdmFyIG9mZnNldCA9IGlucHV0T2Zmc2V0O1xuICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCwgYyk7XG5cbiAgICAgIGlmIChjID09PSAnICcgJiYgYW5jaG9yID09PSAnanVzdGlmeScgJiYgdGV4dEZ1bGxXaWR0aCA8IGZ1bGxQYXRoV2lkdGgpIHtcbiAgICAgICAgZ2x5cGhXaWR0aCArPSAoZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpIC8gc3BhY2VzTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhckkgPiAtMSkge1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nQXQoY2hhckkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3BsaW5lU3RlcCA9IHRoaXMudGV4dEhlaWdodCAvIDIwO1xuICAgICAgdmFyIHAwID0gdGhpcy5nZXRFcXVpZGlzdGFudFBvaW50T25QYXRoKG9mZnNldCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgICB2YXIgcDEgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0ICsgZ2x5cGhXaWR0aCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgICB2YXIgc2VnbWVudCA9IHtcbiAgICAgICAgcDA6IHAwLFxuICAgICAgICBwMTogcDFcbiAgICAgIH07XG4gICAgICB2YXIgcm90YXRpb24gPSBwMCAmJiBwMSA/IE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSA6IDA7XG5cbiAgICAgIGlmIChkeSkge1xuICAgICAgICB2YXIgZHlYID0gTWF0aC5jb3MoTWF0aC5QSSAvIDIgKyByb3RhdGlvbikgKiBkeTtcbiAgICAgICAgdmFyIGR5WSA9IE1hdGguY29zKC1yb3RhdGlvbikgKiBkeTtcbiAgICAgICAgc2VnbWVudC5wMCA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIHAwKSwge30sIHtcbiAgICAgICAgICB4OiBwMC54ICsgZHlYLFxuICAgICAgICAgIHk6IHAwLnkgKyBkeVlcbiAgICAgICAgfSk7XG4gICAgICAgIHNlZ21lbnQucDEgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwMSksIHt9LCB7XG4gICAgICAgICAgeDogcDEueCArIGR5WCxcbiAgICAgICAgICB5OiBwMS55ICsgZHlZXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gZ2x5cGhXaWR0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzZWdtZW50OiBzZWdtZW50LFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1lYXN1cmVUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGN0eCwgdGV4dCkge1xuICAgICAgdmFyIG1lYXN1cmVzQ2FjaGUgPSB0aGlzLm1lYXN1cmVzQ2FjaGU7XG4gICAgICB2YXIgdGFyZ2V0VGV4dCA9IHRleHQgfHwgdGhpcy5nZXRUZXh0KCk7XG5cbiAgICAgIGlmIChtZWFzdXJlc0NhY2hlLmhhcyh0YXJnZXRUZXh0KSkge1xuICAgICAgICByZXR1cm4gbWVhc3VyZXNDYWNoZS5nZXQodGFyZ2V0VGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpO1xuICAgICAgbWVhc3VyZXNDYWNoZS5zZXQodGFyZ2V0VGV4dCwgbWVhc3VyZSk7XG4gICAgICByZXR1cm4gbWVhc3VyZTtcbiAgICB9IC8vIFRoaXMgbWV0aG9kIHN1cHBvc2VzIHdoYXQgYWxsIGN1c3RvbSBmb250cyBhbHJlYWR5IGxvYWRlZC5cbiAgICAvLyBJZiBzb21lIGZvbnQgd2lsbCBiZSBsb2FkZWQgYWZ0ZXIgdGhpcyBtZXRob2QgY2FsbCwgPHRleHRQYXRoPiB3aWxsIG5vdCBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXG4gICAgLy8gWW91IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBtYW51YWxseSB0byB1cGRhdGUgZ2x5cGhzIGNhY2hlLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGV4dERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGV4dERhdGEoY3R4KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZ2x5cGhJbmZvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICAgIHZhciBjaGFycyA9IHJlbmRlclRleHQuc3BsaXQoJycpO1xuICAgICAgdmFyIHNwYWNlc051bWJlciA9IHJlbmRlclRleHQuc3BsaXQoJyAnKS5sZW5ndGggLSAxO1xuICAgICAgdmFyIGR4ID0gdGhpcy5wYXJlbnQuZ2V0QXR0cmlidXRlKCdkeCcpLnNwbGl0KCkubWFwKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBfLmdldFBpeGVscygneCcpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZHkgPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgYW5jaG9yID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ3RleHQtYW5jaG9yJykuZ2V0U3RyaW5nKCdzdGFydCcpO1xuICAgICAgdmFyIHRoaXNTcGFjaW5nID0gdGhpcy5nZXRTdHlsZSgnbGV0dGVyLXNwYWNpbmcnKTtcbiAgICAgIHZhciBwYXJlbnRTcGFjaW5nID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAgIGlmICghdGhpc1NwYWNpbmcuaGFzVmFsdWUoKSB8fCB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgbGV0dGVyU3BhY2luZyA9IHBhcmVudFNwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNTcGFjaW5nLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaWYgKHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICdpbml0aWFsJyAmJiB0aGlzU3BhY2luZy5nZXRWYWx1ZSgpICE9PSAndW5zZXQnKSB7XG4gICAgICAgICAgbGV0dGVyU3BhY2luZyA9IHRoaXNTcGFjaW5nLmdldFBpeGVscygpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZpbGwgbGV0dGVyLXNwYWNpbmcgY2FjaGVcblxuXG4gICAgICB2YXIgbGV0dGVyU3BhY2luZ0NhY2hlID0gW107XG4gICAgICB2YXIgdGV4dExlbiA9IHJlbmRlclRleHQubGVuZ3RoO1xuICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nQ2FjaGUgPSBsZXR0ZXJTcGFjaW5nQ2FjaGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExlbjsgaSsrKSB7XG4gICAgICAgIGxldHRlclNwYWNpbmdDYWNoZS5wdXNoKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgPyBkeFtpXSA6IGxldHRlclNwYWNpbmcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHhTdW0gPSBsZXR0ZXJTcGFjaW5nQ2FjaGUucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1ciwgaSkge1xuICAgICAgICByZXR1cm4gaSA9PT0gMCA/IDAgOiBhY2MgKyBjdXIgfHwgMDtcbiAgICAgIH0sIDApO1xuICAgICAgdmFyIHRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICAgIHZhciB0ZXh0RnVsbFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoICsgZHhTdW0sIDApO1xuICAgICAgdGhpcy50ZXh0V2lkdGggPSB0ZXh0V2lkdGg7XG4gICAgICB0aGlzLnRleHRIZWlnaHQgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgICB0aGlzLmdseXBoSW5mbyA9IFtdO1xuICAgICAgdmFyIGZ1bGxQYXRoV2lkdGggPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMuZ2V0U3R5bGUoJ3N0YXJ0T2Zmc2V0JykuZ2V0TnVtYmVyKDApICogZnVsbFBhdGhXaWR0aDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBpZiAoYW5jaG9yID09PSAnbWlkZGxlJyB8fCBhbmNob3IgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuY2hvciA9PT0gJ2VuZCcgfHwgYW5jaG9yID09PSAncmlnaHQnKSB7XG4gICAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgKz0gc3RhcnRPZmZzZXQ7XG4gICAgICBjaGFycy5mb3JFYWNoKGZ1bmN0aW9uIChjaGFyLCBpKSB7XG4gICAgICAgIC8vIEZpbmQgc3VjaCBzZWdtZW50IHdoYXQgZGlzdGFuY2UgYmV0d2VlbiBwMCBhbmQgcDEgaXMgYXBwcm94LiB3aWR0aCBvZiBnbHlwaFxuICAgICAgICB2YXIgX3RoaXMyJGZpbmRTZWdtZW50VG9GID0gX3RoaXMyLmZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIG9mZnNldCwgZHksIGNoYXIsIGkpLFxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IF90aGlzMiRmaW5kU2VnbWVudFRvRi5vZmZzZXQsXG4gICAgICAgICAgICBzZWdtZW50ID0gX3RoaXMyJGZpbmRTZWdtZW50VG9GLnNlZ21lbnQsXG4gICAgICAgICAgICByb3RhdGlvbiA9IF90aGlzMiRmaW5kU2VnbWVudFRvRi5yb3RhdGlvbjtcblxuICAgICAgICBvZmZzZXQgPSBuZXh0T2Zmc2V0O1xuXG4gICAgICAgIGlmICghc2VnbWVudC5wMCB8fCAhc2VnbWVudC5wMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0TGluZUxlbmd0aChcbiAgICAgICAgLy8gXHRzZWdtZW50LnAwLngsXG4gICAgICAgIC8vIFx0c2VnbWVudC5wMC55LFxuICAgICAgICAvLyBcdHNlZ21lbnQucDEueCxcbiAgICAgICAgLy8gXHRzZWdtZW50LnAxLnlcbiAgICAgICAgLy8gKTtcbiAgICAgICAgLy8gTm90ZTogU2luY2UgZ2x5cGhzIGFyZSByZW5kZXJlZCBvbmUgYXQgYSB0aW1lLCBhbnkga2VybmluZyBwYWlyIGRhdGEgYnVpbHQgaW50byB0aGUgZm9udCB3aWxsIG5vdCBiZSB1c2VkLlxuICAgICAgICAvLyBDYW4gZm9yZXNlZSBoYXZpbmcgYSByb3VnaCBwYWlyIHRhYmxlIGJ1aWx0IGluIHRoYXQgdGhlIGRldmVsb3BlciBjYW4gb3ZlcnJpZGUgYXMgbmVlZGVkLlxuICAgICAgICAvLyBPciB1c2UgXCJkeFwiIGF0dHJpYnV0ZSBvZiB0aGUgPHRleHQ+IG5vZGUgYXMgYSBuYWl2ZSByZXBsYWNlbWVudFxuICAgICAgICAvLyBjb25zdCBrZXJuID0gMDtcbiAgICAgICAgLy8gcGxhY2Vob2xkZXIgZm9yIGZ1dHVyZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAvLyBjb25zdCBtaWRwb2ludCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAgIC8vIFx0a2VybiArIHdpZHRoIC8gMi4wLFxuICAgICAgICAvLyBcdHNlZ21lbnQucDAueCwgc2VnbWVudC5wMC55LCBzZWdtZW50LnAxLngsIHNlZ21lbnQucDEueVxuICAgICAgICAvLyApO1xuXG5cbiAgICAgICAgX3RoaXMyLmdseXBoSW5mby5wdXNoKHtcbiAgICAgICAgICAvLyB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAgIC8vIHRyYW5zcG9zZVk6IG1pZHBvaW50LnksXG4gICAgICAgICAgdGV4dDogY2hhcnNbaV0sXG4gICAgICAgICAgcDA6IHNlZ21lbnQucDAsXG4gICAgICAgICAgcDE6IHNlZ21lbnQucDEsXG4gICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlUGF0aERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VQYXRoRGF0YShwYXRoKSB7XG4gICAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTsgLy8gcmVzZXQgcGF0aCBsZW5ndGhcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhdGhDb21tYW5kcyA9IFtdO1xuICAgICAgdmFyIHBhdGhQYXJzZXIgPSBwYXRoLnBhdGhQYXJzZXI7XG4gICAgICBwYXRoUGFyc2VyLnJlc2V0KCk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHBhdGhQYXJzZXIuY3VycmVudDtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGN1cnJlbnQgPyBjdXJyZW50LnggOiAwO1xuICAgICAgICB2YXIgc3RhcnRZID0gY3VycmVudCA/IGN1cnJlbnQueSA6IDA7XG4gICAgICAgIHZhciBjb21tYW5kID0gcGF0aFBhcnNlci5uZXh0KCk7XG4gICAgICAgIHZhciBuZXh0Q29tbWFuZFR5cGUgPSBjb21tYW5kLnR5cGU7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5NT1ZFX1RPOlxuICAgICAgICAgICAgdGhpcy5wYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aEwocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkhPUklaX0xJTkVfVE86XG4gICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5WRVJUX0xJTkVfVE86XG4gICAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAgIHRoaXMucGF0aEMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9DVVJWRV9UTzpcbiAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICB0aGlzLnBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMucGF0aEEocGF0aFBhcnNlcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoocGF0aFBhcnNlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21tYW5kLnR5cGUgIT09IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCkge1xuICAgICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IG5leHRDb21tYW5kVHlwZSxcbiAgICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIG5leHRDb21tYW5kVHlwZSwgcG9pbnRzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCxcbiAgICAgICAgICAgIHBvaW50czogW10sXG4gICAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGhDb21tYW5kcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aE1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aE0ocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhNJHBvID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcikucG9pbnQsXG4gICAgICAgICAgeCA9IF9QYXRoRWxlbWVudCRwYXRoTSRwby54LFxuICAgICAgICAgIHkgPSBfUGF0aEVsZW1lbnQkcGF0aE0kcG8ueTtcbiAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aEwkcG8gPSBQYXRoRWxlbWVudC5wYXRoTChwYXRoUGFyc2VyKS5wb2ludCxcbiAgICAgICAgICB4ID0gX1BhdGhFbGVtZW50JHBhdGhMJHBvLngsXG4gICAgICAgICAgeSA9IF9QYXRoRWxlbWVudCRwYXRoTCRwby55O1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoSFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoSChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aEgkcG8gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKS5wb2ludCxcbiAgICAgICAgICB4ID0gX1BhdGhFbGVtZW50JHBhdGhIJHBvLngsXG4gICAgICAgICAgeSA9IF9QYXRoRWxlbWVudCRwYXRoSCRwby55O1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoVlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoVihwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aFYkcG8gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKS5wb2ludCxcbiAgICAgICAgICB4ID0gX1BhdGhFbGVtZW50JHBhdGhWJHBvLngsXG4gICAgICAgICAgeSA9IF9QYXRoRWxlbWVudCRwYXRoViRwby55O1xuICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoQ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICAgIHZhciBfUGF0aEVsZW1lbnQkcGF0aEMgPSBQYXRoRWxlbWVudC5wYXRoQyhwYXRoUGFyc2VyKSxcbiAgICAgICAgICBwb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5wb2ludCxcbiAgICAgICAgICBjb250cm9sUG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aEMuY29udHJvbFBvaW50LFxuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoQy5jdXJyZW50UG9pbnQ7XG5cbiAgICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhTID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlciksXG4gICAgICAgICAgcG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMucG9pbnQsXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhTLmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFMuY3VycmVudFBvaW50O1xuXG4gICAgICBwb2ludHMucHVzaChwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgICByZXR1cm4gUGF0aFBhcnNlci5DVVJWRV9UTztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aFFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aFEocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgICB2YXIgX1BhdGhFbGVtZW50JHBhdGhRID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlciksXG4gICAgICAgICAgY29udHJvbFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhRLmNvbnRyb2xQb2ludCxcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBfUGF0aEVsZW1lbnQkcGF0aFEuY3VycmVudFBvaW50O1xuXG4gICAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhdGhUXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGhUKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoVCA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIGNvbnRyb2xQb2ludCA9IF9QYXRoRWxlbWVudCRwYXRoVC5jb250cm9sUG9pbnQsXG4gICAgICAgICAgY3VycmVudFBvaW50ID0gX1BhdGhFbGVtZW50JHBhdGhULmN1cnJlbnRQb2ludDtcblxuICAgICAgcG9pbnRzLnB1c2goY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgICAgcmV0dXJuIFBhdGhQYXJzZXIuUVVBRF9UTztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0aEFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0aEEocGF0aFBhcnNlcikge1xuICAgICAgdmFyIF9QYXRoRWxlbWVudCRwYXRoQSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpLFxuICAgICAgICAgIHJYID0gX1BhdGhFbGVtZW50JHBhdGhBLnJYLFxuICAgICAgICAgIHJZID0gX1BhdGhFbGVtZW50JHBhdGhBLnJZLFxuICAgICAgICAgIHN3ZWVwRmxhZyA9IF9QYXRoRWxlbWVudCRwYXRoQS5zd2VlcEZsYWcsXG4gICAgICAgICAgeEF4aXNSb3RhdGlvbiA9IF9QYXRoRWxlbWVudCRwYXRoQS54QXhpc1JvdGF0aW9uLFxuICAgICAgICAgIGNlbnRwID0gX1BhdGhFbGVtZW50JHBhdGhBLmNlbnRwLFxuICAgICAgICAgIGExID0gX1BhdGhFbGVtZW50JHBhdGhBLmExLFxuICAgICAgICAgIGFkID0gX1BhdGhFbGVtZW50JHBhdGhBLmFkO1xuXG4gICAgICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFkID4gMCkge1xuICAgICAgICBhZCAtPSAyICogTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhZCA8IDApIHtcbiAgICAgICAgYWQgKz0gMiAqIE1hdGguUEk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbY2VudHAueCwgY2VudHAueSwgclgsIHJZLCBhMSwgYWQsIHhBeGlzUm90YXRpb24sIHN3ZWVwRmxhZ107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGNMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY0xlbmd0aCh4LCB5LCBjb21tYW5kVHlwZSwgcG9pbnRzKSB7XG4gICAgICB2YXIgbGVuID0gMDtcbiAgICAgIHZhciBwMSA9IG51bGw7XG4gICAgICB2YXIgcDIgPSBudWxsO1xuICAgICAgdmFyIHQgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGNvbW1hbmRUeXBlKSB7XG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byAxMDAgbGluZSBzZWdtZW50c1xuICAgICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgICBwMSA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuXG4gICAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbGVuO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5RVUFEX1RPOlxuICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKDAsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG5cbiAgICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBsZW47XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBBcHByb3hpbWF0ZXMgYnkgYnJlYWtpbmcgY3VydmUgaW50byBsaW5lIHNlZ21lbnRzXG4gICAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludHNbNF07IC8vIDQgPSB0aGV0YVxuXG4gICAgICAgICAgICB2YXIgZFRoZXRhID0gcG9pbnRzWzVdOyAvLyA1ID0gZFRoZXRhXG5cbiAgICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgICB2YXIgaW5jID0gTWF0aC5QSSAvIDE4MC4wOyAvLyAxIGRlZ3JlZSByZXNvbHV0aW9uXG5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhzdGFydCAtIGVuZCkgPCBpbmMpIHtcbiAgICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgICAgfSAvLyBOb3RlOiBmb3IgcHVycG9zZSBvZiBjYWxjdWxhdGluZyBhcmMgbGVuZ3RoLCBub3QgZ29pbmcgdG8gd29ycnkgYWJvdXQgcm90YXRpbmcgWC1heGlzIGJ5IGFuZ2xlIHBzaVxuXG5cbiAgICAgICAgICAgIHAxID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHN0YXJ0LCAwKTtcblxuICAgICAgICAgICAgaWYgKGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgICAgLy8gY2xvY2t3aXNlXG4gICAgICAgICAgICAgIGZvciAodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICAgIGxlbiArPSB0aGlzLmdldExpbmVMZW5ndGgocDEueCwgcDEueSwgcDIueCwgcDIueSk7XG4gICAgICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgKyBpbmM7IHQgPCBlbmQ7IHQgKz0gaW5jKSB7XG4gICAgICAgICAgICAgICAgcDIgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgdCwgMCk7XG4gICAgICAgICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIGVuZCwgMCk7XG4gICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgcmV0dXJuIGxlbjtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludE9uTGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludE9uTGluZShkaXN0LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICAgIHZhciBmcm9tWCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogcDF4O1xuICAgICAgdmFyIGZyb21ZID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiBwMXk7XG4gICAgICB2YXIgbSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCArIFBTRVVET19aRVJPKTtcbiAgICAgIHZhciBydW4gPSBNYXRoLnNxcnQoZGlzdCAqIGRpc3QgLyAoMSArIG0gKiBtKSk7XG5cbiAgICAgIGlmIChwMnggPCBwMXgpIHtcbiAgICAgICAgcnVuICo9IC0xO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmlzZSA9IG0gKiBydW47XG4gICAgICB2YXIgcHQgPSBudWxsO1xuXG4gICAgICBpZiAocDJ4ID09PSBwMXgpIHtcbiAgICAgICAgLy8gdmVydGljYWwgbGluZVxuICAgICAgICBwdCA9IHtcbiAgICAgICAgICB4OiBmcm9tWCxcbiAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKGZyb21ZIC0gcDF5KSAvIChmcm9tWCAtIHAxeCArIFBTRVVET19aRVJPKSA9PT0gbSkge1xuICAgICAgICBwdCA9IHtcbiAgICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpeCA9IDA7XG4gICAgICAgIHZhciBpeSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgocDF4LCBwMXksIHAyeCwgcDJ5KTtcblxuICAgICAgICBpZiAobGVuIDwgUFNFVURPX1pFUk8pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1ID0gKGZyb21YIC0gcDF4KSAqIChwMnggLSBwMXgpICsgKGZyb21ZIC0gcDF5KSAqIChwMnkgLSBwMXkpO1xuICAgICAgICB1IC89IGxlbiAqIGxlbjtcbiAgICAgICAgaXggPSBwMXggKyB1ICogKHAyeCAtIHAxeCk7XG4gICAgICAgIGl5ID0gcDF5ICsgdSAqIChwMnkgLSBwMXkpO1xuICAgICAgICB2YXIgcFJpc2UgPSB0aGlzLmdldExpbmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBpeCwgaXkpO1xuICAgICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG5cbiAgICAgICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgICAgIHJ1biAqPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJpc2UgPSBtICogcnVuO1xuICAgICAgICBwdCA9IHtcbiAgICAgICAgICB4OiBpeCArIHJ1bixcbiAgICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHB0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludE9uUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludE9uUGF0aChkaXN0YW5jZSkge1xuICAgICAgdmFyIGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICAgIHZhciBjdW11bGF0aXZlUGF0aExlbmd0aCA9IDA7XG4gICAgICB2YXIgcCA9IG51bGw7XG5cbiAgICAgIGlmIChkaXN0YW5jZSA8IC0wLjAwMDA1IHx8IGRpc3RhbmNlIC0gMC4wMDAwNSA+IGZ1bGxMZW4pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhQXJyYXkgPSB0aGlzLmRhdGFBcnJheTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGFBcnJheSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNvbW1hbmQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmIChjb21tYW5kICYmIChjb21tYW5kLnBhdGhMZW5ndGggPCAwLjAwMDA1IHx8IGN1bXVsYXRpdmVQYXRoTGVuZ3RoICsgY29tbWFuZC5wYXRoTGVuZ3RoICsgMC4wMDAwNSA8IGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKz0gY29tbWFuZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlbHRhID0gZGlzdGFuY2UgLSBjdW11bGF0aXZlUGF0aExlbmd0aDtcbiAgICAgICAgICB2YXIgY3VycmVudFQgPSAwO1xuXG4gICAgICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uTGluZShkZWx0YSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGNvbW1hbmQucG9pbnRzWzRdOyAvLyA0ID0gdGhldGFcblxuICAgICAgICAgICAgICAgIHZhciBkVGhldGEgPSBjb21tYW5kLnBvaW50c1s1XTsgLy8gNSA9IGRUaGV0YVxuXG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGNvbW1hbmQucG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aCAqIGRUaGV0YTtcblxuICAgICAgICAgICAgICAgIGlmIChkVGhldGEgPCAwICYmIGN1cnJlbnRUIDwgZW5kIHx8IGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSwgY3VycmVudFQsIGNvbW1hbmQucG9pbnRzWzZdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID4gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcihjdXJyZW50VCwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5wb2ludHNbMl0sIGNvbW1hbmQucG9pbnRzWzNdLCBjb21tYW5kLnBvaW50c1s0XSwgY29tbWFuZC5wb2ludHNbNV0pO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUID4gMSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHAgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoY3VycmVudFQsIGNvbW1hbmQuc3RhcnQueCwgY29tbWFuZC5zdGFydC55LCBjb21tYW5kLnBvaW50c1swXSwgY29tbWFuZC5wb2ludHNbMV0sIGNvbW1hbmQucG9pbnRzWzJdLCBjb21tYW5kLnBvaW50c1szXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGluZUxlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhdGhMZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0aExlbmd0aCgpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhMZW5ndGggPT09IC0xKSB7XG4gICAgICAgIHRoaXMucGF0aExlbmd0aCA9IHRoaXMuZGF0YUFycmF5LnJlZHVjZShmdW5jdGlvbiAobGVuZ3RoLCBjb21tYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbW1hbmQucGF0aExlbmd0aCA+IDAgPyBsZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggOiBsZW5ndGg7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXRoTGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludE9uQ3ViaWNCZXppZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnRPbkN1YmljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSwgcDR4LCBwNHkpIHtcbiAgICAgIHZhciB4ID0gcDR4ICogQ0IxKHBjdCkgKyBwM3ggKiBDQjIocGN0KSArIHAyeCAqIENCMyhwY3QpICsgcDF4ICogQ0I0KHBjdCk7XG4gICAgICB2YXIgeSA9IHA0eSAqIENCMShwY3QpICsgcDN5ICogQ0IyKHBjdCkgKyBwMnkgKiBDQjMocGN0KSArIHAxeSAqIENCNChwY3QpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHBjdCwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgICAgdmFyIHggPSBwM3ggKiBRQjEocGN0KSArIHAyeCAqIFFCMihwY3QpICsgcDF4ICogUUIzKHBjdCk7XG4gICAgICB2YXIgeSA9IHAzeSAqIFFCMShwY3QpICsgcDJ5ICogUUIyKHBjdCkgKyBwMXkgKiBRQjMocGN0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50T25FbGxpcHRpY2FsQXJjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50T25FbGxpcHRpY2FsQXJjKGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgcHNpKSB7XG4gICAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKTtcbiAgICAgIHZhciBzaW5Qc2kgPSBNYXRoLnNpbihwc2kpO1xuICAgICAgdmFyIHB0ID0ge1xuICAgICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogcnkgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjeCArIChwdC54ICogY29zUHNpIC0gcHQueSAqIHNpblBzaSksXG4gICAgICAgIHk6IGN5ICsgKHB0LnggKiBzaW5Qc2kgKyBwdC55ICogY29zUHNpKVxuICAgICAgfTtcbiAgICB9IC8vIFRPRE8gbmVlZCBzb21lIG9wdGltaXNhdGlvbnMuIHBvc3NpYmx5IGJ1aWxkIGNhY2hlIG9ubHkgZm9yIGN1cnZlZCBzZWdtZW50cz9cblxuICB9LCB7XG4gICAga2V5OiBcImJ1aWxkRXF1aWRpc3RhbnRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEVxdWlkaXN0YW50Q2FjaGUoaW5wdXRTdGVwLCBpbnB1dFByZWNpc2lvbikge1xuICAgICAgdmFyIGZ1bGxMZW4gPSB0aGlzLmdldFBhdGhMZW5ndGgoKTtcbiAgICAgIHZhciBwcmVjaXNpb24gPSBpbnB1dFByZWNpc2lvbiB8fCAwLjI1OyAvLyBhY2N1cmFjeSB2cyBwZXJmb3JtYW5jZVxuXG4gICAgICB2YXIgc3RlcCA9IGlucHV0U3RlcCB8fCBmdWxsTGVuIC8gMTAwO1xuXG4gICAgICBpZiAoIXRoaXMuZXF1aWRpc3RhbnRDYWNoZSB8fCB0aGlzLmVxdWlkaXN0YW50Q2FjaGUuc3RlcCAhPT0gc3RlcCB8fCB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucHJlY2lzaW9uICE9PSBwcmVjaXNpb24pIHtcbiAgICAgICAgLy8gUHJlcGFyZSBjYWNoZVxuICAgICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUgPSB7XG4gICAgICAgICAgc3RlcDogc3RlcCxcbiAgICAgICAgICBwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICAgICAgICBwb2ludHM6IFtdXG4gICAgICAgIH07IC8vIENhbGN1bGF0ZSBwb2ludHNcblxuICAgICAgICB2YXIgcyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPD0gZnVsbExlbjsgbCArPSBwcmVjaXNpb24pIHtcbiAgICAgICAgICB2YXIgcDAgPSB0aGlzLmdldFBvaW50T25QYXRoKGwpO1xuICAgICAgICAgIHZhciBwMSA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCArIHByZWNpc2lvbik7XG5cbiAgICAgICAgICBpZiAoIXAwIHx8ICFwMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcyArPSB0aGlzLmdldExpbmVMZW5ndGgocDAueCwgcDAueSwgcDEueCwgcDEueSk7XG5cbiAgICAgICAgICBpZiAocyA+PSBzdGVwKSB7XG4gICAgICAgICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICB4OiBwMC54LFxuICAgICAgICAgICAgICB5OiBwMC55LFxuICAgICAgICAgICAgICBkaXN0YW5jZTogbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzIC09IHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVxdWlkaXN0YW50UG9pbnRPblBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXF1aWRpc3RhbnRQb2ludE9uUGF0aCh0YXJnZXREaXN0YW5jZSwgc3RlcCwgcHJlY2lzaW9uKSB7XG4gICAgICB0aGlzLmJ1aWxkRXF1aWRpc3RhbnRDYWNoZShzdGVwLCBwcmVjaXNpb24pO1xuXG4gICAgICBpZiAodGFyZ2V0RGlzdGFuY2UgPCAwIHx8IHRhcmdldERpc3RhbmNlIC0gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgPiAwLjAwMDA1KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWR4ID0gTWF0aC5yb3VuZCh0YXJnZXREaXN0YW5jZSAvIHRoaXMuZ2V0UGF0aExlbmd0aCgpICogKHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMubGVuZ3RoIC0gMSkpO1xuICAgICAgcmV0dXJuIHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHNbaWR4XSB8fCBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0UGF0aEVsZW1lbnQ7XG59KFRleHRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBkYXRhVXJpUmVnZXggPSAvXlxccypkYXRhOigoW14vLDtdK1xcL1teLyw7XSspKD86OyhbXiw7PV0rPVteLDs9XSspKT8pPyg/OjsoYmFzZTY0KSk/LCguKikkL2k7XG5cbnZhciBJbWFnZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZW5kZXJlZEVsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShJbWFnZUVsZW1lbnQsIF9SZW5kZXJlZEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZChJbWFnZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEltYWdlRWxlbWVudChkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgSW1hZ2VFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgIF90aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGhyZWYgPSBfdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCk7XG5cbiAgICBpZiAoIWhyZWYpIHtcbiAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3RoaXMpO1xuICAgIH1cblxuICAgIHZhciBpc1N2ZyA9IGhyZWYuZW5kc1dpdGgoJy5zdmcnKSB8fCAvXlxccypkYXRhOmltYWdlXFwvc3ZnXFwreG1sL2kudGVzdChocmVmKTtcbiAgICBkb2N1bWVudC5pbWFnZXMucHVzaChfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0W1wiZGVmYXVsdFwiXShfdGhpcykpO1xuXG4gICAgaWYgKCFpc1N2Zykge1xuICAgICAgdm9pZCBfdGhpcy5sb2FkSW1hZ2UoaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgX3RoaXMubG9hZFN2ZyhocmVmKTtcbiAgICB9XG5cbiAgICBfdGhpcy5pc1N2ZyA9IGlzU3ZnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oSW1hZ2VFbGVtZW50LCBbe1xuICAgIGtleTogXCJsb2FkSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sb2FkSW1hZ2UgPSBfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoaHJlZikge1xuICAgICAgICB2YXIgaW1hZ2U7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUltYWdlKGhyZWYpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpbWFnZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2FkSW1hZ2UoX3gpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvYWRJbWFnZTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJsb2FkU3ZnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9hZFN2ZyA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoaHJlZikge1xuICAgICAgICB2YXIgbWF0Y2gsIGRhdGEsIHJlc3BvbnNlLCBzdmc7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGRhdGFVcmlSZWdleC5leGVjKGhyZWYpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGF0YSA9IG1hdGNoWzVdO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzRdID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZSA9IGF0b2IoZGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2UgPSBkZWNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSA2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5mZXRjaChocmVmKTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBzdmcgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlID0gc3ZnO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDYpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgX2NvbnRleHQyLnQwKTtcblxuICAgICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcywgW1s2LCAxNl1dKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbG9hZFN2ZyhfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9sb2FkU3ZnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2FkU3ZnO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBpbWFnZSA9IHRoaXMuaW1hZ2UsXG4gICAgICAgICAgbG9hZGVkID0gdGhpcy5sb2FkZWQ7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAoIWxvYWRlZCB8fCAhaW1hZ2UgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgICAgaWYgKHRoaXMuaXNTdmcpIHtcbiAgICAgICAgdmFyIHN1YkRvY3VtZW50ID0gZG9jdW1lbnQuY2FudmcuZm9ya1N0cmluZyhjdHgsIHRoaXMuaW1hZ2UsIHtcbiAgICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZSxcbiAgICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgICAgaWdub3JlRGltZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgICBpZ25vcmVDbGVhcjogdHJ1ZSxcbiAgICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICAgIG9mZnNldFk6IDAsXG4gICAgICAgICAgc2NhbGVXaWR0aDogd2lkdGgsXG4gICAgICAgICAgc2NhbGVIZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgc3ViRG9jdW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHZvaWQgc3ViRG9jdW1lbnQucmVuZGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2ltYWdlID0gdGhpcy5pbWFnZTtcbiAgICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGRlc2lyZWRXaWR0aDogX2ltYWdlLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgIGRlc2lyZWRIZWlnaHQ6IF9pbWFnZS5oZWlnaHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfaW1hZ2UuY29tcGxldGUgPT09ICd1bmRlZmluZWQnIHx8IF9pbWFnZS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShfaW1hZ2UsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveCgpIHtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlRWxlbWVudDtcbn0oUmVuZGVyZWRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTeW1ib2xFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVuZGVyZWRFbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU3ltYm9sRWxlbWVudCwgX1JlbmRlcmVkRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRjKFN5bWJvbEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFN5bWJvbEVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTeW1ib2xFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdzeW1ib2wnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU3ltYm9sRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN5bWJvbEVsZW1lbnQ7XG59KFJlbmRlcmVkRWxlbWVudCk7XG5cbnZhciBTVkdGb250TG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU1ZHRm9udExvYWRlcihkb2N1bWVudCkge1xuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgU1ZHRm9udExvYWRlcik7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5mb250cy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShTVkdGb250TG9hZGVyLCBbe1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9hZCA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmb250RmFtaWx5LCB1cmwpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50LCBzdmdEb2N1bWVudCwgZm9udHM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY2FudmcucGFyc2VyLmxvYWQodXJsKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgc3ZnRG9jdW1lbnQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIGZvbnRzID0gc3ZnRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGZvbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmb250Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGZvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGZvbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRlZmluaXRpb25zW2ZvbnRGYW1pbHldID0gZm9udDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igd2hpbGUgbG9hZGluZyBmb250IFxcXCJcIi5jb25jYXQodXJsLCBcIlxcXCI6XCIpLCBfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzAsIDldXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxvYWQoX3gsIF94Mikge1xuICAgICAgICByZXR1cm4gX2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvYWQ7XG4gICAgfSgpXG4gIH1dKTtcblxuICByZXR1cm4gU1ZHRm9udExvYWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBTdHlsZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oU3R5bGVFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRiKFN0eWxlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU3R5bGVFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBTdHlsZUVsZW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgX3RoaXMudHlwZSA9ICdzdHlsZSc7XG4gICAgdmFyIGNzcyA9IGNvbXByZXNzU3BhY2VzKEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKSAvLyBORUVEIFRFU1RcbiAgICAubWFwKGZ1bmN0aW9uIChfKSB7XG4gICAgICByZXR1cm4gXy50ZXh0Q29udGVudDtcbiAgICB9KS5qb2luKCcnKS5yZXBsYWNlKC8oXFwvXFwqKFteKl18W1xcclxcbl18KFxcKisoW14qL118W1xcclxcbl0pKSkqXFwqK1xcLyl8KF5bXFxzXSpcXC9cXC8uKikvZ20sICcnKSAvLyByZW1vdmUgY29tbWVudHNcbiAgICAucmVwbGFjZSgvQGltcG9ydC4qOy9nLCAnJykgLy8gcmVtb3ZlIGltcG9ydHNcbiAgICApO1xuICAgIHZhciBjc3NEZWZzID0gY3NzLnNwbGl0KCd9Jyk7XG4gICAgY3NzRGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChfKSB7XG4gICAgICB2YXIgZGVmID0gXy50cmltKCk7XG5cbiAgICAgIGlmICghZGVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNzc1BhcnRzID0gZGVmLnNwbGl0KCd7Jyk7XG4gICAgICB2YXIgY3NzQ2xhc3NlcyA9IGNzc1BhcnRzWzBdLnNwbGl0KCcsJyk7XG4gICAgICB2YXIgY3NzUHJvcHMgPSBjc3NQYXJ0c1sxXS5zcGxpdCgnOycpO1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHZhciBjc3NDbGFzcyA9IF8udHJpbSgpO1xuXG4gICAgICAgIGlmICghY3NzQ2xhc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvcHMgPSBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdIHx8IHt9O1xuICAgICAgICBjc3NQcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChjc3NQcm9wKSB7XG4gICAgICAgICAgdmFyIHByb3AgPSBjc3NQcm9wLmluZGV4T2YoJzonKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGNzc1Byb3Auc3Vic3RyKDAsIHByb3ApLnRyaW0oKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjc3NQcm9wLnN1YnN0cihwcm9wICsgMSwgY3NzUHJvcC5sZW5ndGggLSBwcm9wKS50cmltKCk7XG5cbiAgICAgICAgICBpZiAobmFtZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5zdHlsZXNbY3NzQ2xhc3NdID0gcHJvcHM7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1NwZWNpZmljaXR5W2Nzc0NsYXNzXSA9IGdldFNlbGVjdG9yU3BlY2lmaWNpdHkoY3NzQ2xhc3MpO1xuXG4gICAgICAgIGlmIChjc3NDbGFzcyA9PT0gJ0Bmb250LWZhY2UnKSB7XG4gICAgICAgICAgLy8gICYmICFub2RlRW52XG4gICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBwcm9wc1snZm9udC1mYW1pbHknXS5nZXRTdHJpbmcoKS5yZXBsYWNlKC9cInwnL2csICcnKTtcbiAgICAgICAgICB2YXIgc3JjcyA9IHByb3BzLnNyYy5nZXRTdHJpbmcoKS5zcGxpdCgnLCcpO1xuICAgICAgICAgIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xuICAgICAgICAgICAgICB2YXIgdXJsID0gcGFyc2VFeHRlcm5hbFVybChzcmMpO1xuXG4gICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICB2b2lkIG5ldyBTVkdGb250TG9hZGVyKGRvY3VtZW50KS5sb2FkKGZvbnRGYW1pbHksIHVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFN0eWxlRWxlbWVudDtcbn0oRWxlbWVudCk7XG5TdHlsZUVsZW1lbnQucGFyc2VFeHRlcm5hbFVybCA9IHBhcnNlRXh0ZXJuYWxVcmw7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRhKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgVXNlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlbmRlcmVkRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFVzZUVsZW1lbnQsIF9SZW5kZXJlZEVsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYShVc2VFbGVtZW50KTtcblxuICBmdW5jdGlvbiBVc2VFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVXNlRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAndXNlJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKFVzZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcInNldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGV4dChjdHgpIHtcbiAgICAgIF9nZXRfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oVXNlRWxlbWVudC5wcm90b3R5cGUpLCBcInNldENvbnRleHRcIiwgdGhpcykuY2FsbCh0aGlzLCBjdHgpO1xuXG4gICAgICB2YXIgeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpO1xuICAgICAgdmFyIHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgICAgaWYgKHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4QXR0ci5nZXRQaXhlbHMoJ3gnKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoMCwgeUF0dHIuZ2V0UGl4ZWxzKCd5JykpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdGgoY3R4KSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5wYXRoKGN0eCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckNoaWxkcmVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgdGVtcFN2ZyA9IGVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAvLyByZW5kZXIgbWUgdXNpbmcgYSB0ZW1wb3Jhcnkgc3ZnIGVsZW1lbnQgaW4gc3ltYm9sIGNhc2VzIChodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvc3RydWN0Lmh0bWwjVXNlRWxlbWVudClcbiAgICAgICAgICB0ZW1wU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAndmlld0JveCcsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5wcmVzZXJ2ZUFzcGVjdFJhdGlvID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncHJlc2VydmVBc3BlY3RSYXRpbycsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ292ZXJmbG93JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICAgIHRlbXBTdmcuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuOyAvLyBlbGVtZW50IGlzIHN0aWxsIHRoZSBwYXJlbnQgb2YgdGhlIGNoaWxkcmVuXG5cbiAgICAgICAgICBlbGVtZW50LnN0eWxlcy5vcGFjaXR5ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnb3BhY2l0eScsIHRoaXMuY2FsY3VsYXRlT3BhY2l0eSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZW1wU3ZnLnR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgdmFyIHdpZHRoU3R5bGUgPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSk7IC8vIGlmIHN5bWJvbCBvciBzdmcsIGluaGVyaXQgd2lkdGgvaGVpZ2h0IGZyb20gbWVcblxuICAgICAgICAgIGlmICh3aWR0aFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy53aWR0aCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3dpZHRoJywgd2lkdGhTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhlaWdodFN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCBoZWlnaHRTdHlsZS5nZXRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZFBhcmVudCA9IHRlbXBTdmcucGFyZW50O1xuICAgICAgICB0ZW1wU3ZnLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRlbXBTdmcucmVuZGVyKGN0eCk7XG4gICAgICAgIHRlbXBTdmcucGFyZW50ID0gb2xkUGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWxlbWVudFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbGVtZW50VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIGRvY3VtZW50ID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICghdGhpcy5jYWNoZWRFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2FjaGVkRWxlbWVudCA9IHRoaXMuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2FjaGVkRWxlbWVudDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXNlRWxlbWVudDtcbn0oUmVuZGVyZWRFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDkoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIGltR2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEpIHtcbiAgcmV0dXJuIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXTtcbn1cblxuZnVuY3Rpb24gaW1TZXQoaW1nLCB4LCB5LCB3aWR0aCwgX2hlaWdodCwgcmdiYSwgdmFsKSB7XG4gIGltZ1t5ICogd2lkdGggKiA0ICsgeCAqIDQgKyByZ2JhXSA9IHZhbDtcbn1cblxuZnVuY3Rpb24gbShtYXRyaXgsIGksIHYpIHtcbiAgdmFyIG1pID0gbWF0cml4W2ldO1xuICByZXR1cm4gbWkgKiB2O1xufVxuXG5mdW5jdGlvbiBjKGEsIG0xLCBtMiwgbTMpIHtcbiAgcmV0dXJuIG0xICsgTWF0aC5jb3MoYSkgKiBtMiArIE1hdGguc2luKGEpICogbTM7XG59XG5cbnZhciBGZUNvbG9yTWF0cml4RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZUNvbG9yTWF0cml4RWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkOShGZUNvbG9yTWF0cml4RWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRmVDb2xvck1hdHJpeEVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZlQ29sb3JNYXRyaXhFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZmVDb2xvck1hdHJpeCc7XG4gICAgdmFyIG1hdHJpeCA9IHRvTnVtYmVycyhfdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlcycpLmdldFN0cmluZygpKTtcblxuICAgIHN3aXRjaCAoX3RoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJykuZ2V0U3RyaW5nKCdtYXRyaXgnKSkge1xuICAgICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL2ZpbHRlcnMuaHRtbCNmZUNvbG9yTWF0cml4RWxlbWVudFxuICAgICAgY2FzZSAnc2F0dXJhdGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHMgPSBtYXRyaXhbMF07XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBtYXRyaXggPSBbMC4yMTMgKyAwLjc4NyAqIHMsIDAuNzE1IC0gMC43MTUgKiBzLCAwLjA3MiAtIDAuMDcyICogcywgMCwgMCwgMC4yMTMgLSAwLjIxMyAqIHMsIDAuNzE1ICsgMC4yODUgKiBzLCAwLjA3MiAtIDAuMDcyICogcywgMCwgMCwgMC4yMTMgLSAwLjIxMyAqIHMsIDAuNzE1IC0gMC43MTUgKiBzLCAwLjA3MiArIDAuOTI4ICogcywgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2h1ZVJvdGF0ZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgYSA9IG1hdHJpeFswXSAqIE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIG1hdHJpeCA9IFtjKGEsIDAuMjEzLCAwLjc4NywgLTAuMjEzKSwgYyhhLCAwLjcxNSwgLTAuNzE1LCAtMC43MTUpLCBjKGEsIDAuMDcyLCAtMC4wNzIsIDAuOTI4KSwgMCwgMCwgYyhhLCAwLjIxMywgLTAuMjEzLCAwLjE0MyksIGMoYSwgMC43MTUsIDAuMjg1LCAwLjE0MCksIGMoYSwgMC4wNzIsIC0wLjA3MiwgLTAuMjgzKSwgMCwgMCwgYyhhLCAwLjIxMywgLTAuMjEzLCAtMC43ODcpLCBjKGEsIDAuNzE1LCAtMC43MTUsIDAuNzE1KSwgYyhhLCAwLjA3MiwgMC45MjgsIDAuMDcyKSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMV07XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2x1bWluYW5jZVRvQWxwaGEnOlxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cbiAgICAgICAgbWF0cml4ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAuMjEyNSwgMC43MTU0LCAwLjA3MjEsIDAsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIF90aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICBfdGhpcy5pbmNsdWRlT3BhY2l0eSA9IF90aGlzLmdldEF0dHJpYnV0ZSgnaW5jbHVkZU9wYWNpdHknKS5oYXNWYWx1ZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVDb2xvck1hdHJpeEVsZW1lbnQsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCwgX3gsIF95LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAvLyBhc3N1bWluZyB4PT0wICYmIHk9PTAgZm9yIG5vd1xuICAgICAgdmFyIGluY2x1ZGVPcGFjaXR5ID0gdGhpcy5pbmNsdWRlT3BhY2l0eSxcbiAgICAgICAgICBtYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgIHZhciBzcmNEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICB2YXIgciA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMCk7XG4gICAgICAgICAgdmFyIGcgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEpO1xuICAgICAgICAgIHZhciBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcbiAgICAgICAgICB2YXIgYSA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMyk7XG4gICAgICAgICAgdmFyIG5yID0gbShtYXRyaXgsIDAsIHIpICsgbShtYXRyaXgsIDEsIGcpICsgbShtYXRyaXgsIDIsIGIpICsgbShtYXRyaXgsIDMsIGEpICsgbShtYXRyaXgsIDQsIDEpO1xuICAgICAgICAgIHZhciBuZyA9IG0obWF0cml4LCA1LCByKSArIG0obWF0cml4LCA2LCBnKSArIG0obWF0cml4LCA3LCBiKSArIG0obWF0cml4LCA4LCBhKSArIG0obWF0cml4LCA5LCAxKTtcbiAgICAgICAgICB2YXIgbmIgPSBtKG1hdHJpeCwgMTAsIHIpICsgbShtYXRyaXgsIDExLCBnKSArIG0obWF0cml4LCAxMiwgYikgKyBtKG1hdHJpeCwgMTMsIGEpICsgbShtYXRyaXgsIDE0LCAxKTtcbiAgICAgICAgICB2YXIgbmEgPSBtKG1hdHJpeCwgMTUsIHIpICsgbShtYXRyaXgsIDE2LCBnKSArIG0obWF0cml4LCAxNywgYikgKyBtKG1hdHJpeCwgMTgsIGEpICsgbShtYXRyaXgsIDE5LCAxKTtcblxuICAgICAgICAgIGlmIChpbmNsdWRlT3BhY2l0eSkge1xuICAgICAgICAgICAgbnIgPSAwO1xuICAgICAgICAgICAgbmcgPSAwO1xuICAgICAgICAgICAgbmIgPSAwO1xuICAgICAgICAgICAgbmEgKj0gYSAvIDI1NTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIG5yKTtcbiAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDEsIG5nKTtcbiAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDIsIG5iKTtcbiAgICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG5hKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShzcmNEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmVDb2xvck1hdHJpeEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIE1hc2tFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1hc2tFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ4KE1hc2tFbGVtZW50KTtcblxuICBmdW5jdGlvbiBNYXNrRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIE1hc2tFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdtYXNrJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKE1hc2tFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7IC8vIHJlbmRlciBhcyB0ZW1wIHN2Z1xuXG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngxKTtcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueTEpO1xuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gud2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZ25vcmVkU3R5bGVzID0gdGhpcy5yZW1vdmVTdHlsZXMoZWxlbWVudCwgTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICAgIHZhciBtYXNrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRvY3VtZW50LnNjcmVlbi5zZXREZWZhdWx0cyhtYXNrQ3R4KTtcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7IC8vIGNvbnZlcnQgbWFzayB0byBhbHBoYSB3aXRoIGEgZmFrZSBub2RlXG4gICAgICAvLyBUT0RPOiByZWZhY3RvciBvdXQgYXBwbHkgZnJvbSBmZUNvbG9yTWF0cml4XG5cbiAgICAgIG5ldyBGZUNvbG9yTWF0cml4RWxlbWVudChkb2N1bWVudCwge1xuICAgICAgICBub2RlVHlwZTogMSxcbiAgICAgICAgY2hpbGROb2RlczogW10sXG4gICAgICAgIGF0dHJpYnV0ZXM6IFt7XG4gICAgICAgICAgbm9kZU5hbWU6ICd0eXBlJyxcbiAgICAgICAgICB2YWx1ZTogJ2x1bWluYW5jZVRvQWxwaGEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBub2RlTmFtZTogJ2luY2x1ZGVPcGFjaXR5JyxcbiAgICAgICAgICB2YWx1ZTogJ3RydWUnXG4gICAgICAgIH1dXG4gICAgICB9KS5hcHBseShtYXNrQ3R4LCAwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpO1xuICAgICAgdG1wQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1pbic7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKG1hc2tDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICAgIHRtcEN0eC5maWxsUmVjdCgwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRtcEN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcywgJ25vLXJlcGVhdCcpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7IC8vIHJlYXNzaWduIG1hc2tcblxuICAgICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFza0VsZW1lbnQ7XG59KEVsZW1lbnQpO1xuTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzID0gWydtYXNrJywgJ3RyYW5zZm9ybScsICdjbGlwLXBhdGgnXTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHsvLyBOT09QXG59O1xuXG52YXIgQ2xpcFBhdGhFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKENsaXBQYXRoRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNyhDbGlwUGF0aEVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIENsaXBQYXRoRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIENsaXBQYXRoRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnY2xpcFBhdGgnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oQ2xpcFBhdGhFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShjdHgpIHtcbiAgICAgIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gICAgICB2YXIgY29udGV4dFByb3RvID0gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihjdHgpO1xuICAgICAgdmFyIGJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGgsXG4gICAgICAgICAgY2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcblxuICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gbm9vcDtcbiAgICAgICAgY29udGV4dFByb3RvLmNsb3NlUGF0aCA9IG5vb3A7XG4gICAgICB9XG5cbiAgICAgIFJlZmxlY3QuYXBwbHkoYmVnaW5QYXRoLCBjdHgsIFtdKTtcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSB0eXBlb2YgY2hpbGQuZWxlbWVudFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcgPyBjaGlsZC5lbGVtZW50VHJhbnNmb3JtKCkgOiBudWxsOyAvLyBoYW5kbGUgPHVzZSAvPlxuXG4gICAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgICAgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KGRvY3VtZW50LCBjaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZC5wYXRoKGN0eCk7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQcm90bykge1xuICAgICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBSZWZsZWN0LmFwcGx5KGNsb3NlUGF0aCwgY3R4LCBbXSk7XG4gICAgICBjdHguY2xpcCgpO1xuXG4gICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBiZWdpblBhdGg7XG4gICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDbGlwUGF0aEVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEZpbHRlckVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmlsdGVyRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNihGaWx0ZXJFbGVtZW50KTtcblxuICBmdW5jdGlvbiBGaWx0ZXJFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgRmlsdGVyRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnZmlsdGVyJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZpbHRlckVsZW1lbnQsIFt7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgICAgLy8gcmVuZGVyIGFzIHRlbXAgc3ZnXG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBweCA9IDA7XG4gICAgICB2YXIgcHkgPSAwO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGVmZCA9IGNoaWxkLmV4dHJhRmlsdGVyRGlzdGFuY2UgfHwgMDtcbiAgICAgICAgcHggPSBNYXRoLm1heChweCwgZWZkKTtcbiAgICAgICAgcHkgPSBNYXRoLm1heChweSwgZWZkKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgICAgdmFyIHRtcENhbnZhc1dpZHRoID0gd2lkdGggKyAyICogcHg7XG4gICAgICB2YXIgdG1wQ2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICsgMiAqIHB5O1xuXG4gICAgICBpZiAodG1wQ2FudmFzV2lkdGggPCAxIHx8IHRtcENhbnZhc0hlaWdodCA8IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueCk7XG4gICAgICB2YXIgeSA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3gueSk7XG4gICAgICB2YXIgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIEZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXModG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLXggKyBweCwgLXkgKyBweSk7XG4gICAgICBlbGVtZW50LnJlbmRlcih0bXBDdHgpOyAvLyBhcHBseSBmaWx0ZXJzXG5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQuYXBwbHkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjaGlsZC5hcHBseSh0bXBDdHgsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gcmVuZGVyIG9uIG1lXG5cbiAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0LCB4IC0gcHgsIHkgLSBweSwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgICB0aGlzLnJlc3RvcmVTdHlsZXMoZWxlbWVudCwgaWdub3JlZFN0eWxlcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoXykgey8vIE5PIFJFTkRFUlxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWx0ZXJFbGVtZW50O1xufShFbGVtZW50KTtcbkZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzID0gWydmaWx0ZXInLCAndHJhbnNmb3JtJywgJ2NsaXAtcGF0aCddO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEZlRHJvcFNoYWRvd0VsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVEcm9wU2hhZG93RWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNShGZURyb3BTaGFkb3dFbGVtZW50KTtcblxuICBmdW5jdGlvbiBGZURyb3BTaGFkb3dFbGVtZW50KGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBGZURyb3BTaGFkb3dFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIF90aGlzLnR5cGUgPSAnZmVEcm9wU2hhZG93JztcblxuICAgIF90aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVEcm9wU2hhZG93RWxlbWVudCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmVEcm9wU2hhZG93RWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ0KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRmVNb3JwaG9sb2d5RWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZU1vcnBob2xvZ3lFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ0KEZlTW9ycGhvbG9neUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZlTW9ycGhvbG9neUVsZW1lbnQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCBGZU1vcnBob2xvZ3lFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdmZU1vcnBob2xvZ3knO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVNb3JwaG9sb2d5RWxlbWVudCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoXywgX3gsIF95LCBfd2lkdGgsIF9oZWlnaHQpIHsvLyBUT0RPOiBpbXBsZW1lbnRcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmVNb3JwaG9sb2d5RWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2ZfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDMoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRmVDb21wb3NpdGVFbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZlQ29tcG9zaXRlRWxlbWVudCwgX0VsZW1lbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMyhGZUNvbXBvc2l0ZUVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZlQ29tcG9zaXRlRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZlQ29tcG9zaXRlRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIF90aGlzLnR5cGUgPSAnZmVDb21wb3NpdGUnO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRmVDb21wb3NpdGVFbGVtZW50LCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGZUNvbXBvc2l0ZUVsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5fX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxudmFyIEZlR2F1c3NpYW5CbHVyRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VsZW1lbnQpIHtcbiAgX2luaGVyaXRzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShGZUdhdXNzaWFuQmx1ckVsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDIoRmVHYXVzc2lhbkJsdXJFbGVtZW50KTtcblxuICBmdW5jdGlvbiBGZUdhdXNzaWFuQmx1ckVsZW1lbnQoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIEZlR2F1c3NpYW5CbHVyRWxlbWVudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICBfdGhpcy50eXBlID0gJ2ZlR2F1c3NpYW5CbHVyJztcbiAgICBfdGhpcy5ibHVyUmFkaXVzID0gTWF0aC5mbG9vcihfdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicpLmdldE51bWJlcigpKTtcbiAgICBfdGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gX3RoaXMuYmx1clJhZGl1cztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKEZlR2F1c3NpYW5CbHVyRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgIGJsdXJSYWRpdXMgPSB0aGlzLmJsdXJSYWRpdXM7XG4gICAgICB2YXIgYm9keSA9IGRvY3VtZW50LndpbmRvdyA/IGRvY3VtZW50LndpbmRvdy5kb2N1bWVudC5ib2R5IDogbnVsbDtcbiAgICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzOyAvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XG5cbiAgICAgIGNhbnZhcy5pZCA9IGRvY3VtZW50LmdldFVuaXF1ZUlkKCk7XG5cbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIHN0YWNrYmx1ckNhbnZhcy5jYW52YXNSR0JBKGNhbnZhcywgeCwgeSwgd2lkdGgsIGhlaWdodCwgYmx1clJhZGl1cyk7XG5cbiAgICAgIGlmIChib2R5KSB7XG4gICAgICAgIGJvZHkucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmVHYXVzc2lhbkJsdXJFbGVtZW50O1xufShFbGVtZW50KTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBUaXRsZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oVGl0bGVFbGVtZW50LCBfRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKFRpdGxlRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gVGl0bGVFbGVtZW50KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgVGl0bGVFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICd0aXRsZSc7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFRpdGxlRWxlbWVudDtcbn0oRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgRGVzY0VsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c19fZGVmYXVsdFtcImRlZmF1bHRcIl0oRGVzY0VsZW1lbnQsIF9FbGVtZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKERlc2NFbGVtZW50KTtcblxuICBmdW5jdGlvbiBEZXNjRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIERlc2NFbGVtZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgX3RoaXMudHlwZSA9ICdkZXNjJztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gRGVzY0VsZW1lbnQ7XG59KEVsZW1lbnQpO1xuXG52YXIgZWxlbWVudHMgPSB7XG4gICdzdmcnOiBTVkdFbGVtZW50LFxuICAncmVjdCc6IFJlY3RFbGVtZW50LFxuICAnY2lyY2xlJzogQ2lyY2xlRWxlbWVudCxcbiAgJ2VsbGlwc2UnOiBFbGxpcHNlRWxlbWVudCxcbiAgJ2xpbmUnOiBMaW5lRWxlbWVudCxcbiAgJ3BvbHlsaW5lJzogUG9seWxpbmVFbGVtZW50LFxuICAncG9seWdvbic6IFBvbHlnb25FbGVtZW50LFxuICAncGF0aCc6IFBhdGhFbGVtZW50LFxuICAncGF0dGVybic6IFBhdHRlcm5FbGVtZW50LFxuICAnbWFya2VyJzogTWFya2VyRWxlbWVudCxcbiAgJ2RlZnMnOiBEZWZzRWxlbWVudCxcbiAgJ2xpbmVhckdyYWRpZW50JzogTGluZWFyR3JhZGllbnRFbGVtZW50LFxuICAncmFkaWFsR3JhZGllbnQnOiBSYWRpYWxHcmFkaWVudEVsZW1lbnQsXG4gICdzdG9wJzogU3RvcEVsZW1lbnQsXG4gICdhbmltYXRlJzogQW5pbWF0ZUVsZW1lbnQsXG4gICdhbmltYXRlQ29sb3InOiBBbmltYXRlQ29sb3JFbGVtZW50LFxuICAnYW5pbWF0ZVRyYW5zZm9ybSc6IEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50LFxuICAnZm9udCc6IEZvbnRFbGVtZW50LFxuICAnZm9udC1mYWNlJzogRm9udEZhY2VFbGVtZW50LFxuICAnbWlzc2luZy1nbHlwaCc6IE1pc3NpbmdHbHlwaEVsZW1lbnQsXG4gICdnbHlwaCc6IEdseXBoRWxlbWVudCxcbiAgJ3RleHQnOiBUZXh0RWxlbWVudCxcbiAgJ3RzcGFuJzogVFNwYW5FbGVtZW50LFxuICAndHJlZic6IFRSZWZFbGVtZW50LFxuICAnYSc6IEFFbGVtZW50LFxuICAndGV4dFBhdGgnOiBUZXh0UGF0aEVsZW1lbnQsXG4gICdpbWFnZSc6IEltYWdlRWxlbWVudCxcbiAgJ2cnOiBHRWxlbWVudCxcbiAgJ3N5bWJvbCc6IFN5bWJvbEVsZW1lbnQsXG4gICdzdHlsZSc6IFN0eWxlRWxlbWVudCxcbiAgJ3VzZSc6IFVzZUVsZW1lbnQsXG4gICdtYXNrJzogTWFza0VsZW1lbnQsXG4gICdjbGlwUGF0aCc6IENsaXBQYXRoRWxlbWVudCxcbiAgJ2ZpbHRlcic6IEZpbHRlckVsZW1lbnQsXG4gICdmZURyb3BTaGFkb3cnOiBGZURyb3BTaGFkb3dFbGVtZW50LFxuICAnZmVNb3JwaG9sb2d5JzogRmVNb3JwaG9sb2d5RWxlbWVudCxcbiAgJ2ZlQ29tcG9zaXRlJzogRmVDb21wb3NpdGVFbGVtZW50LFxuICAnZmVDb2xvck1hdHJpeCc6IEZlQ29sb3JNYXRyaXhFbGVtZW50LFxuICAnZmVHYXVzc2lhbkJsdXInOiBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsXG4gICd0aXRsZSc6IFRpdGxlRWxlbWVudCxcbiAgJ2Rlc2MnOiBEZXNjRWxlbWVudFxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQxKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQxKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbWFnZShfeCkge1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVJbWFnZSgpIHtcbiAgX2NyZWF0ZUltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNyYykge1xuICAgIHZhciBhbm9ueW1vdXNDcm9zc09yaWdpbixcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lX19kZWZhdWx0W1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPSBfYXJncy5sZW5ndGggPiAxICYmIF9hcmdzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnc1sxXSA6IGZhbHNlO1xuICAgICAgICAgICAgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICAgICAgaWYgKGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uIChfZXZlbnQsIF9zb3VyY2UsIF9saW5lbm8sIF9jb2xubywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9jcmVhdGVJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgRG9jdW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEb2N1bWVudChjYW52Zykge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgX3JlZiRyb290RW1TaXplID0gX3JlZi5yb290RW1TaXplLFxuICAgICAgICByb290RW1TaXplID0gX3JlZiRyb290RW1TaXplID09PSB2b2lkIDAgPyAxMiA6IF9yZWYkcm9vdEVtU2l6ZSxcbiAgICAgICAgX3JlZiRlbVNpemUgPSBfcmVmLmVtU2l6ZSxcbiAgICAgICAgZW1TaXplID0gX3JlZiRlbVNpemUgPT09IHZvaWQgMCA/IDEyIDogX3JlZiRlbVNpemUsXG4gICAgICAgIF9yZWYkY3JlYXRlQ2FudmFzID0gX3JlZi5jcmVhdGVDYW52YXMsXG4gICAgICAgIGNyZWF0ZUNhbnZhcyA9IF9yZWYkY3JlYXRlQ2FudmFzID09PSB2b2lkIDAgPyBEb2N1bWVudC5jcmVhdGVDYW52YXMgOiBfcmVmJGNyZWF0ZUNhbnZhcyxcbiAgICAgICAgX3JlZiRjcmVhdGVJbWFnZSA9IF9yZWYuY3JlYXRlSW1hZ2UsXG4gICAgICAgIGNyZWF0ZUltYWdlID0gX3JlZiRjcmVhdGVJbWFnZSA9PT0gdm9pZCAwID8gRG9jdW1lbnQuY3JlYXRlSW1hZ2UgOiBfcmVmJGNyZWF0ZUltYWdlLFxuICAgICAgICBhbm9ueW1vdXNDcm9zc09yaWdpbiA9IF9yZWYuYW5vbnltb3VzQ3Jvc3NPcmlnaW47XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2tfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHRoaXMsIERvY3VtZW50KTtcblxuICAgIHRoaXMuY2FudmcgPSBjYW52ZztcbiAgICB0aGlzLmRlZmluaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB0aGlzLmZvbnRzID0gW107XG4gICAgdGhpcy5lbVNpemVTdGFjayA9IFtdO1xuICAgIHRoaXMudW5pcXVlSWQgPSAwO1xuICAgIHRoaXMuc2NyZWVuID0gY2Fudmcuc2NyZWVuO1xuICAgIHRoaXMucm9vdEVtU2l6ZSA9IHJvb3RFbVNpemU7XG4gICAgdGhpcy5lbVNpemUgPSBlbVNpemU7XG4gICAgdGhpcy5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG4gICAgdGhpcy5jcmVhdGVJbWFnZSA9IHRoaXMuYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzSW1hZ2VzTG9hZGVkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NyZWVuLndhaXQodGhpcy5pc0ZvbnRzTG9hZGVkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShEb2N1bWVudCwgW3tcbiAgICBrZXk6IFwiYmluZENyZWF0ZUltYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRDcmVhdGVJbWFnZShjcmVhdGVJbWFnZSwgYW5vbnltb3VzQ3Jvc3NPcmlnaW4pIHtcbiAgICAgIGlmICh0eXBlb2YgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSwgZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVJbWFnZShzb3VyY2UsIHR5cGVvZiBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luID09PSAnYm9vbGVhbicgPyBmb3JjZUFub255bW91c0Nyb3NzT3JpZ2luIDogYW5vbnltb3VzQ3Jvc3NPcmlnaW4pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlSW1hZ2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcEVtU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BFbVNpemUoKSB7XG4gICAgICB2YXIgZW1TaXplU3RhY2sgPSB0aGlzLmVtU2l6ZVN0YWNrO1xuICAgICAgZW1TaXplU3RhY2sucG9wKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFVuaXF1ZUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICAgICAgcmV0dXJuIFwiY2FudmdcIi5jb25jYXQoKyt0aGlzLnVuaXF1ZUlkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbWFnZXNMb2FkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbWFnZXNMb2FkZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWFnZXMuZXZlcnkoZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgcmV0dXJuIF8ubG9hZGVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRm9udHNMb2FkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGb250c0xvYWRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvbnRzLmV2ZXJ5KGZ1bmN0aW9uIChfKSB7XG4gICAgICAgIHJldHVybiBfLmxvYWRlZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVEb2N1bWVudEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRFbGVtZW50KGRvY3VtZW50KSB7XG4gICAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICBkb2N1bWVudEVsZW1lbnQucm9vdCA9IHRydWU7XG4gICAgICBkb2N1bWVudEVsZW1lbnQuYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbigpO1xuICAgICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgICByZXR1cm4gZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobm9kZSkge1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gbm9kZS5ub2RlTmFtZS5yZXBsYWNlKC9eW146XSs6LywgJycpO1xuICAgICAgdmFyIEVsZW1lbnRUeXBlID0gRG9jdW1lbnQuZWxlbWVudFR5cGVzW2VsZW1lbnRUeXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBFbGVtZW50VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGVtZW50VHlwZSh0aGlzLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRWxlbWVudCh0aGlzLCBub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGV4dE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUobm9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLCBub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Vmlld0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWV3Qm94KGNvbmZpZykge1xuICAgICAgdGhpcy5zY3JlZW4uc2V0Vmlld0JveChfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgICBkb2N1bWVudDogdGhpc1xuICAgICAgfSwgY29uZmlnKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpbmRvd1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLndpbmRvdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5mZXRjaDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3R4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zY3JlZW4uY3R4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbVNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbVNpemVTdGFjayA9IHRoaXMuZW1TaXplU3RhY2s7XG4gICAgICByZXR1cm4gZW1TaXplU3RhY2tbZW1TaXplU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgdmFyIGVtU2l6ZVN0YWNrID0gdGhpcy5lbVNpemVTdGFjaztcbiAgICAgIGVtU2l6ZVN0YWNrLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEb2N1bWVudDtcbn0oKTtcbkRvY3VtZW50LmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbkRvY3VtZW50LmNyZWF0ZUltYWdlID0gY3JlYXRlSW1hZ2U7XG5Eb2N1bWVudC5lbGVtZW50VHlwZXMgPSBlbGVtZW50cztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eV9fZGVmYXVsdFtcImRlZmF1bHRcIl0odGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBTVkcgcmVuZGVyZXIgb24gY2FudmFzLlxyXG4gKi9cblxudmFyIENhbnZnID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXHJcbiAgICogTWFpbiBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBEb2N1bWVudC5cclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDYW52ZyhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVja19fZGVmYXVsdFtcImRlZmF1bHRcIl0odGhpcywgQ2FudmcpO1xuXG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIGRvY3VtZW50ID0gbmV3IERvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEVsZW1lbnQoc3ZnKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3NfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKENhbnZnLCBbe1xuICAgIGtleTogXCJmb3JrXCIsXG5cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yayhjdHgsIHN2Zykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgcmV0dXJuIENhbnZnLmZyb20oY3R4LCBzdmcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cclxuICAgICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9ya1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JrU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gQ2FudmcuZnJvbVN0cmluZyhjdHgsIHN2ZywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRG9jdW1lbnQgaXMgcmVhZHkgcHJvbWlzZS5cclxuICAgICAqIEByZXR1cm5zIFJlYWR5IHByb21pc2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlYWR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLnJlYWR5KCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRG9jdW1lbnQgaXMgcmVhZHkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJucyBJcyByZWFkeSBvciBub3QuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImlzUmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5pc1JlYWR5KCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIG9ubHkgZmlyc3QgZnJhbWUsIGlnbm9yaW5nIGFuaW1hdGlvbnMgYW5kIG1vdXNlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVuZGVyID0gX2FzeW5jVG9HZW5lcmF0b3JfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyxcbiAgICAgICAgICAgIF9hcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZV9fZGVmYXVsdFtcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gX2FyZ3MubGVuZ3RoID4gMCAmJiBfYXJnc1swXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3NbMF0gOiB7fTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgICAgICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaWdub3JlTW91c2U6IHRydWVcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZHkoKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW5kZXI7XG4gICAgfSgpXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlciBvcHRpb25zLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICBzY3JlZW4gPSB0aGlzLnNjcmVlbixcbiAgICAgICAgICBiYXNlT3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHNjcmVlbi5zdGFydChkb2N1bWVudEVsZW1lbnQsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZVxuICAgICAgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3RvcCByZW5kZXJpbmcuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuc2NyZWVuLnN0b3AoKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgU1ZHIHRvIGZpdCBpbiBnaXZlbiBzaXplLlxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpb1xyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKHdpZHRoKSB7XG4gICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB3aWR0aDtcbiAgICAgIHZhciBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZnJvbSA9IF9hc3luY1RvR2VuZXJhdG9yX19kZWZhdWx0W1wiZGVmYXVsdFwiXSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoY3R4LCBzdmcpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMsXG4gICAgICAgICAgICBwYXJzZXIsXG4gICAgICAgICAgICBzdmdEb2N1bWVudCxcbiAgICAgICAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBfYXJnczIubGVuZ3RoID4gMiAmJiBfYXJnczJbMl0gIT09IHVuZGVmaW5lZCA/IF9hcmdzMlsyXSA6IHt9O1xuICAgICAgICAgICAgICAgIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2Uoc3ZnKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgc3ZnRG9jdW1lbnQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBmcm9tKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9mcm9tLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmcm9tO1xuICAgIH0oKVxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFJlbmRlcmluZyBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyhjdHgsIHN2Zykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICB2YXIgc3ZnRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Zyk7XG4gICAgICByZXR1cm4gbmV3IENhbnZnKGN0eCwgc3ZnRG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYW52Zztcbn0oKTtcblxuZXhwb3J0cy5BRWxlbWVudCA9IEFFbGVtZW50O1xuZXhwb3J0cy5BbmltYXRlQ29sb3JFbGVtZW50ID0gQW5pbWF0ZUNvbG9yRWxlbWVudDtcbmV4cG9ydHMuQW5pbWF0ZUVsZW1lbnQgPSBBbmltYXRlRWxlbWVudDtcbmV4cG9ydHMuQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQgPSBBbmltYXRlVHJhbnNmb3JtRWxlbWVudDtcbmV4cG9ydHMuQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcbmV4cG9ydHMuQ0IxID0gQ0IxO1xuZXhwb3J0cy5DQjIgPSBDQjI7XG5leHBvcnRzLkNCMyA9IENCMztcbmV4cG9ydHMuQ0I0ID0gQ0I0O1xuZXhwb3J0cy5DYW52ZyA9IENhbnZnO1xuZXhwb3J0cy5DaXJjbGVFbGVtZW50ID0gQ2lyY2xlRWxlbWVudDtcbmV4cG9ydHMuQ2xpcFBhdGhFbGVtZW50ID0gQ2xpcFBhdGhFbGVtZW50O1xuZXhwb3J0cy5EZWZzRWxlbWVudCA9IERlZnNFbGVtZW50O1xuZXhwb3J0cy5EZXNjRWxlbWVudCA9IERlc2NFbGVtZW50O1xuZXhwb3J0cy5Eb2N1bWVudCA9IERvY3VtZW50O1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRWxsaXBzZUVsZW1lbnQgPSBFbGxpcHNlRWxlbWVudDtcbmV4cG9ydHMuRmVDb2xvck1hdHJpeEVsZW1lbnQgPSBGZUNvbG9yTWF0cml4RWxlbWVudDtcbmV4cG9ydHMuRmVDb21wb3NpdGVFbGVtZW50ID0gRmVDb21wb3NpdGVFbGVtZW50O1xuZXhwb3J0cy5GZURyb3BTaGFkb3dFbGVtZW50ID0gRmVEcm9wU2hhZG93RWxlbWVudDtcbmV4cG9ydHMuRmVHYXVzc2lhbkJsdXJFbGVtZW50ID0gRmVHYXVzc2lhbkJsdXJFbGVtZW50O1xuZXhwb3J0cy5GZU1vcnBob2xvZ3lFbGVtZW50ID0gRmVNb3JwaG9sb2d5RWxlbWVudDtcbmV4cG9ydHMuRmlsdGVyRWxlbWVudCA9IEZpbHRlckVsZW1lbnQ7XG5leHBvcnRzLkZvbnQgPSBGb250O1xuZXhwb3J0cy5Gb250RWxlbWVudCA9IEZvbnRFbGVtZW50O1xuZXhwb3J0cy5Gb250RmFjZUVsZW1lbnQgPSBGb250RmFjZUVsZW1lbnQ7XG5leHBvcnRzLkdFbGVtZW50ID0gR0VsZW1lbnQ7XG5leHBvcnRzLkdseXBoRWxlbWVudCA9IEdseXBoRWxlbWVudDtcbmV4cG9ydHMuR3JhZGllbnRFbGVtZW50ID0gR3JhZGllbnRFbGVtZW50O1xuZXhwb3J0cy5JbWFnZUVsZW1lbnQgPSBJbWFnZUVsZW1lbnQ7XG5leHBvcnRzLkxpbmVFbGVtZW50ID0gTGluZUVsZW1lbnQ7XG5leHBvcnRzLkxpbmVhckdyYWRpZW50RWxlbWVudCA9IExpbmVhckdyYWRpZW50RWxlbWVudDtcbmV4cG9ydHMuTWFya2VyRWxlbWVudCA9IE1hcmtlckVsZW1lbnQ7XG5leHBvcnRzLk1hc2tFbGVtZW50ID0gTWFza0VsZW1lbnQ7XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcbmV4cG9ydHMuTWlzc2luZ0dseXBoRWxlbWVudCA9IE1pc3NpbmdHbHlwaEVsZW1lbnQ7XG5leHBvcnRzLk1vdXNlID0gTW91c2U7XG5leHBvcnRzLlBTRVVET19aRVJPID0gUFNFVURPX1pFUk87XG5leHBvcnRzLlBhcnNlciA9IFBhcnNlcjtcbmV4cG9ydHMuUGF0aEVsZW1lbnQgPSBQYXRoRWxlbWVudDtcbmV4cG9ydHMuUGF0aFBhcnNlciA9IFBhdGhQYXJzZXI7XG5leHBvcnRzLlBhdHRlcm5FbGVtZW50ID0gUGF0dGVybkVsZW1lbnQ7XG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XG5leHBvcnRzLlBvbHlnb25FbGVtZW50ID0gUG9seWdvbkVsZW1lbnQ7XG5leHBvcnRzLlBvbHlsaW5lRWxlbWVudCA9IFBvbHlsaW5lRWxlbWVudDtcbmV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcbmV4cG9ydHMuUUIxID0gUUIxO1xuZXhwb3J0cy5RQjIgPSBRQjI7XG5leHBvcnRzLlFCMyA9IFFCMztcbmV4cG9ydHMuUmFkaWFsR3JhZGllbnRFbGVtZW50ID0gUmFkaWFsR3JhZGllbnRFbGVtZW50O1xuZXhwb3J0cy5SZWN0RWxlbWVudCA9IFJlY3RFbGVtZW50O1xuZXhwb3J0cy5SZW5kZXJlZEVsZW1lbnQgPSBSZW5kZXJlZEVsZW1lbnQ7XG5leHBvcnRzLlJvdGF0ZSA9IFJvdGF0ZTtcbmV4cG9ydHMuU1ZHRWxlbWVudCA9IFNWR0VsZW1lbnQ7XG5leHBvcnRzLlNWR0ZvbnRMb2FkZXIgPSBTVkdGb250TG9hZGVyO1xuZXhwb3J0cy5TY2FsZSA9IFNjYWxlO1xuZXhwb3J0cy5TY3JlZW4gPSBTY3JlZW47XG5leHBvcnRzLlNrZXcgPSBTa2V3O1xuZXhwb3J0cy5Ta2V3WCA9IFNrZXdYO1xuZXhwb3J0cy5Ta2V3WSA9IFNrZXdZO1xuZXhwb3J0cy5TdG9wRWxlbWVudCA9IFN0b3BFbGVtZW50O1xuZXhwb3J0cy5TdHlsZUVsZW1lbnQgPSBTdHlsZUVsZW1lbnQ7XG5leHBvcnRzLlN5bWJvbEVsZW1lbnQgPSBTeW1ib2xFbGVtZW50O1xuZXhwb3J0cy5UUmVmRWxlbWVudCA9IFRSZWZFbGVtZW50O1xuZXhwb3J0cy5UU3BhbkVsZW1lbnQgPSBUU3BhbkVsZW1lbnQ7XG5leHBvcnRzLlRleHRFbGVtZW50ID0gVGV4dEVsZW1lbnQ7XG5leHBvcnRzLlRleHRQYXRoRWxlbWVudCA9IFRleHRQYXRoRWxlbWVudDtcbmV4cG9ydHMuVGl0bGVFbGVtZW50ID0gVGl0bGVFbGVtZW50O1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XG5leHBvcnRzLlRyYW5zbGF0ZSA9IFRyYW5zbGF0ZTtcbmV4cG9ydHMuVW5rbm93bkVsZW1lbnQgPSBVbmtub3duRWxlbWVudDtcbmV4cG9ydHMuVXNlRWxlbWVudCA9IFVzZUVsZW1lbnQ7XG5leHBvcnRzLlZpZXdQb3J0ID0gVmlld1BvcnQ7XG5leHBvcnRzLmNvbXByZXNzU3BhY2VzID0gY29tcHJlc3NTcGFjZXM7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IENhbnZnO1xuZXhwb3J0cy5nZXRTZWxlY3RvclNwZWNpZmljaXR5ID0gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eTtcbmV4cG9ydHMubm9ybWFsaXplQXR0cmlidXRlTmFtZSA9IG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWU7XG5leHBvcnRzLm5vcm1hbGl6ZUNvbG9yID0gbm9ybWFsaXplQ29sb3I7XG5leHBvcnRzLnBhcnNlRXh0ZXJuYWxVcmwgPSBwYXJzZUV4dGVybmFsVXJsO1xuZXhwb3J0cy5wcmVzZXRzID0gaW5kZXg7XG5leHBvcnRzLnRvTnVtYmVycyA9IHRvTnVtYmVycztcbmV4cG9ydHMudHJpbUxlZnQgPSB0cmltTGVmdDtcbmV4cG9ydHMudHJpbVJpZ2h0ID0gdHJpbVJpZ2h0O1xuZXhwb3J0cy52ZWN0b3JNYWduaXR1ZGUgPSB2ZWN0b3JNYWduaXR1ZGU7XG5leHBvcnRzLnZlY3RvcnNBbmdsZSA9IHZlY3RvcnNBbmdsZTtcbmV4cG9ydHMudmVjdG9yc1JhdGlvID0gdmVjdG9yc1JhdGlvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndVkycHpJaXdpYzI5MWNtTmxjeUk2VzEwc0luTnZkWEpqWlhORGIyNTBaVzUwSWpwYlhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzaWZRPT1cbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInJlcXVpcmUiLCJfcmVnZW5lcmF0b3JSdW50aW1lIiwiX2FzeW5jVG9HZW5lcmF0b3IiLCJfc2xpY2VkVG9BcnJheSIsIl9kZWZpbmVQcm9wZXJ0eSIsIl9jbGFzc0NhbGxDaGVjayIsIl9jcmVhdGVDbGFzcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIlJHQkNvbG9yIiwiX2luaGVyaXRzIiwiX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iLCJfZ2V0UHJvdG90eXBlT2YiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfZ2V0Iiwic3ZnUGF0aGRhdGEiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkIiwic3RhY2tibHVyQ2FudmFzIiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIl9yZWdlbmVyYXRvclJ1bnRpbWVfX2RlZmF1bHQiLCJfYXN5bmNUb0dlbmVyYXRvcl9fZGVmYXVsdCIsIl9zbGljZWRUb0FycmF5X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnR5X19kZWZhdWx0IiwiX2NsYXNzQ2FsbENoZWNrX19kZWZhdWx0IiwiX2NyZWF0ZUNsYXNzX19kZWZhdWx0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lX19kZWZhdWx0IiwiUkdCQ29sb3JfX2RlZmF1bHQiLCJfaW5oZXJpdHNfX2RlZmF1bHQiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybl9fZGVmYXVsdCIsIl9nZXRQcm90b3R5cGVPZl9fZGVmYXVsdCIsIl90b0NvbnN1bWFibGVBcnJheV9fZGVmYXVsdCIsIl9nZXRfX2RlZmF1bHQiLCJfYXNzZXJ0VGhpc0luaXRpYWxpemVkX19kZWZhdWx0Iiwib2Zmc2NyZWVuIiwiX3JlZiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIkRPTVBhcnNlckZhbGxiYWNrIiwiRE9NUGFyc2VyIiwicHJlc2V0Iiwid2luZG93IiwiaWdub3JlQW5pbWF0aW9uIiwiaWdub3JlTW91c2UiLCJjcmVhdGVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZUltYWdlIiwidXJsIiwibWFyayIsIl9jYWxsZWUiLCJyZXNwb25zZSIsImJsb2IiLCJpbWciLCJ3cmFwIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInByZXYiLCJuZXh0IiwiZmV0Y2giLCJzZW50IiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJhYnJ1cHQiLCJzdG9wIiwiUmVmbGVjdCIsImRlbGV0ZVByb3BlcnR5Iiwibm9kZSIsImNhbnZhcyIsImxvYWRJbWFnZSIsImluZGV4IiwiZnJlZXplIiwiX19wcm90b19fIiwiY29tcHJlc3NTcGFjZXMiLCJzdHIiLCJyZXBsYWNlIiwidHJpbUxlZnQiLCJ0cmltUmlnaHQiLCJ0b051bWJlcnMiLCJtYXRjaGVzIiwibWF0Y2giLCJtYXAiLCJwYXJzZUZsb2F0IiwiYWxsVXBwZXJjYXNlIiwibm9ybWFsaXplQXR0cmlidXRlTmFtZSIsIm5hbWUiLCJ0ZXN0IiwidG9Mb3dlckNhc2UiLCJwYXJzZUV4dGVybmFsVXJsIiwidXJsTWF0Y2giLCJleGVjIiwibm9ybWFsaXplQ29sb3IiLCJjb2xvciIsInN0YXJ0c1dpdGgiLCJyZ2JQYXJ0cyIsIm5vcm1hbGl6ZWRDb2xvciIsIm51bSIsImlzRmxvYXQiLCJTdHJpbmciLCJNYXRoIiwicm91bmQiLCJhdHRyaWJ1dGVSZWdleCIsImlkUmVnZXgiLCJjbGFzc1JlZ2V4IiwicHNldWRvRWxlbWVudFJlZ2V4IiwicHNldWRvQ2xhc3NXaXRoQnJhY2tldHNSZWdleCIsInBzZXVkb0NsYXNzUmVnZXgiLCJlbGVtZW50UmVnZXgiLCJmaW5kU2VsZWN0b3JNYXRjaCIsInNlbGVjdG9yIiwicmVnZXgiLCJnZXRTZWxlY3RvclNwZWNpZmljaXR5Iiwic3BlY2lmaWNpdHkiLCJjdXJyZW50U2VsZWN0b3IiLCJkZWx0YSIsIl9maW5kU2VsZWN0b3JNYXRjaCIsIl9maW5kU2VsZWN0b3JNYXRjaDIiLCJfZmluZFNlbGVjdG9yTWF0Y2gzIiwiX2ZpbmRTZWxlY3Rvck1hdGNoNCIsIl9maW5kU2VsZWN0b3JNYXRjaDUiLCJfZmluZFNlbGVjdG9yTWF0Y2g2IiwiX2ZpbmRTZWxlY3Rvck1hdGNoNyIsIl9maW5kU2VsZWN0b3JNYXRjaDgiLCJfZmluZFNlbGVjdG9yTWF0Y2g5IiwiX2ZpbmRTZWxlY3Rvck1hdGNoMTAiLCJfZmluZFNlbGVjdG9yTWF0Y2gxMSIsIl9maW5kU2VsZWN0b3JNYXRjaDEyIiwiX2ZpbmRTZWxlY3Rvck1hdGNoMTMiLCJfZmluZFNlbGVjdG9yTWF0Y2gxNCIsImpvaW4iLCJQU0VVRE9fWkVSTyIsInZlY3Rvck1hZ25pdHVkZSIsInYiLCJzcXJ0IiwicG93IiwidmVjdG9yc1JhdGlvIiwidSIsInZlY3RvcnNBbmdsZSIsImFjb3MiLCJDQjEiLCJ0IiwiQ0IyIiwiQ0IzIiwiQ0I0IiwiUUIxIiwiUUIyIiwiUUIzIiwiUHJvcGVydHkiLCJkb2N1bWVudCIsImlzTm9ybWFsaXplZENvbG9yIiwia2V5Iiwic3BsaXQiLCJzZXBhcmF0b3IiLCJnZXRTdHJpbmciLCJ0cmltIiwiaGFzVmFsdWUiLCJ6ZXJvSXNWYWx1ZSIsImlzU3RyaW5nIiwicmVnZXhwIiwicmVzdWx0IiwiaXNVcmxEZWZpbml0aW9uIiwiaXNQaXhlbHMiLCJhc1N0cmluZyIsImVuZHNXaXRoIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImRlZiIsImdldE51bWJlciIsIm4iLCJnZXRDb2xvciIsImdldERwaSIsImdldFJlbSIsInJvb3RFbVNpemUiLCJnZXRFbSIsImVtU2l6ZSIsImdldFVuaXRzIiwiZ2V0UGl4ZWxzIiwiYXhpc09ySXNGb250U2l6ZSIsInByb2Nlc3NQZXJjZW50IiwiX3JlZjIiLCJheGlzIiwiaXNGb250U2l6ZSIsInZpZXdQb3J0Iiwic2NyZWVuIiwibWluIiwiY29tcHV0ZVNpemUiLCJtYXgiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRSYWRpYW5zIiwiUEkiLCJnZXREZWZpbml0aW9uIiwiZGVmaW5pdGlvbnMiLCJnZXRGaWxsU3R5bGVEZWZpbml0aW9uIiwiZWxlbWVudCIsIm9wYWNpdHkiLCJjcmVhdGVHcmFkaWVudCIsImN0eCIsImNyZWF0ZVBhdHRlcm4iLCJnZXRIcmVmQXR0cmlidXRlIiwicGF0dGVyblRyYW5zZm9ybSIsImdldEF0dHJpYnV0ZSIsImdldFRleHRCYXNlbGluZSIsInRleHRCYXNlbGluZU1hcHBpbmciLCJhZGRPcGFjaXR5IiwibGVuIiwiY29tbWFzIiwiaSIsIm9rIiwiYWxwaGEiLCJ0b1JHQkEiLCJlbXB0eSIsIlZpZXdQb3J0Iiwidmlld1BvcnRzIiwiY2xlYXIiLCJzZXRDdXJyZW50IiwicHVzaCIsInJlbW92ZUN1cnJlbnQiLCJwb3AiLCJnZXRDdXJyZW50IiwiZCIsImdldCIsIlBvaW50IiwieCIsInkiLCJhbmdsZVRvIiwicG9pbnQiLCJhdGFuMiIsImFwcGx5VHJhbnNmb3JtIiwidHJhbnNmb3JtIiwieHAiLCJ5cCIsInBhcnNlIiwiZGVmYXVsdFZhbHVlIiwiX3RvTnVtYmVycyIsIl90b051bWJlcnMyIiwiX3RvTnVtYmVyczIkIiwiX3RvTnVtYmVyczIkMiIsInBhcnNlU2NhbGUiLCJzY2FsZSIsIl90b051bWJlcnMzIiwiX3RvTnVtYmVyczQiLCJfdG9OdW1iZXJzNCQiLCJfdG9OdW1iZXJzNCQyIiwicGFyc2VQYXRoIiwicGF0aCIsInBvaW50cyIsInBhdGhQb2ludHMiLCJNb3VzZSIsIndvcmtpbmciLCJldmVudHMiLCJldmVudEVsZW1lbnRzIiwib25DbGljayIsImJpbmQiLCJvbk1vdXNlTW92ZSIsImlzV29ya2luZyIsInN0YXJ0Iiwib25jbGljayIsIm9ubW91c2Vtb3ZlIiwiaGFzRXZlbnRzIiwicnVuRXZlbnRzIiwic3R5bGUiLCJjdXJzb3IiLCJmb3JFYWNoIiwicnVuIiwicGFyZW50IiwiY2hlY2tQYXRoIiwiaXNQb2ludEluUGF0aCIsImNoZWNrQm91bmRpbmdCb3giLCJib3VuZGluZ0JveCIsIl9yZWYzIiwiaXNQb2ludEluQm94IiwibWFwWFkiLCJfdGhpcyRzY3JlZW4iLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwib2Zmc2V0UGFyZW50Iiwic2Nyb2xsWCIsInNjcm9sbFkiLCJldmVudCIsIl90aGlzJG1hcFhZIiwiY2xpZW50WCIsImNsaWVudFkiLCJ0eXBlIiwiZXZlbnRUYXJnZXQiLCJfdGhpcyRtYXBYWTIiLCJkZWZhdWx0V2luZG93IiwiZGVmYXVsdEZldGNoJDEiLCJTY3JlZW4iLCJfcmVmJGZldGNoIiwiX3JlZiR3aW5kb3ciLCJGUkFNRVJBVEUiLCJNQVhfVklSVFVBTF9QSVhFTFMiLCJDTElFTlRfV0lEVEgiLCJDTElFTlRfSEVJR0hUIiwibW91c2UiLCJhbmltYXRpb25zIiwid2FpdHMiLCJmcmFtZUR1cmF0aW9uIiwiaXNSZWFkeUxvY2siLCJpc0ZpcnN0UmVuZGVyIiwiaW50ZXJ2YWxJZCIsIndhaXQiLCJjaGVja2VyIiwicmVhZHkiLCJyZWFkeVByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsImlzUmVhZHkiLCJldmVyeSIsIl8iLCJyZXNvbHZlUmVhZHkiLCJzZXREZWZhdWx0cyIsInN0cm9rZVN0eWxlIiwibGluZUNhcCIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsInNldFZpZXdCb3giLCJhc3BlY3RSYXRpbyIsImRlc2lyZWRXaWR0aCIsImRlc2lyZWRIZWlnaHQiLCJfcmVmMiRtaW5YIiwibWluWCIsIl9yZWYyJG1pblkiLCJtaW5ZIiwicmVmWCIsInJlZlkiLCJfcmVmMiRjbGlwIiwiY2xpcCIsIl9yZWYyJGNsaXBYIiwiY2xpcFgiLCJfcmVmMiRjbGlwWSIsImNsaXBZIiwiY2xlYW5Bc3BlY3RSYXRpbyIsIl9jbGVhbkFzcGVjdFJhdGlvJHNwbCIsIl9jbGVhbkFzcGVjdFJhdGlvJHNwbDIiLCJhc3BlY3RSYXRpb0FsaWduIiwiYXNwZWN0UmF0aW9NZWV0T3JTbGljZSIsImFsaWduIiwibWVldE9yU2xpY2UiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZU1pbiIsInNjYWxlTWF4IiwiZmluYWxEZXNpcmVkV2lkdGgiLCJmaW5hbERlc2lyZWRIZWlnaHQiLCJyZWZYUHJvcCIsInJlZllQcm9wIiwiaGFzUmVmcyIsInRyYW5zbGF0ZSIsInNjYWxlZENsaXBYIiwic2NhbGVkQ2xpcFkiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJpc01lZXRNaW5ZIiwiaXNTbGljZU1heFkiLCJpc01lZXRNaW5YIiwiaXNTbGljZU1heFgiLCJfdGhpcyIsIl9yZWYzJGVuYWJsZVJlZHJhdyIsImVuYWJsZVJlZHJhdyIsIl9yZWYzJGlnbm9yZU1vdXNlIiwiX3JlZjMkaWdub3JlQW5pbWF0aW9uIiwiX3JlZjMkaWdub3JlRGltZW5zaW9uIiwiaWdub3JlRGltZW5zaW9ucyIsIl9yZWYzJGlnbm9yZUNsZWFyIiwiaWdub3JlQ2xlYXIiLCJmb3JjZVJlZHJhdyIsInNjYWxlV2lkdGgiLCJzY2FsZUhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwicmVuZGVyIiwibm93IiwiRGF0ZSIsInRoZW4iLCJ0aWNrIiwic2hvdWxkVXBkYXRlIiwiY2FuY2VsIiwicmVkdWNlIiwiYW5pbWF0aW9uIiwidXBkYXRlIiwid2lkdGhTdHlsZSIsImdldFN0eWxlIiwiaGVpZ2h0U3R5bGUiLCJjb25jYXQiLCJjV2lkdGgiLCJjbGllbnRXaWR0aCIsImNIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ2aWV3Qm94IiwieFJhdGlvIiwieVJhdGlvIiwiX3dpZHRoU3R5bGUiLCJpc05hTiIsIl9oZWlnaHRTdHlsZSIsInRyYW5zZm9ybVN0eWxlIiwiY2xlYXJSZWN0IiwiZGVmYXVsdEZldGNoIiwiRGVmYXVsdERPTVBhcnNlciIsIlBhcnNlciIsIl9yZWYkRE9NUGFyc2VyIiwiX3BhcnNlIiwicmVzb3VyY2UiLCJwYXJzZUZyb21TdHJpbmciLCJsb2FkIiwiX3giLCJhcHBseSIsInhtbCIsInBhcnNlciIsImNoZWNrRG9jdW1lbnQiLCJlcnIiLCJwYXJzZXJFcnJvciIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiRXJyb3IiLCJ0ZXh0Q29udGVudCIsIl9sb2FkIiwiX2NhbGxlZTIiLCJfY2FsbGVlMiQiLCJfY29udGV4dDIiLCJ0ZXh0IiwiX3gyIiwiVHJhbnNsYXRlIiwiX3RoaXMkcG9pbnQiLCJ1bmFwcGx5IiwiX3RoaXMkcG9pbnQyIiwiYXBwbHlUb1BvaW50IiwiX3RoaXMkcG9pbnQzIiwiUm90YXRlIiwicm90YXRlIiwidHJhbnNmb3JtT3JpZ2luIiwiYW5nbGUiLCJvcmlnaW5YIiwib3JpZ2luWSIsImN4IiwiY3kiLCJudW1iZXJzIiwidHgiLCJ0eSIsInJhZCIsImNvcyIsInNpbiIsIlNjYWxlIiwic2NhbGVTaXplIiwiX3RoaXMkc2NhbGUiLCJfdGhpcyRzY2FsZTIiLCJfdGhpcyRzY2FsZTMiLCJNYXRyaXgiLCJtYXRyaXgiLCJhIiwiYiIsImMiLCJmIiwiZyIsImgiLCJkZXQiLCJfY3JlYXRlU3VwZXIkTSIsIkRlcml2ZWQiLCJoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRNIiwiX2NyZWF0ZVN1cGVySW50ZXJuYWwiLCJTdXBlciIsIk5ld1RhcmdldCIsImNvbnN0cnVjdG9yIiwiY29uc3RydWN0Iiwic2hhbSIsIlByb3h5IiwiQm9vbGVhbiIsInByb3RvdHlwZSIsInZhbHVlT2YiLCJjYWxsIiwiU2tldyIsIl9NYXRyaXgiLCJfc3VwZXIiLCJza2V3IiwiX2NyZWF0ZVN1cGVyJEwiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEwiLCJTa2V3WCIsIl9Ta2V3IiwidGFuIiwiX2NyZWF0ZVN1cGVyJEsiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEsiLCJTa2V3WSIsInBhcnNlVHJhbnNmb3JtcyIsInBhcnNlVHJhbnNmb3JtIiwiX3RyYW5zZm9ybSRzcGxpdCIsIl90cmFuc2Zvcm0kc3BsaXQyIiwiVHJhbnNmb3JtIiwidHJhbnNmb3JtcyIsImRhdGEiLCJfcGFyc2VUcmFuc2Zvcm0iLCJfcGFyc2VUcmFuc2Zvcm0yIiwiVHJhbnNmb3JtVHlwZSIsInRyYW5zZm9ybVR5cGVzIiwiZnJvbUVsZW1lbnQiLCJfZWxlbWVudCRnZXRTdHlsZSRzcGwiLCJfZWxlbWVudCRnZXRTdHlsZSRzcGwyIiwidHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5IiwiX2VsZW1lbnQkZ2V0U3R5bGUkc3BsMyIsInRyYW5zZm9ybU9yaWdpbllQcm9wZXJ0eSIsInNrZXdYIiwic2tld1kiLCJFbGVtZW50IiwiY2FwdHVyZVRleHROb2RlcyIsImF0dHJpYnV0ZXMiLCJjcmVhdGUiLCJzdHlsZXMiLCJzdHlsZXNTcGVjaWZpY2l0eSIsImFuaW1hdGlvbkZyb3plbiIsImFuaW1hdGlvbkZyb3plblZhbHVlIiwiY2hpbGRyZW4iLCJub2RlVHlwZSIsIkFycmF5IiwiZnJvbSIsImF0dHJpYnV0ZSIsIm5vZGVOYW1lIiwiYWRkU3R5bGVzRnJvbVN0eWxlRGVmaW5pdGlvbiIsIl9zdHlsZSRzcGxpdCRtYXAiLCJfc3R5bGUkc3BsaXQkbWFwMiIsImlkIiwiY2hpbGROb2RlcyIsImNoaWxkTm9kZSIsImFkZENoaWxkIiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImdldFRleHQiLCJjcmVhdGVJZk5vdEV4aXN0cyIsImF0dHIiLCJfYXR0ciIsInNraXBBbmNlc3RvcnMiLCJwYXJlbnRTdHlsZSIsIl9zdHlsZSIsInNhdmUiLCJtYXNrIiwiYXBwbHlFZmZlY3RzIiwiZmlsdGVyIiwic2V0Q29udGV4dCIsInJlbmRlckNoaWxkcmVuIiwiY2xlYXJDb250ZXh0IiwicmVzdG9yZSIsImNsaXBQYXRoU3R5bGVQcm9wIiwiY2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiaWdub3JlQ2hpbGRUeXBlcyIsImluY2x1ZGVzIiwibWF0Y2hlc1NlbGVjdG9yIiwiX25vZGUkZ2V0QXR0cmlidXRlIiwic3R5bGVDbGFzc2VzIiwic29tZSIsInN0eWxlQ2xhc3MiLCJfdGhpcyRkb2N1bWVudCIsImV4aXN0aW5nU3BlY2lmaWNpdHkiLCJyZW1vdmVTdHlsZXMiLCJpZ25vcmVTdHlsZXMiLCJ0b1Jlc3RvcmUiLCJzdHlsZVByb3AiLCJyZXN0b3JlU3R5bGVzIiwiaXNGaXJzdENoaWxkIiwiX3RoaXMkcGFyZW50IiwiaW5kZXhPZiIsIl9jcmVhdGVTdXBlciRKIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRKIiwiVW5rbm93bkVsZW1lbnQiLCJfRWxlbWVudCIsIndyYXBGb250RmFtaWx5IiwiZm9udEZhbWlseSIsInRyaW1tZWQiLCJwcmVwYXJlRm9udEZhbWlseSIsInByb2Nlc3MiLCJwcmVwYXJlRm9udFN0eWxlIiwiZm9udFN0eWxlIiwidGFyZ2V0Rm9udFN0eWxlIiwicHJlcGFyZUZvbnRXZWlnaHQiLCJmb250V2VpZ2h0IiwidGFyZ2V0Rm9udFdlaWdodCIsIkZvbnQiLCJmb250VmFyaWFudCIsImZvbnRTaXplIiwiaW5oZXJpdCIsImluaGVyaXRGb250IiwidG9TdHJpbmciLCJmb250IiwicGFydHMiLCJzZXQiLCJwYXJ0IiwidmFyaWFudHMiLCJ3ZWlnaHRzIiwiX3BhcnQkc3BsaXQiLCJfcGFydCRzcGxpdDIiLCJCb3VuZGluZ0JveCIsIngxIiwiTnVtYmVyIiwiTmFOIiwieTEiLCJ4MiIsInkyIiwiYWRkUG9pbnQiLCJhZGRYIiwiYWRkWSIsImFkZEJvdW5kaW5nQm94Iiwic3VtQ3ViaWMiLCJwMCIsInAxIiwicDIiLCJwMyIsImJlemllckN1cnZlQWRkIiwiZm9yWCIsImIyYWMiLCJ0MSIsInQyIiwiYWRkQmV6aWVyQ3VydmUiLCJwMHgiLCJwMHkiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJhZGRRdWFkcmF0aWNDdXJ2ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJfY3JlYXRlU3VwZXIkSSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkSSIsIlBhdGhQYXJzZXIiLCJfU1ZHUGF0aERhdGEiLCJjb250cm9sIiwiY3VycmVudCIsImNvbW1hbmQiLCJjb21tYW5kcyIsInByZXZpb3VzQ29tbWFuZCIsImFuZ2xlcyIsInJlc2V0IiwiaXNFbmQiLCJnZXRQb2ludCIsInhQcm9wIiwieVByb3AiLCJtYWtlQWJzb2x1dGUiLCJnZXRBc0NvbnRyb2xQb2ludCIsImdldEFzQ3VycmVudFBvaW50IiwiZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50IiwiU1ZHUGF0aERhdGEiLCJDVVJWRV9UTyIsIlNNT09USF9DVVJWRV9UTyIsIlFVQURfVE8iLCJTTU9PVEhfUVVBRF9UTyIsIl90aGlzJGN1cnJlbnQiLCJfdGhpcyRjb250cm9sIiwib3giLCJveSIsInJlbGF0aXZlIiwiX3RoaXMkY3VycmVudDIiLCJhZGRNYXJrZXIiLCJwcmlvclRvIiwiYWRkTWFya2VyQW5nbGUiLCJnZXRNYXJrZXJQb2ludHMiLCJnZXRNYXJrZXJBbmdsZXMiLCJqIiwiX2NyZWF0ZVN1cGVyJEgiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEgiLCJSZW5kZXJlZEVsZW1lbnQiLCJtb2RpZmllZEVtU2l6ZVN0YWNrIiwiY2FsY3VsYXRlT3BhY2l0eSIsIm9wYWNpdHlTdHlsZSIsImZyb21NZWFzdXJlIiwiZmlsbFN0eWxlUHJvcCIsImZpbGxPcGFjaXR5U3R5bGVQcm9wIiwic3Ryb2tlU3R5bGVQcm9wIiwic3Ryb2tlT3BhY2l0eVByb3AiLCJmaWxsU3R5bGUiLCJfZmlsbFN0eWxlIiwiX2ZpbGxTdHlsZTIiLCJfc3Ryb2tlU3R5bGUiLCJfc3Ryb2tlU3R5bGUyIiwic3Ryb2tlV2lkdGhTdHlsZVByb3AiLCJuZXdMaW5lV2lkdGgiLCJsaW5lV2lkdGgiLCJzdHJva2VMaW5lY2FwU3R5bGVQcm9wIiwic3Ryb2tlTGluZWpvaW5TdHlsZVByb3AiLCJzdHJva2VNaXRlcmxpbWl0UHJvcCIsInN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCIsInN0cm9rZURhc2hvZmZzZXRQcm9wIiwiZ2FwcyIsInNldExpbmVEYXNoIiwid2Via2l0TGluZURhc2giLCJtb3pEYXNoIiwib2Zmc2V0IiwibGluZURhc2hPZmZzZXQiLCJ3ZWJraXRMaW5lRGFzaE9mZnNldCIsIm1vekRhc2hPZmZzZXQiLCJmb250U3R5bGVQcm9wIiwiZm9udFN0eWxlU3R5bGVQcm9wIiwiZm9udFZhcmlhbnRTdHlsZVByb3AiLCJmb250V2VpZ2h0U3R5bGVQcm9wIiwiZm9udFNpemVTdHlsZVByb3AiLCJmb250RmFtaWx5U3R5bGVQcm9wIiwiZ2xvYmFsQWxwaGEiLCJwb3BFbVNpemUiLCJfY3JlYXRlU3VwZXIkRyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkRyIsIlBhdGhFbGVtZW50IiwiX1JlbmRlcmVkRWxlbWVudCIsInBhdGhQYXJzZXIiLCJNT1ZFX1RPIiwicGF0aE0iLCJMSU5FX1RPIiwicGF0aEwiLCJIT1JJWl9MSU5FX1RPIiwicGF0aEgiLCJWRVJUX0xJTkVfVE8iLCJwYXRoViIsInBhdGhDIiwicGF0aFMiLCJwYXRoUSIsInBhdGhUIiwiQVJDIiwicGF0aEEiLCJDTE9TRV9QQVRIIiwicGF0aFoiLCJnZXRCb3VuZGluZ0JveCIsImdldE1hcmtlcnMiLCJtYXJrZXJzIiwiZmlsbFJ1bGVTdHlsZVByb3AiLCJmaWxsIiwic2V0VHJhbnNmb3JtIiwic3Ryb2tlIiwibWFya2Vyc0xhc3RJbmRleCIsIm1hcmtlclN0YXJ0U3R5bGVQcm9wIiwibWFya2VyTWlkU3R5bGVQcm9wIiwibWFya2VyRW5kU3R5bGVQcm9wIiwibWFya2VyIiwiX21hcmtlcnMkIiwiX21hcmtlciIsIl9tYXJrZXJzJGkiLCJfcG9pbnQiLCJfYW5nbGUiLCJfbWFya2VyMiIsIl9tYXJrZXJzJG1hcmtlcnNMYXN0SSIsIl9wb2ludDIiLCJfYW5nbGUyIiwiX1BhdGhFbGVtZW50JHBhdGhNIiwiX1BhdGhFbGVtZW50JHBhdGhMIiwiX1BhdGhFbGVtZW50JHBhdGhIIiwiX1BhdGhFbGVtZW50JHBhdGhWIiwiX1BhdGhFbGVtZW50JHBhdGhDIiwiY29udHJvbFBvaW50IiwiY3VycmVudFBvaW50IiwiYmV6aWVyQ3VydmVUbyIsIl9QYXRoRWxlbWVudCRwYXRoUyIsIl9QYXRoRWxlbWVudCRwYXRoUSIsInF1YWRyYXRpY0N1cnZlVG8iLCJfUGF0aEVsZW1lbnQkcGF0aFQiLCJfUGF0aEVsZW1lbnQkcGF0aEEiLCJyWCIsInJZIiwic3dlZXBGbGFnIiwieEF4aXNSb3RhdGlvbiIsImNlbnRwIiwiYTEiLCJhZCIsImRpciIsImFoIiwiaGFsZldheSIsInIiLCJzeCIsInN5IiwiYXJjIiwieFJvdCIsImxBcmNGbGFnIiwiY3VycnAiLCJsIiwicyIsImNwcCIsIl9jcmVhdGVTdXBlciRGIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRGIiwiR2x5cGhFbGVtZW50IiwiX1BhdGhFbGVtZW50IiwiaG9yaXpBZHZYIiwidW5pY29kZSIsImFyYWJpY0Zvcm0iLCJfY3JlYXRlU3VwZXIkRSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkRSIsIlRleHRFbGVtZW50IiwibWVhc3VyZUNhY2hlIiwidGV4dEJhc2VsaW5lIiwiaW5pdGlhbGl6ZUNvb3JkaW5hdGVzIiwibGVhZlRleHRzIiwidGV4dENodW5rU3RhcnQiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1heFgiLCJORUdBVElWRV9JTkZJTklUWSIsIl90aGlzMiIsImdldFRFbGVtZW50Qm91bmRpbmdCb3giLCJhZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlIiwiY2hpbGRCb3VuZGluZ0JveCIsImdldENoaWxkQm91bmRpbmdCb3giLCJnZXRGb250U2l6ZSIsImluaGVyaXRGb250U2l6ZSIsIm1lYXN1cmVUZXh0IiwiZ2V0R2x5cGgiLCJjaGFyIiwiZ2x5cGgiLCJpc0FyYWJpYyIsInByZXZDaGFyIiwibmV4dENoYXIiLCJnbHlwaHMiLCJtYXliZUdseXBoIiwibWlzc2luZ0dseXBoIiwiZ2V0VGV4dEZyb21Ob2RlIiwicGFyZW50Tm9kZSIsImxhc3RJbmRleCIsIl90aGlzMyIsInJlbmRlclRFbGVtZW50Q2hpbGRyZW4iLCJyZW5kZXJDaGlsZCIsInJlbmRlclRleHQiLCJjdXN0b21Gb250IiwidW5pdHNQZXJFbSIsImZvbnRGYWNlIiwiY3R4Rm9udCIsImlzUlRMIiwicmV2ZXJzZSIsImR4IiwibHciLCJmaWxsVGV4dCIsInN0cm9rZVRleHQiLCJhcHBseUFuY2hvcmluZyIsImZpcnN0RWxlbWVudCIsInRleHRBbmNob3IiLCJzaGlmdCIsIl90aGlzNCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlIiwidGV4dFBhcmVudCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXMiLCJ4QXR0ciIsInlBdHRyIiwiZHhBdHRyIiwiZHlBdHRyIiwiZ2V0SW5oZXJpdGVkQXR0cmlidXRlIiwibWVhc3VyZSIsIm1lYXN1cmVUYXJnZXRUZXh0IiwidGFyZ2V0VGV4dCIsIl9tZWFzdXJlIiwiX2N0eCRtZWFzdXJlVGV4dCIsInBhcmVudEF0dHIiLCJfY3JlYXRlU3VwZXIkRCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkRCIsIlRTcGFuRWxlbWVudCIsIl9UZXh0RWxlbWVudCIsIl9jcmVhdGVTdXBlciRDIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRDIiwiVGV4dE5vZGUiLCJfVFNwYW5FbGVtZW50IiwiX2NyZWF0ZVN1cGVyJEIiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JEIiLCJTVkdFbGVtZW50Iiwicm9vdCIsIl90aGlzJG5vZGUkcGFyZW50Tm9kZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9udFNpemVQcm9wIiwiX3NjcmVlbiR2aWV3UG9ydCIsInJlZlhBdHRyIiwicmVmWUF0dHIiLCJ2aWV3Qm94QXR0ciIsInJlc2l6ZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJ3aWR0aEF0dHIiLCJoZWlnaHRBdHRyIiwic3R5bGVBdHRyIiwib3JpZ2luV2lkdGgiLCJvcmlnaW5IZWlnaHQiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ciIsIl9jcmVhdGVTdXBlciRBIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRBIiwiUmVjdEVsZW1lbnQiLCJyeEF0dHIiLCJyeUF0dHIiLCJyeCIsInJ5IiwiS0FQUEEiLCJfY3JlYXRlU3VwZXIkeiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeiIsIkNpcmNsZUVsZW1lbnQiLCJfY3JlYXRlU3VwZXIkeSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkeSIsIkVsbGlwc2VFbGVtZW50IiwiX2NyZWF0ZVN1cGVyJHgiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHgiLCJMaW5lRWxlbWVudCIsImdldFBvaW50cyIsIl90aGlzJGdldFBvaW50cyIsIl90aGlzJGdldFBvaW50czIiLCJfdGhpcyRnZXRQb2ludHMyJCIsIngwIiwieTAiLCJfdGhpcyRnZXRQb2ludHMyJDIiLCJfdGhpcyRnZXRQb2ludHMzIiwiX3RoaXMkZ2V0UG9pbnRzNCIsIl9jcmVhdGVTdXBlciR3IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCR3IiwiUG9seWxpbmVFbGVtZW50IiwiX3BvaW50cyIsIl9wb2ludHMkIiwiX2NyZWF0ZVN1cGVyJHYiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHYiLCJQb2x5Z29uRWxlbWVudCIsIl9Qb2x5bGluZUVsZW1lbnQiLCJfdGhpcyRwb2ludHMiLCJfdGhpcyRwb2ludHMkIiwiX2NyZWF0ZVN1cGVyJHUiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHUiLCJQYXR0ZXJuRWxlbWVudCIsInBhcmVudE9wYWNpdHlQcm9wIiwicGF0dGVyblN2ZyIsInBhdHRlcm5DYW52YXMiLCJwYXR0ZXJuQ3R4IiwiZ2V0Q29udGV4dCIsInBhdHRlcm4iLCJfY3JlYXRlU3VwZXIkdCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkdCIsIk1hcmtlckVsZW1lbnQiLCJvcmllbnQiLCJtYXJrZXJVbml0cyIsIm1hcmtlclN2ZyIsIm92ZXJmbG93IiwiX2NyZWF0ZVN1cGVyJHMiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMiLCJEZWZzRWxlbWVudCIsIl9jcmVhdGVTdXBlciRyIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRyIiwiR0VsZW1lbnQiLCJfY3JlYXRlU3VwZXIkcSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcSIsIkdyYWRpZW50RWxlbWVudCIsImF0dHJpYnV0ZXNUb0luaGVyaXQiLCJzdG9wcyIsIl9hc3NlcnRUaGlzSW5pdGlhbGl6ZSIsImdldEdyYWRpZW50VW5pdHMiLCJzdG9wc0NvbnRhaW5lciIsImluaGVyaXRTdG9wQ29udGFpbmVyIiwiX3N0b3BzQ29udGFpbmVyIiwiZ3JhZGllbnQiLCJnZXRHcmFkaWVudCIsImFkZFBhcmVudE9wYWNpdHkiLCJhZGRDb2xvclN0b3AiLCJfZG9jdW1lbnQkc2NyZWVuIiwiX3ZpZXdQb3J0JHZpZXdQb3J0cyIsInJvb3RWaWV3IiwicmVjdCIsImdyb3VwIiwiYXR0cmlidXRlVG9Jbmhlcml0IiwiY29sb3JQcm9wIiwiX2NyZWF0ZVN1cGVyJHAiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHAiLCJMaW5lYXJHcmFkaWVudEVsZW1lbnQiLCJfR3JhZGllbnRFbGVtZW50IiwiaXNCb3VuZGluZ0JveFVuaXRzIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJfY3JlYXRlU3VwZXIkbyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbyIsIlJhZGlhbEdyYWRpZW50RWxlbWVudCIsImZ4IiwiZnkiLCJmciIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiX2NyZWF0ZVN1cGVyJG4iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG4iLCJTdG9wRWxlbWVudCIsInN0b3BPcGFjaXR5Iiwic3RvcENvbG9yIiwiX2NyZWF0ZVN1cGVyJG0iLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0iLCJBbmltYXRlRWxlbWVudCIsImR1cmF0aW9uIiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbFVuaXRzIiwicmVtb3ZlZCIsImZyb3plbiIsImJlZ2luIiwibWF4RHVyYXRpb24iLCJ0byIsInZhbHVlcyIsInZhbHVlc0F0dHIiLCJnZXRQcm9wZXJ0eSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVOYW1lIiwiY2FsY1ZhbHVlIiwiX3RoaXMkZ2V0UHJvZ3Jlc3MiLCJnZXRQcm9ncmVzcyIsInByb2dyZXNzIiwibmV3VmFsdWUiLCJwcm9wIiwidXBkYXRlZCIsInR5cGVBdHRyIiwicCIsImxiIiwiZmxvb3IiLCJ1YiIsImNlaWwiLCJfY3JlYXRlU3VwZXIkbCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbCIsIkFuaW1hdGVDb2xvckVsZW1lbnQiLCJfQW5pbWF0ZUVsZW1lbnQiLCJjb2xvckZyb20iLCJjb2xvclRvIiwiX2NyZWF0ZVN1cGVyJGsiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsiLCJBbmltYXRlVHJhbnNmb3JtRWxlbWVudCIsInRyYW5zZm9ybUZyb20iLCJ0cmFuc2Zvcm1UbyIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEiLCJvIiwiYWxsb3dBcnJheUxpa2UiLCJpdCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiaXNBcnJheSIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQxIiwiRiIsImRvbmUiLCJfZSIsIlR5cGVFcnJvciIsIm5vcm1hbENvbXBsZXRpb24iLCJkaWRFcnIiLCJzdGVwIiwiX2UyIiwicmV0dXJuIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkkMSIsInNsaWNlIiwiYXJyIiwiYXJyMiIsIl9jcmVhdGVTdXBlciRqIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRqIiwiRm9udEVsZW1lbnQiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImZvbnRGYW1pbHlTdHlsZSIsIl9jcmVhdGVTdXBlciRpIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpIiwiRm9udEZhY2VFbGVtZW50IiwiYXNjZW50IiwiZGVzY2VudCIsIl9jcmVhdGVTdXBlciRoIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoIiwiTWlzc2luZ0dseXBoRWxlbWVudCIsIl9jcmVhdGVTdXBlciRnIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnIiwiVFJlZkVsZW1lbnQiLCJmaXJzdENoaWxkIiwiX2NyZWF0ZVN1cGVyJGYiLCJfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGYiLCJBRWxlbWVudCIsImhhc1RleHQiLCJvcGVuIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfYXJyYXlMaWtlVG9BcnJheSIsIm93bktleXMkMiIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX29iamVjdFNwcmVhZCQyIiwidGFyZ2V0Iiwic291cmNlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY3JlYXRlU3VwZXIkZSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSIsIlRleHRQYXRoRWxlbWVudCIsInRleHRXaWR0aCIsInRleHRIZWlnaHQiLCJwYXRoTGVuZ3RoIiwiZ2x5cGhJbmZvIiwibGV0dGVyU3BhY2luZ0NhY2hlIiwibWVhc3VyZXNDYWNoZSIsIk1hcCIsInBhdGhFbGVtZW50IiwiZGF0YUFycmF5IiwicGFyc2VQYXRoRGF0YSIsInRoZXRhIiwiZFRoZXRhIiwicHNpIiwiZnMiLCJzZXRUZXh0RGF0YSIsInRleHREZWNvcmF0aW9uIiwicm90YXRpb24iLCJwYXJ0aWFsVGV4dCIsImdldExldHRlclNwYWNpbmdBdCIsImlkeCIsImZpbmRTZWdtZW50VG9GaXRDaGFyIiwiYW5jaG9yIiwidGV4dEZ1bGxXaWR0aCIsImZ1bGxQYXRoV2lkdGgiLCJzcGFjZXNOdW1iZXIiLCJpbnB1dE9mZnNldCIsImR5IiwiY2hhckkiLCJnbHlwaFdpZHRoIiwic3BsaW5lU3RlcCIsImdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgiLCJzZWdtZW50IiwiZHlYIiwiZHlZIiwiaGFzIiwiY2hhcnMiLCJ0aGlzU3BhY2luZyIsInBhcmVudFNwYWNpbmciLCJsZXR0ZXJTcGFjaW5nIiwidGV4dExlbiIsImR4U3VtIiwiYWNjIiwiY3VyIiwiZ2V0UGF0aExlbmd0aCIsInN0YXJ0T2Zmc2V0IiwiX3RoaXMyJGZpbmRTZWdtZW50VG9GIiwibmV4dE9mZnNldCIsInBhdGhDb21tYW5kcyIsInN0YXJ0WCIsInN0YXJ0WSIsIm5leHRDb21tYW5kVHlwZSIsImNhbGNMZW5ndGgiLCJfUGF0aEVsZW1lbnQkcGF0aE0kcG8iLCJfUGF0aEVsZW1lbnQkcGF0aEwkcG8iLCJfUGF0aEVsZW1lbnQkcGF0aEgkcG8iLCJfUGF0aEVsZW1lbnQkcGF0aFYkcG8iLCJjb21tYW5kVHlwZSIsImdldExpbmVMZW5ndGgiLCJnZXRQb2ludE9uQ3ViaWNCZXppZXIiLCJnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyIiwiZW5kIiwiaW5jIiwiYWJzIiwiZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMiLCJnZXRQb2ludE9uTGluZSIsImRpc3QiLCJmcm9tWCIsImZyb21ZIiwibSIsInJpc2UiLCJwdCIsIml4IiwiaXkiLCJwUmlzZSIsInBSdW4iLCJnZXRQb2ludE9uUGF0aCIsImRpc3RhbmNlIiwiZnVsbExlbiIsImN1bXVsYXRpdmVQYXRoTGVuZ3RoIiwiY3VycmVudFQiLCJwY3QiLCJwNHgiLCJwNHkiLCJjb3NQc2kiLCJzaW5Qc2kiLCJidWlsZEVxdWlkaXN0YW50Q2FjaGUiLCJpbnB1dFN0ZXAiLCJpbnB1dFByZWNpc2lvbiIsInByZWNpc2lvbiIsImVxdWlkaXN0YW50Q2FjaGUiLCJ0YXJnZXREaXN0YW5jZSIsIl9jcmVhdGVTdXBlciRkIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkIiwiZGF0YVVyaVJlZ2V4IiwiSW1hZ2VFbGVtZW50IiwibG9hZGVkIiwiaHJlZiIsImlzU3ZnIiwiaW1hZ2VzIiwibG9hZFN2ZyIsIl9sb2FkSW1hZ2UiLCJpbWFnZSIsInQwIiwiY29uc29sZSIsImVycm9yIiwiX2xvYWRTdmciLCJzdmciLCJhdG9iIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3ViRG9jdW1lbnQiLCJjYW52ZyIsImZvcmtTdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJfaW1hZ2UiLCJjb21wbGV0ZSIsImRyYXdJbWFnZSIsIl9jcmVhdGVTdXBlciRjIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjIiwiU3ltYm9sRWxlbWVudCIsIlNWR0ZvbnRMb2FkZXIiLCJmb250cyIsInN2Z0RvY3VtZW50IiwiZm9udE5vZGUiLCJfY3JlYXRlU3VwZXIkYiIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYiIsIlN0eWxlRWxlbWVudCIsImNzcyIsImNzc0RlZnMiLCJjc3NQYXJ0cyIsImNzc0NsYXNzZXMiLCJjc3NQcm9wcyIsImNzc0NsYXNzIiwicHJvcHMiLCJjc3NQcm9wIiwic3Vic3RyIiwic3JjcyIsInNyYyIsIl9jcmVhdGVTdXBlciRhIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhIiwiVXNlRWxlbWVudCIsInRlbXBTdmciLCJvbGRQYXJlbnQiLCJlbGVtZW50VHJhbnNmb3JtIiwiY2FjaGVkRWxlbWVudCIsIl9jcmVhdGVTdXBlciQ5IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5IiwiaW1HZXQiLCJfaGVpZ2h0IiwicmdiYSIsImltU2V0IiwidmFsIiwibWkiLCJtMSIsIm0yIiwibTMiLCJGZUNvbG9yTWF0cml4RWxlbWVudCIsImluY2x1ZGVPcGFjaXR5IiwiX3kiLCJzcmNEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwibnIiLCJuZyIsIm5iIiwibmEiLCJwdXRJbWFnZURhdGEiLCJfY3JlYXRlU3VwZXIkOCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkOCIsIk1hc2tFbGVtZW50IiwiaWdub3JlZFN0eWxlcyIsIm1hc2tDYW52YXMiLCJtYXNrQ3R4IiwidG1wQ2FudmFzIiwidG1wQ3R4IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiZmlsbFJlY3QiLCJfY3JlYXRlU3VwZXIkNyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNyIsIm5vb3AiLCJDbGlwUGF0aEVsZW1lbnQiLCJjb250ZXh0UHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsIl9jcmVhdGVTdXBlciQ2IiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2IiwiRmlsdGVyRWxlbWVudCIsInB4IiwicHkiLCJlZmQiLCJleHRyYUZpbHRlckRpc3RhbmNlIiwidG1wQ2FudmFzV2lkdGgiLCJ0bXBDYW52YXNIZWlnaHQiLCJfY3JlYXRlU3VwZXIkNSIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNSIsIkZlRHJvcFNoYWRvd0VsZW1lbnQiLCJfd2lkdGgiLCJfY3JlYXRlU3VwZXIkNCIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkNCIsIkZlTW9ycGhvbG9neUVsZW1lbnQiLCJfY3JlYXRlU3VwZXIkMyIsIl9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMyIsIkZlQ29tcG9zaXRlRWxlbWVudCIsIl9jcmVhdGVTdXBlciQyIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyIiwiRmVHYXVzc2lhbkJsdXJFbGVtZW50IiwiYmx1clJhZGl1cyIsImJvZHkiLCJnZXRVbmlxdWVJZCIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsImNhbnZhc1JHQkEiLCJyZW1vdmVDaGlsZCIsIl9jcmVhdGVTdXBlciQxIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxIiwiVGl0bGVFbGVtZW50IiwiX2NyZWF0ZVN1cGVyIiwiX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCIsIkRlc2NFbGVtZW50IiwiZWxlbWVudHMiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJfY3JlYXRlSW1hZ2UiLCJhbm9ueW1vdXNDcm9zc09yaWdpbiIsIl9hcmdzIiwiY3Jvc3NPcmlnaW4iLCJyZWplY3QiLCJvbmxvYWQiLCJvbmVycm9yIiwiX2V2ZW50IiwiX3NvdXJjZSIsIl9saW5lbm8iLCJfY29sbm8iLCJEb2N1bWVudCIsIl9yZWYkcm9vdEVtU2l6ZSIsIl9yZWYkZW1TaXplIiwiX3JlZiRjcmVhdGVDYW52YXMiLCJfcmVmJGNyZWF0ZUltYWdlIiwiZW1TaXplU3RhY2siLCJ1bmlxdWVJZCIsImJpbmRDcmVhdGVJbWFnZSIsImlzSW1hZ2VzTG9hZGVkIiwiaXNGb250c0xvYWRlZCIsImZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4iLCJjcmVhdGVEb2N1bWVudEVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIkVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGVzIiwiY29uZmlnIiwib3duS2V5cyIsIl9vYmplY3RTcHJlYWQiLCJDYW52ZyIsIm9wdGlvbnMiLCJmb3JrIiwiZnJvbVN0cmluZyIsIl9yZW5kZXIiLCJiYXNlT3B0aW9ucyIsIl9mcm9tIiwiX2FyZ3MyIiwicHJlc2V0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.cjs\n");

/***/ })

};
;